<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<link rel="manifest" href="manifest.webmanifest">

<title>10min's Survivor</title>
<style>
  html,body { margin:0; height:100%; background:#0e0e0f; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
#wrap {
  position:relative;
  width:100%;
  height:100dvh;
  overflow:hidden;
  touch-action:none;
  padding-bottom: env(safe-area-inset-bottom);
}


@supports not (height: 100dvh) {
  #wrap { height:100svh; }
}

canvas {
  position:absolute;
  top:0; left:0; right:0; bottom:0;
  width:100%; height:100%;
  display:block;
}
#start { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:50; pointer-events:auto; }
.hud {
  position:absolute; left:0; right:0; top:0;
  display:flex; gap:.75rem; padding:.5rem .75rem;
  align-items:center; pointer-events:none;

  /* ← ここから追記/置換：セーフエリア考慮しつつ左上Pauseぶんだけ空ける */
  padding-top:  calc(.5rem + env(safe-area-inset-top));
  padding-left: calc(44px  + env(safe-area-inset-left));   /* ← 44pxでPauseを避ける */
  padding-right:calc(.75rem + env(safe-area-inset-right));
}
  .badge { background:#1a1a1a; border:1px solid #333; border-radius:.5rem; padding:.2rem .5rem; font-weight:600; }
  .bar { flex:1; height:.6rem; background:#1a1a1a; border:1px solid #333; border-radius:.4rem; overflow:hidden; }
  .bar > i { display:block; height:100%; width:0%; background:linear-gradient(90deg,#2ecc71,#27ae60); }
  .xp > i { background:linear-gradient(90deg,#3498db,#2980b9); }
  #levelup, #chest { position:absolute; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:12;}
/* === Game Over / Clear overlay (centered & stacked) === */
#gameover, #gameclear{
  position: fixed;
  inset: 0;
  display: none;             /* JSで flex に切替 */
  align-items: center;
  justify-content: center;
  flex-direction: column;    /* ← 縦に並べる（改行と同義） */
  gap: 14px;                 /* 行間 */
  text-align: center;        /* 中央寄せ */
  z-index: 13040;
  background: rgba(0,0,0,.65);
  pointer-events: auto;
}
#gameover > *, #gameclear > *{
  pointer-events: auto;
}

  #cardRow, #chestRow { display:grid; grid-template-columns:1fr; gap:1rem; width:min(900px,92vw); }
  @media (min-width:720px){ #cardRow, #chestRow{ grid-template-columns:repeat(3,1fr);} }
  @media (min-width:1000px){ #chestRow{ grid-template-columns:repeat(5,1fr);} }
  .card { background:#181818; border:1px solid #333; border-radius:.8rem; padding:1rem; box-shadow:0 4px 18px rgba(0,0,0,.45); cursor:pointer; text-align:left; color:#fff; }
  .card h3 { margin:.2rem 0 .4rem; font-size:1.08rem; color:#fff; }
  .card p { margin:0; color:#e5e5e5; line-height:1.38; font-size:.94rem; }
  .card:hover, .card.sel { outline:2px solid #4aa3ff; }
.chestHUD {
  position: fixed;                 /* 固定配置にして重なり順を安定させる */
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 13000;                  /* 半透明オーバーレイ(#chest)より前に */
  display: none;
  gap: .75rem;
  align-items: center;
  pointer-events: none;            /* 親は透過（カードクリックを妨げない） */
}

.chestHUD .badge,
.chestHUD .pickMode {
  pointer-events: auto;            /* 必要なら子はクリック可 */
}

.chestHUD .pickMode{
  font-weight: 800;
  letter-spacing: .04em;
  font-size: clamp(20px, 3.6vw, 40px);
  line-height: 1.1;
  padding: .35rem .9rem;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(18,27,37,.92), rgba(6,11,18,.92));
  color: #E6FF7A;
  text-shadow: 0 1px 0 #000, 0 0 12px rgba(230,255,122,.35);
  outline: 2px solid rgba(230,255,122,.35);
  box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
  backdrop-filter: blur(6px);
}

/* 選択済みカードの視覚強調（任意: ついでに見やすく） */
#chest .card.selected {
  outline: 4px solid #ffd400;
  box-shadow: 0 0 0 3px rgba(0,0,0,.5), 0 8px 20px rgba(0,0,0,.35);
  transform: translateY(-2px);
}

  #start h1 { font-size: clamp(28px, 6vw, 64px); margin:0 0 .5rem; color:#fff; letter-spacing:.02em; }
  #start p { font-size: clamp(14px, 3vw, 22px); margin:0 0 1rem; opacity:.9;}
  .btn { background:#1f6feb; color:#fff; border:none; padding:.7rem 1.1rem; border-radius:.6rem; font-weight:700; cursor:pointer; box-shadow:0 6px 20px rgba(31,111,235,.35); }
  .btn:hover { filter:brightness(1.05); }
  #gameover h2 { font-size: clamp(24px, 5vw, 44px); margin:.25rem 0 .75rem; }
  #gameover .sub { opacity:.85; margin-bottom:1rem; }
  /* 縦持ちのときはHUDを少し縮小 */
@media (orientation:portrait){
  .hud { transform: scale(.9); transform-origin: top center; opacity:.9; }
}

/* かなり狭い端末ではHUDを非表示（後でプレイヤー周りリングで代替） */
@media (max-width:480px){
  .hud { display:none; }

/* さらに狭い幅ならHUDの縮小を強める（HUDを使う構成のままなら） */
@media (max-width:380px){
  .hud { transform: scale(.8); }
}

.bar.hp.low > i {
  background: linear-gradient(90deg,#ff5a5a,#c0392b);
}

}

/* デスクトップ幅は HUD 右にタイマーぶんの余白を空ける */
@media (min-width: 768px){
  .hud{
    padding-right: 140px; /* ← ここで右側のスペース確保（必要なら160〜180に） */
  }
}


.hc-badges{
  position:absolute;
  right: calc(.5rem + env(safe-area-inset-right));
  top:   calc(4.2rem + env(safe-area-inset-top)); /* 「HARDCORE」の少し下 */
  z-index: 16;
  display: none;                 /* 通常は非表示 */
  gap: .35rem;
}

/* === Hardcore badge（ボタンに追従：CSS変数で位置制御） === */
body[data-hc]::after{
  content:"HARDCORE";
  position: fixed;
  right: var(--hc-right);
  top:   var(--hc-top);
  background:#8b5cf6; color:#fff; font-weight:700;
  padding:.2rem .5rem; border-radius:.4rem; opacity:.95;
  box-shadow:0 4px 12px rgba(139,92,246,.35);
  font-size:.85rem;
  z-index: 12005; /* ← ボタン(12010)より下。クリックを邪魔しない */
}

/* 追加の条件バッジを出す場合は、その「さらに下」に固定 */
.hc-badges{
  position: fixed;
  right: var(--hc-right);
  top:   calc(var(--hc-top) + 32px); /* ラベルの下へ */
  z-index: 12005;
  display: none;
  gap: .35rem;
}
body[data-hc] .hc-badges{ display: flex; }
.hc-badges .badge{
  background:#231a3a;
  border:1px solid #5b2a8a;
  color:#e9d5ff;
  padding:.15rem .35rem;
  border-radius:.35rem;
  font-weight:700;
  letter-spacing:.01em;
  font-size:.8rem;
}

/* === Floating Joystick === */
#joyBase, #joyKnob{
  position:fixed; left:0; top:0; transform:translate(-50%,-50%);
  pointer-events:none; display:none; z-index: 10001; /* ⌛やPauseより前面 */
}
#joyBase{
  width:120px; height:120px; border-radius:50%;
  background: radial-gradient(closest-side, rgba(99,102,241,.25), rgba(99,102,241,.08));
  border:1px solid rgba(99,102,241,.45);
  backdrop-filter: blur(2px);
}
#joyKnob{
  width:64px; height:64px; border-radius:50%;
  background: radial-gradient(circle at 35% 35%, #fff, #c7d2fe);
  border:1px solid rgba(99,102,241,.6);
  box-shadow:0 6px 18px rgba(99,102,241,.25);
}

/* === Dock area (情報表示エリア) ====================== */
#dock{
  position:absolute;
  display:none;
  background:rgba(0,0,0,.6);
  color:#fff;
  padding:8px;
  box-sizing:border-box;
  border:1px solid rgba(255,255,255,.06);
  backdrop-filter: blur(2px);
  overflow:auto;
  pointer-events: none;   /* ← タッチを透過してキャンバスへ渡す */
}
#dock.landscape{ border-left:1px solid rgba(255,255,255,.08); }
#dock.portrait { border-top: 1px solid rgba(255,255,255,.08); }

/* === Top HUD band ===================================== */
#hudTop{
  position:absolute;
  left:0; top:0;
  height:56px;
  width:auto;
  display:none;           /* 縦向き時のみJSで 'block' にする */
  color:#fff;
  background:rgba(0,0,0,.45);
  border-bottom:1px solid rgba(255,255,255,.08);
  box-sizing:border-box;
  padding:8px;
  backdrop-filter: blur(2px);
  pointer-events: none;   /* ← 上帯は操作不要なので透過 */
padding-left:  var(--hud-lpad);
  padding-right: var(--hud-rpad);
  margin-top:    var(--hud-tpad);
  box-sizing:    border-box; /* 念のため */
  /* HUD上段がノッチにかぶらないよう安全領域分だけ下げる */
#hudTop, .hud{
  padding-top: calc(8px + var(--safe-top));
}
}

:root{
  --hc-top:   calc(44px + 8px + env(safe-area-inset-top, 0px)); /* デフォルトは Pause の下あたり */
  --hc-right: calc(12px + env(safe-area-inset-right, 0px));

  --hud-lpad: calc(env(safe-area-inset-left, 0px) + 12px);  /* 左余白（初期） */
  --hud-rpad: calc(env(safe-area-inset-right,0px) + 12px);  /* 右余白（初期） */
  --hud-tpad: 0px;                                          /* 上マージン（初期） */
  
    /* iOS等のノッチ安全領域をCSS変数化 */
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-left: env(safe-area-inset-left, 0px);
}

/* === LevelUp layout === */
#levelup{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:12px;
}
#cardRow{
  display:flex; flex-wrap:wrap; gap:12px;
  align-items:stretch; justify-content:center;
  max-width:min(92vw, 920px); margin:0 auto;
}
#rerollBtn{
  display:block; margin:12px auto 0;
}


/* === Timer (共通ベース) === */
#pcTimer{
  position: fixed;
  z-index: 12000;
  pointer-events: none;
  user-select: none;
  font-weight: 900;
  font-variant-numeric: tabular-nums;
  line-height: 1;
  letter-spacing: .04em;
  color: #fff;
  text-shadow: 0 0 18px rgba(255,255,255,.25);
  opacity: .32;
  font-size: clamp(36px, 14vw, 120px);
  background: transparent; border: 0; padding: 0;
  display: none; /* JSで表示切替 */
  transform-origin: top right;
}

/* 横画面ではタイマーを約1/3スケールへ */
@media (orientation: landscape){
  #pcTimer{ font-size: clamp(20px, 4.8vw, 56px); }
}

/* 横向き（PC/タブレット含む）は右上アンカー */
@media (orientation: landscape){
  #pcTimer{
    top:  calc(env(safe-area-inset-top) + 92px);
    right: calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px));
    left: auto; bottom: auto; transform: none; text-align: right;
  }
}

/* 縦向きは下部中央（JSでPLAY幅に合わせて微調整） */
@media (orientation: portrait){
  #pcTimer{
    left: 50%; right: auto; top: auto;
    bottom: calc(env(safe-area-inset-bottom) + 12px);
    transform: translateX(-50%); text-align: center;
  }
}



/* === Top-right buttons (Pause / Sound) === */
#btnPause, #btnSound{
  position: fixed; z-index: 12010;
  pointer-events: auto;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.45);
  color:#fff; border-radius: 999px;
}

/* Pause は“丸ボタン”固定サイズ（横長化を防止） */
#btnPause{
  width: 44px; height: 44px;
  display: inline-flex; align-items: center; justify-content: center;
  font-size: 18px; line-height: 1;
}

/* Sound はラベル付きの横長でOK（サイズは中身依存） */
#btnSound{
  display: inline-flex; align-items: center; gap: 8px; padding: 0 12px;
}

/* 位置指定は JS が入れるので top/left/right はここでは触らない */


/* —— 位置: 端末の向きで切り替え —— */
@media (orientation: landscape){
  /* 横画面：右上。Sound は Pause の左にずらす */
  #btnPause{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 12px); left:auto; }
  #btnSound{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 64px); left:auto; }
}
@media (orientation: portrait){
  /* 縦画面：HUBの上で「のっち」左右に配置 */
  #btnPause{ top:  calc(env(safe-area-inset-top)  + 8px); left:  calc(env(safe-area-inset-left) + 12px);  right:auto; }
  #btnSound{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 12px); left:auto; }
}


@media (orientation: portrait){
  #btnSound{
    right: calc(env(safe-area-inset-right) + 64px);
    top:   calc(env(safe-area-inset-top) + 8px);
  }
}

#btnSound[data-muted="false"]{ box-shadow: 0 6px 16px rgba(16,185,129,.22); }
#btnSound[data-muted="true"] { box-shadow: 0 6px 16px rgba(239,68,68,.22); }

#btnSound .icon{ font-size: 16px; line-height: 1; }
#btnSound .label{ font-size: 12px; line-height: 1; opacity: .95; }
#btnSound{ z-index: 9999; /* ← タイマーより手前 */ }


#btnSound[data-muted="false"]{ background: rgba(16,185,129,.20); }
#btnSound[data-muted="true"] { background: rgba(239,68,68,.20); }
#btnSound:active{ transform: translateY(1px); }

/* 右上UIの重なり回避を強制：デスクトップ幅でタイマーをボタンの左へ */
@media (min-width:768px){
  #btnSound{
   right: calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px));
  }
/* 背景タイマー：右寄せ・前面・クリック透過 */
#pcTimer{
  position: fixed;
  z-index: 12000;                            /* 最前面 */
  pointer-events: none; user-select: none;   /* クリックは背面に通す */

  /* 右上アンカー（必要なら数値だけ調整） */
  top:  calc(env(safe-area-inset-top) + 92px);
  right: calc(env(safe-area-inset-right) + 12px);

  /* ← センタリング解除（必須） */
  left: auto; 
  transform: none;

  /* 表示スタイル */
  font-weight: 900;
  font-variant-numeric: tabular-nums;
  line-height: 1;
  letter-spacing: .04em;
  text-align: right;                         /* 念のため右揃え */
  font-size: clamp(40px, min(12vw, 14vh), 80px);
  color: #fff;
  opacity: .32;                              /* 濃さは .16〜.22 で調整 */
  text-shadow: 0 0 18px rgba(255,255,255,.25);

  background: transparent; border: 0; padding: 0;
  display: none; /* 横向き時は JS で block */
}
}

</style>
</head>
<body>

<div id="wrap">
<div id="start" style="display:flex; flex-direction:column; align-items:center; text-align:center; gap:.5rem;">
  <h1>10min's Survivor</h1>
  <h2>10分間生き延びろ！</h2>
  <p>レベルアップで能力を選び、ボスを倒して生存を目指せ。</p>
  <button id="startBtn" class="btn">スタート</button>
</div>
</div>
  
  <div id="gameover" style="display:none;">
    <h2>ゲームオーバー</h2>
    <div class="sub">もう一度挑戦しよう！</div>
    <button id="retryBtn" class="btn">やり直す</button>
    </div> <!-- ← ここで閉じる -->
<!-- クリア画面 -->
<div id="gameclear" style="display:none;">
  <h2 style="font-size:clamp(28px,6vw,64px); margin:0 0 .75rem;">GAME CLEAR</h2>
  <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
    <button id="replayBtn" class="btn">もう一度遊ぶ</button>
    <button id="hardcoreBtn" class="btn" style="display:none;background:#8b5cf6;">Hardcoreで再挑戦</button>
  </div>
</div>
  
  <canvas id="cv"></canvas>
  
  <!-- 上部HUD（プレイ領域に被せず上に固定） -->
<div id="hudTop" aria-label="top hud"></div>
  <!-- 情報ドック（横長: 右 / 縦長: 下）-->
<div id="dock" aria-label="info dock"></div>

  
  <div class="hud">
    <!-- ▼スコア表示を追加 -->
  <div id="scoreHud" style="font-weight:700; margin:4px 0;">
    SCORE: <span id="scoreVal">0</span>
  </div>
    <span class="badge">Lv <b id="lv">1</b></span>
    <div class="bar hp"><i id="hpw"></i></div>
    <span id="hpval" class="hpval"></span>   <!-- ★ 追加 -->
    <div class="bar xp"><i id="xpw"></i></div>
    <span class="badge">武器: <b id="wep">-</b></span>
  </div>
  <!-- ⏸/▶ ボタン（.hud の外！） -->
  <button id="btnPause" class="hud-btn" aria-label="Pause">⏸</button>
  <div id="levelup"><div id="cardRow"></div></div>
  <div id="chest"><div id="chestRow"></div></div>
  <div class="chestHUD" id="chestHUD"><span class="badge">宝箱：<b id="pickLeft">2</b>つ選択</span></div>
  </div>

<!-- removed: duplicate boss approaching -->
<!-- <div id="bossmsg">!! BOSS APPROACHING !!</div> -->
<!-- removed: legacy gather HUD -->
<!-- <div id="gather"><div class="box"><h3>経験値を集めています</h3><div class="bar xp" style="width:260px;margin:auto;"><i id="gbar"></i></div></div></div> -->


</div>

<script>
// ===== 画面エラー表示ユーティリティ =====
function showErrorBanner(msg){
  let el = document.getElementById('errBanner');
  if(!el){
    el = document.createElement('div');
    el.id = 'errBanner';
    el.style.cssText = 'position:fixed;left:0;right:0;top:0;z-index:99999;background:#b00020;color:#fff;padding:.5rem 1rem;font:14px/1.4 system-ui;white-space:pre-wrap';
    document.body.appendChild(el);
  }
  el.textContent = '⚠ ' + msg;
}
// window.onerror で未捕捉エラーをバナー表示
window.onerror = function(message, source, lineno, colno, error){
  showErrorBanner(`${message} @ ${source}:${lineno}:${colno}`);
};
// unhandledrejection も捕まえる
window.addEventListener('unhandledrejection', e=>{
  showErrorBanner('UnhandledPromiseRejection: ' + (e.reason && (e.reason.stack || e.reason.message || e.reason)));
});

// ===== JavaScript 全文（修正版適用済み） =====
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let W=0,H=0,DPR=1;

// === Sound toggle persistence ===
const SND_KEY = 'sndMuted';

function loadSavedMute(){
  try { return localStorage.getItem(SND_KEY) === '1'; }
  catch(_){ return false; }
}

function saveMute(m){
  try { localStorage.setItem(SND_KEY, m ? '1' : '0'); }
  catch(_){}
}

// 起動時に前回状態を反映
(function(){
  const m = loadSavedMute();
  if (typeof window.setAudioMuted === 'function') setAudioMuted(m);
  else window.AUDIO_MUTED = !!m;
})();

// === Global audio mute flag (BGM/SFX 共通で使える) ===
window.AUDIO_MUTED = !!window.AUDIO_MUTED; // 未定義なら false で初期化

// === Audio Core =========================================================

// === Audio Unlock (desktop autoplay対策・一度だけ) =======================
(function(){
  let done = false;
  function unlock(){
    if (done) return; done = true;
    try{
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();
      // すでにBGMが読めていてミュートでなければ再生
      if (window.bgm && bgm.isReady && bgm.isReady() && !window.AUDIO_MUTED){
        const p = bgm.play(); if (p && p.catch) p.catch(()=>{});
      }
    }catch(_){}
    ['pointerdown','keydown','touchstart','visibilitychange']
      .forEach(ev=>window.removeEventListener(ev, unlock, true));
  }
  ['pointerdown','keydown','touchstart','visibilitychange']
    .forEach(ev=>window.addEventListener(ev, unlock, true));
})();


// === BGM (file-based, loop, SOUNDに連動) ================================
(function(){
  function AC_(){
    if (!window.AC && typeof initAudioOnce === 'function') initAudioOnce();
    return window.AC;
  }
  const BG = { el:null, node:null, gain:null, vol:0.30, ready:false };

  window.bgm = {
    load(url){
      const AC = AC_(); if (!AC) return;
      if (!BG.el){
        BG.el = new Audio();
        BG.el.loop = true;
        BG.el.preload = 'auto';
        // file:/// 直開きでもOK。サーバ配信時は crossOrigin つけてもよい
        BG.node = AC.createMediaElementSource(BG.el);
        BG.gain = AC.createGain();
        BG.gain.gain.value = (window.AUDIO_MUTED ? 0 : BG.vol);
        const dest = (window.bus && (bus.music || bus.master)) ? (bus.music || bus.master) : AC.destination;
        BG.node.connect(BG.gain).connect(dest);
        BG.el.addEventListener('canplay', ()=> BG.ready = true);
      }
      BG.el.src = url;
    },
    play(){ try{ BG.el && BG.el.play(); }catch(_){ /* autoplay規制はStart押下で回避 */ } },
    pause(){ BG.el && BG.el.pause(); },
    setVolume(v){ BG.vol = v; if (BG.gain) BG.gain.gain.value = (window.AUDIO_MUTED ? 0 : v); },
    isReady(){ return !!BG.ready; }
  };
})();


(function(){
  // 既にあれば使う（再宣言しない）
  if (!window.AC) {
    window.AC = null; // AudioContext
  }
  if (!window.bus) {
    window.bus = { master:null, bgm:null, sfx:null, ui:null };
  }
  if (typeof window.AUDIO_MUTED === 'undefined') {
    window.AUDIO_MUTED = false; // 既存があればそのまま
  }

  function initAudioOnce(){
    try{
      if (!window.AC) window.AC = new (window.AudioContext || window.webkitAudioContext)();
      const AC = window.AC;
      if (!bus.master){
        bus.master = AC.createGain();
        bus.master.gain.value = window.AUDIO_MUTED ? 0.0001 : 1.0;
        bus.master.connect(AC.destination);

        bus.bgm = AC.createGain();  bus.bgm.gain.value = 0.25; bus.bgm.connect(bus.master);
        bus.sfx = AC.createGain();  bus.sfx.gain.value = 0.9;  bus.sfx.connect(bus.master);
        bus.ui  = AC.createGain();  bus.ui.gain.value  = 0.8;  bus.ui.connect(bus.master);
      }
    }catch(e){ console.warn('Audio init failed', e); }
  }
  window.initAudioOnce = initAudioOnce;

  // 既存のミュート関数があればそこにフック、無ければ定義
  const _origSetAudioMuted = window.setAudioMuted;
  window.setAudioMuted = function(m){
    window.AUDIO_MUTED = !!m;
    if (typeof _origSetAudioMuted === 'function') {
      try{ _origSetAudioMuted(m); }catch(e){}
    }
    if (!window.AC) return;
    const now = AC.currentTime;
    if (bus.master) bus.master.gain.setTargetAtTime(m ? 0.0001 : 1.0, now, 0.03);
  };

  // 初回タップ/キーでAudioを解錠
  function unlock(){
    initAudioOnce();
    if (window.AC && AC.state === 'suspended') AC.resume();
    document.removeEventListener('pointerdown', unlock, {passive:true});
    document.removeEventListener('keydown', unlock, {passive:true});
  }
  document.addEventListener('pointerdown', unlock, {passive:true});
  document.addEventListener('keydown', unlock, {passive:true});
})();

// 起動時に保存されたミュート状態を反映
(()=>{
  const m = loadSavedMute();
  if (typeof window.setAudioMuted === 'function') setAudioMuted(m);
  else window.AUDIO_MUTED = !!m;
})();


// ==== SFX: Slash Whoosh ===================================
(function(){
  // 既存の AC / bus を使う（無ければフォールバック）
  const AC_ = ()=> window.AC || (window.initAudioOnce && initAudioOnce(), window.AC);
  function getBus(){
    const AC = AC_();
    if (!AC) return null;
    // sfx バス（無ければ master に）
    const bus = (window.bus && (bus.sfx || bus.master)) ? window.bus : null;
    return bus ? (bus.sfx || bus.master) : AC.destination;
  }

  // 共有ホワイトノイズバッファ
  let _noiseBuf = null;
  function noiseBuf(){
    const AC = AC_(); if (!AC) return null;
    if (_noiseBuf) return _noiseBuf;
    const len = Math.floor(AC.sampleRate * 1.0);
    const buf = AC.createBuffer(1, len, AC.sampleRate);
    const ch  = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = Math.random()*2 - 1;
    _noiseBuf = buf; return buf;
  }

  // 風切り音：連撃番号 idx に応じて少し強く/長く
  function playSlashWhoosh(idx=0){
    if (window.AUDIO_MUTED) return;
    const AC = AC_(); const dest = getBus(); const buf = noiseBuf();
    if (!AC || !dest || !buf) return;

    const t0   = AC.currentTime;
    const dur  = 0.10 + 0.02*idx;          // 2発目以降はほんの少し長い
    const peak = 0.20 + 0.06*idx;          // 2発目以降は気持ち大きい

    const src = new AudioBufferSourceNode(AC, {buffer: buf, loop:false});
    const hp  = new BiquadFilterNode(AC, {type:'highpass', frequency:500});
    const bp  = new BiquadFilterNode(AC, {type:'bandpass', Q:0.7, frequency:1400+200*idx});
    const gn  = new GainNode(AC, {gain:0});

    src.connect(hp).connect(bp).connect(gn).connect(dest);

    // エンベロープ（気持ち立ち上がってスッと消える）
    gn.gain.setValueAtTime(0.0001, t0);
    gn.gain.linearRampToValueAtTime(peak, t0 + 0.02);
    gn.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    // フィルタ周波数を軽くスイープ（スパッと切る質感）
    bp.frequency.setValueAtTime(1400+200*idx, t0);
    bp.frequency.exponentialRampToValueAtTime(7000, t0 + Math.min(0.08+0.01*idx, dur));

    try{ src.start(t0); src.stop(t0 + dur + 0.02); }catch(_){}
  }

  // sfx 名前空間に公開
  window.sfx = window.sfx || {};
  window.sfx.slash = playSlashWhoosh;
})();


// HUD を避けて Pause/SOUND の位置を決める（縦=HUBの上, 横=右上で縦積み）
function layoutTopRightUI(){
  const pause = document.getElementById('btnPause');
  const sound = document.getElementById('btnSound');
  if (!pause || !sound) return;

  // 代表的なHUD（なければ null でもOK）
  const hud = document.querySelector('#hudTop, #hud, #hub, .hud, .hub');

  const isVisible = el => !!el && el.offsetParent !== null && getComputedStyle(el).display !== 'none';
  const isPortrait = window.matchMedia && window.matchMedia('(orientation: portrait)').matches;

  const BTN  = 44;      // Pauseの直径
  const GAP  = 8;       // 余白
  const SAFE = 8;       // 画面端のベース余白

  // —— 上端位置の決定 ——
  let topPx = SAFE;     // 既定（HUBが無いなど）
  if (isVisible(hud)) {
    const r = hud.getBoundingClientRect();
    if (isPortrait) {
      // ★ 縦：HUBの“上”に置く（のっちを考慮して少し上寄せ）
      topPx = Math.max(SAFE, Math.round(r.top) - (BTN + GAP));
    } else {
      // ★ 横：常に上端に寄せる（HUBとは縦に分ける）
      topPx = SAFE;
    }
  }

  // —— 位置反映（safe area の分は CSS 側で足す） ——
  if (isPortrait){
    // のっち左=Pause, 右=SOUND
    pause.style.top   = `calc(${topPx}px + env(safe-area-inset-top, 0px))`;
    pause.style.left  = `calc(env(safe-area-inset-left, 0px) + 12px)`;
    pause.style.right = 'auto';

    sound.style.top   = pause.style.top;
    sound.style.right = `calc(env(safe-area-inset-right, 0px) + 12px)`;
    sound.style.left  = 'auto';
  }else{
    // 横：右上にPause、その“真下”にSound（被らない）
    const rightPx = 12;
    pause.style.top   = `calc(${topPx}px + env(safe-area-inset-top, 0px))`;
    pause.style.right = `calc(${rightPx}px + env(safe-area-inset-right, 0px))`;
    pause.style.left  = 'auto';

    const soundTop = topPx + BTN + GAP;
    sound.style.top   = `calc(${soundTop}px + env(safe-area-inset-top, 0px))`;
    sound.style.right = pause.style.right;
    sound.style.left  = 'auto';
  }
  

  // タイマーが右上にある場合の避け幅（任意）：SOUNDの幅をCSS変数へ
  const sndWidth = Math.ceil(sound.getBoundingClientRect().width || 56) + 12;
  document.documentElement.style.setProperty('--snd-offset', sndWidth + 'px');
  
    // ★ HUDの左右余白を“ボタンの実測幅”から算出（縦画面のみ強く効かせる）
  const pauseW = Math.ceil(pause.getBoundingClientRect().width || 44);
  const soundW = Math.ceil(sound.getBoundingClientRect().width || 56);

  if (isPortrait){
    // のっち + ボタン幅 + 少しマージン
    document.documentElement.style.setProperty('--hud-lpad', `calc(env(safe-area-inset-left,0px)  + ${pauseW + 10}px)`);
    document.documentElement.style.setProperty('--hud-rpad', `calc(env(safe-area-inset-right,0px) + ${soundW + 10}px)`);
    // 必要に応じて上方向にも数pxの余裕（重なりが完全に消えるまで微調整）
    document.documentElement.style.setProperty('--hud-tpad', '6px');
  }else{
    // 横画面は控えめ（ほぼ端いっぱい使いたい）
    document.documentElement.style.setProperty('--hud-lpad', `calc(env(safe-area-inset-left,0px)  + 12px)`);
    document.documentElement.style.setProperty('--hud-rpad', `calc(env(safe-area-inset-right,0px) + 12px)`);
    document.documentElement.style.setProperty('--hud-tpad', '0px');
  }
  
    // === Hardcoreバッジ位置を Pause / SOUND に追従させる ===
  // Pauseの「下」に配置（縦向き）／SOUNDの「さらに下」に配置（横向き）
  let hcTopPx = topPx + BTN + GAP;       // Pauseの下
  if (!isPortrait) hcTopPx += BTN + GAP; // 横向きはSoundの下まで下げる

  document.documentElement.style.setProperty('--hc-top',
    `calc(${hcTopPx}px + env(safe-area-inset-top, 0px))`);
  document.documentElement.style.setProperty('--hc-right',
    `calc(12px + env(safe-area-inset-right, 0px))`);

  
}



// 右上UIとタイマーの再レイアウト（安全版：存在チェックつき）
function recalcUi(){
  if (typeof layoutTopRightUI === 'function') layoutTopRightUI();
  if (typeof positionPcTimer === 'function') positionPcTimer();
}
window.addEventListener('load', recalcUi);
window.addEventListener('resize', recalcUi);
window.addEventListener('orientationchange', recalcUi);
setTimeout(recalcUi, 0);
setTimeout(recalcUi, 300);



// ボタン幅が変わったら（SOUND ⇄ MUTE）自動で再計算
const _btn = document.getElementById('btnSound');
if (_btn) new ResizeObserver(()=>layoutTopRightUI()).observe(_btn);


// === SFX Synth ==========================================================
(function(){
function now(){ return (window.AC ? window.AC.currentTime : 0); }

  // 1オシレーター（ADSR）＋周波数グライド（任意）＋パン
  function tone({
    type='square', freq=440, freq2=null,
    t0=now(), a=0.005, d=0.05, s=0.0, r=0.08,
    gain=0.4, pan=0
  }={}){
    if (!AC) return;
    const o = AC.createOscillator(); o.type = type; o.frequency.setValueAtTime(freq, t0);
    if (freq2 && freq2>0){
      // グライド（指数 or 線形は耳で合う方を選択）
      o.frequency.exponentialRampToValueAtTime(freq2, t0 + a + d + r*0.8);
    }
    const g = AC.createGain();
    const p = (AC.createStereoPanner ? AC.createStereoPanner() : null);

    // エンベロープ
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + a);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain*s), t0 + a + d);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + a + d + r);

    o.connect(g);
    if (p){ g.connect(p); p.pan.value = pan; p.connect(bus.sfx); }
    else   { g.connect(bus.sfx); }

    o.start(t0);
    o.stop (t0 + a + d + r + 0.02);
  }

  // ノイズ（HP/LP可・ステレオ任意）
  let NOISE_BUF = null;
  function ensureNoise(){
    if (!AC || NOISE_BUF) return;
    const len = AC.sampleRate * 1.0;
    const buf = AC.createBuffer(1, len, AC.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = Math.random()*2-1;
    NOISE_BUF = buf;
  }
  
function noise({
  t0 = (AC ? AC.currentTime : 0),
  dur = 0.06,
  gain = 0.35,
  hp = null,     // 例: 600
  lp = null,     // 例: 2400
  bp = null,     // 例: 1400（センター周波数）
  q  = 6,        // bp 用 Q（細さ）
  pan = 0
} = {}){
  if (!AC) return;
  ensureNoise();

  const s = AC.createBufferSource(); s.buffer = NOISE_BUF;
  let node = s;

  if (bp){
    const f = AC.createBiquadFilter(); f.type = 'bandpass';
    f.frequency.setValueAtTime(bp, t0);
    f.Q.value = q;
    node.connect(f); node = f;
  }
  if (hp){
    const f = AC.createBiquadFilter(); f.type = 'highpass';
    f.frequency.setValueAtTime(hp, t0);
    node.connect(f); node = f;
  }
  if (lp){
    const f = AC.createBiquadFilter(); f.type = 'lowpass';
    f.frequency.setValueAtTime(lp, t0);
    node.connect(f); node = f;
  }

  const g = AC.createGain();
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  const p = (AC.createStereoPanner ? AC.createStereoPanner() : null);
  if (p){ node.connect(p); p.pan.value = pan; p.connect(g); }
  else  { node.connect(g); }
  g.connect(bus.sfx);

  s.start(t0);
  s.stop(t0 + dur + 0.02);
}


  // カタログ（持続系の一時ノード置き場）
  const live = { laser: null };

  const sfx = {
    // 既存（必要なら微調整してOK）
    shot(opts={}){
      const t = now();
      const base = opts.freq || 1100;
      tone({type:'square',   freq:base,    freq2:base*0.86, t0:t, a:0.003, d:0.05, r:0.06, gain:0.23, pan:opts.pan||0});
      tone({type:'triangle', freq:base*0.5, freq2:base*0.43, t0:t, a:0.002, d:0.045, r:0.06, gain:0.12, pan:opts.pan||0});
    },
    enemyDown(opts={}){
      const t = now();
      noise({t0:t, dur:0.05, gain:0.24, hp:500, pan:opts.pan||0});
      tone({type:'triangle', freq:220, freq2:180, t0:t, a:0.001, d:0.09, r:0.10, gain:0.22, pan:opts.pan||0});
    },
    pickup(){
      const t = now();
      tone({type:'sine', freq:1200, t0:t,       a:0.002, d:0.05, r:0.07, gain:0.22});
      tone({type:'sine', freq:1600, t0:t+0.03,  a:0.002, d:0.05, r:0.07, gain:0.18});
    },
    levelUp(){
      // 少し長く明るく
      const t = now();
      tone({type:'square',   freq:880,  t0:t,        a:0.005, d:0.10, r:0.14, gain:0.30});
      tone({type:'square',   freq:1175, t0:t+0.09,   a:0.005, d:0.12, r:0.16, gain:0.28});
      tone({type:'square',   freq:1568, t0:t+0.18,   a:0.006, d:0.14, r:0.18, gain:0.26});
      tone({type:'triangle', freq:2093, t0:t+0.26,   a:0.006, d:0.16, r:0.20, gain:0.20});
    },

    // ── 新規：電撃・岩・ノヴァ・毒（既に入れていればそのままでOK） ──
    lightning(){
  const AC = window.AC; if (!AC || window.AUDIO_MUTED) return;
  ensureNoise();
  const t0 = AC.currentTime;
  const total = 0.28;

  // 1) 帯電の低い唸り（控えめ、耳に痛くない）
  {
    const o  = AC.createOscillator(); o.type = 'square'; o.frequency.setValueAtTime(120, t0);
    const lfo = AC.createOscillator(); lfo.type='sine'; lfo.frequency.setValueAtTime(16, t0);
    const lfg = AC.createGain(); lfg.gain.value = 8; // ±8Hz
    lfo.connect(lfg); lfg.connect(o.frequency); lfo.start(t0); lfo.stop(t0 + total);

    const g  = AC.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + total);

    o.connect(g); g.connect(bus.sfx);
    o.start(t0); o.stop(t0 + total);
  }

  // 2) スパーク（高域ノイズの破裂をランダムに数回）
  const bursts = 5 + (Math.random()*2|0); // 5〜6発
  for(let i=0;i<bursts;i++){
    const st  = t0 + Math.random()*0.18;
    const dur = 0.05 + Math.random()*0.04; // 50〜90ms
    const n   = AC.createBufferSource(); n.buffer = NOISE_BUF;
    const bp  = AC.createBiquadFilter(); bp.type='bandpass';
    bp.frequency.value = 2500 + Math.random()*1500; bp.Q.value = 6 + Math.random()*4;

    const hp  = AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 900;
    const g   = AC.createGain();
    g.gain.setValueAtTime(0.0001, st);
    g.gain.exponentialRampToValueAtTime(0.32, st + 0.012);
    g.gain.exponentialRampToValueAtTime(0.0001, st + dur);

    n.connect(bp); bp.connect(hp); hp.connect(g); g.connect(bus.sfx);
    n.start(st); n.stop(st + dur + 0.02);
  }
},

 rockRoll(){
  const AC = window.AC; if (!AC || window.AUDIO_MUTED) return;
  ensureNoise();
  const t0  = AC.currentTime;
  const dur = 1.60 + Math.random()*0.25;

  // 地鳴り（低域ノイズを厚めに2段LP）
  const n   = AC.createBufferSource(); n.buffer = NOISE_BUF;
  const lp1 = AC.createBiquadFilter(); lp1.type='lowpass'; lp1.frequency.value = 240; lp1.Q.value = 0.7;
  const lp2 = AC.createBiquadFilter(); lp2.type='lowpass'; lp2.frequency.value = 180; lp2.Q.value = 0.7;
  const g   = AC.createGain();
  g.gain.setValueAtTime(0.0001, t0);
  g.gain.exponentialRampToValueAtTime(0.32, t0 + 0.10);   // ふわっと立ち上げ
  g.gain.exponentialRampToValueAtTime(0.12, t0 + dur*0.6);// ゆるく減衰
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);  // フェード

  // 転がり感（音量トレモロ 3.5Hz）
  const lfo = AC.createOscillator(); lfo.type='sine'; lfo.frequency.value = 3.5;
  const lfg = AC.createGain(); lfg.gain.value = 0.10;
  lfo.connect(lfg); lfg.connect(g.gain);

  n.connect(lp1); lp1.connect(lp2); lp2.connect(g); g.connect(bus.sfx);
  n.start(t0); n.stop(t0 + dur + 0.1);
  lfo.start(t0); lfo.stop(t0 + dur);

  // コツコツ当たる小石（80〜140Hzの短いトンを2〜4回）
  const knocks = 2 + (Math.random()*3|0);
  for(let i=0;i<knocks;i++){
    const st = t0 + 0.15 + Math.random()*(dur-0.35);
    const o  = AC.createOscillator(); o.type='sine';
    o.frequency.setValueAtTime(80 + Math.random()*60, st);
    const og = AC.createGain();
    og.gain.setValueAtTime(0.0001, st);
    og.gain.exponentialRampToValueAtTime(0.18, st + 0.012);
    og.gain.exponentialRampToValueAtTime(0.0001, st + 0.16 + Math.random()*0.06);
    o.connect(og); og.connect(bus.sfx);
    o.start(st); o.stop(st + 0.24);
  }
},

    nova(){
      const t = now();
      tone({type:'sine', freq:220, freq2:420, t0:t, a:0.008, d:0.25, r:0.45, gain:0.32});
      noise({t0:t+0.02, dur:0.35, gain:0.16, lp:800});
    },
    poison(){
      const t = now();
      noise({t0:t, dur:0.25, gain:0.10, lp:1200});
      const n = 5 + (Math.random()*3|0);
      for (let i=0;i<n;i++){
        const dt = t + i*(0.035+Math.random()*0.02);
        const f  = 520 + Math.random()*280;
        tone({type:'sine', freq:f, t0:dt, a:0.001, d:0.04, r:0.06, gain:0.16});
      }
    },

    // ── 重厚な爆発（ボス撃破） ──
bossExplode(){
  const t = now();

  // 初期クラック（高域は控えめ）
  noise({t0:t, dur:0.11, gain:0.34, hp:800, lp:2400});

  // 主ブーム（超低域・長尾）
  const o1 = AC.createOscillator(); o1.type='sine';
  o1.frequency.setValueAtTime(52, t);
  o1.frequency.exponentialRampToValueAtTime(45, t+1.6);
  const g1 = AC.createGain();
  g1.gain.setValueAtTime(0.0001, t);
  g1.gain.exponentialRampToValueAtTime(0.9, t+0.03);
  g1.gain.exponentialRampToValueAtTime(0.0001, t+1.7);
  o1.connect(g1); g1.connect(bus.sfx);
  o1.start(t); o1.stop(t+1.8);

  // 中低域の衝撃層（短めに2層）
  for (let i=0;i<2;i++){
    const tt = t + 0.06 + i*0.05;
    const o = AC.createOscillator(); o.type='triangle';
    o.frequency.setValueAtTime(130, tt);
    o.frequency.exponentialRampToValueAtTime(90, tt+0.35);
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.45, tt+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, tt+0.5);
    o.connect(g); g.connect(bus.sfx);
    o.start(tt); o.stop(tt+0.55);
  }

  // デブリは“コロコロ成分”を削除：ノイズのみで散らす（高域控えめ）
  for (let i=0;i<4;i++){
    const dt = t + 0.10 + i*0.06;
    noise({t0:dt, dur:0.06, gain:0.20, hp:700, lp:2200});
  }

  // 余韻の土埃（低域ノイズを長めに）
  noise({t0:t+0.18, dur:1.2, gain:0.20, lp:450});
},


    // ── ボス：レーザービーム（開始／停止） ──
bossLaserStart(){
  if (!AC || live.laser) return;
  const t = now();

  // 連続音：やや低め＆デチューン少なめ
  const o1 = AC.createOscillator(); o1.type = 'sawtooth'; o1.frequency.setValueAtTime(760, t);
  const o2 = AC.createOscillator(); o2.type = 'sawtooth'; o2.frequency.setValueAtTime(772, t);
  const n  = AC.createBufferSource(); ensureNoise(); n.buffer = NOISE_BUF;

  // 帯域整形（刺さり帯域を減らす）
  const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1400; bp.Q.value = 3.2;
  const lp = AC.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value = 2100; // ←下げた

  const g  = AC.createGain(); g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.26, t+0.04); // ←全体ゲイン小さめ
  const p  = (AC.createStereoPanner? AC.createStereoPanner():null);

  // 配線
  o1.connect(g); o2.connect(g);
  n.connect(bp); bp.connect(lp); lp.connect(g);
  if (p){ g.connect(p); p.pan.value = 0; p.connect(bus.sfx); } else { g.connect(bus.sfx); }

  // ノイズはさらに控えめ
  const ng = AC.createGain(); ng.gain.value = 0.10; // ←下げた
  lp.disconnect(); lp.connect(ng); ng.connect(g);
  n.loop = true;

  o1.start(t); o2.start(t); n.start(t);

  live.laser = { o1, o2, n, g, ng, p, stopAt:null };
},



bossWave(){
  if (!AC) return;
  const t = now();

  // 出力ミキサ：直音 + ディレイを束ねる
  const mix = AC.createGain(); mix.connect(bus.sfx);

  // ディレイ網（シンプルなフィードバック）
  const d   = AC.createDelay();      d.delayTime.value = 0.14; // 140ms
  const fb  = AC.createGain();       fb.gain.value     = 0.30; // フィードバック量
  const dlpf= AC.createBiquadFilter(); dlpf.type='lowpass'; dlpf.frequency.value = 1600;

  // 直列：d → lp → fb → d（ループ）、かつ lp から mix へ
  d.connect(dlpf); dlpf.connect(fb); fb.connect(d);
  dlpf.connect(mix);

  // メイン低域トーン（ブワァン）
  const o  = AC.createOscillator(); o.type='sine';
  o.frequency.setValueAtTime(140, t);
  o.frequency.exponentialRampToValueAtTime(70,  t+0.55);

  const og = AC.createGain();
  og.gain.setValueAtTime(0.0001, t);
  og.gain.exponentialRampToValueAtTime(0.8, t+0.02);
  og.gain.exponentialRampToValueAtTime(0.0001, t+0.65);

  o.connect(og); og.connect(mix); og.connect(d); // 直音+ディレイへ送る
  o.start(t); o.stop(t+0.7);

  // 帯域ノイズで厚み
  const ns = AC.createBufferSource(); ensureNoise(); ns.buffer = NOISE_BUF;
  const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=520; bp.Q.value=1.4;
  const ng = AC.createGain(); ng.gain.setValueAtTime(0.18, t);
  ng.gain.exponentialRampToValueAtTime(0.0001, t+0.45);

  ns.connect(bp); bp.connect(ng); ng.connect(mix); ng.connect(d);
  ns.start(t); ns.stop(t+0.5);
},


warnLevelUp(){
  const t = now();
  // 降下するマイナー2音（短いブザー風）
  const f1 = 740;  // F#5
  const f2 = 622;  // D#5（短三度下）
  for (let i=0;i<2;i++){
    const tt = t + i*0.18;
    const o = AC.createOscillator(); o.type='square';
    o.frequency.setValueAtTime(f1, tt);
    o.frequency.exponentialRampToValueAtTime(f2, tt+0.12);
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.35, tt+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, tt+0.14);
    o.connect(g); g.connect(bus.sfx);
    o.start(tt); o.stop(tt+0.18);
  }
},

warnBoss(){
  const t = now();
  const reps = 3;           // 3連発
  const dur  = 0.42;        // 1発の長さ（ブィーーーの尺）
  const gap  = 0.09;        // 発と発の間
  const f0   = 520;         // 低い出発周波数
  const f1   = 1100;        // 高い到達周波数（上昇終点）

  for (let i = 0; i < reps; i++){
    const tt = t + i * (dur + gap);

    // ざらつきの核：デチューンした鋸波2本を上昇させる
    const o1 = AC.createOscillator(); o1.type = 'sawtooth';
    const o2 = AC.createOscillator(); o2.type = 'sawtooth';
    o1.frequency.setValueAtTime(f0, tt);
    o2.frequency.setValueAtTime(f0 * 1.015, tt); // ほんの少し上にデチューン
    // 低→高へ上昇（指数ランプで“うねり感”）
    o1.frequency.exponentialRampToValueAtTime(f1, tt + dur * 0.9);
    o2.frequency.exponentialRampToValueAtTime(f1 * 1.015, tt + dur * 0.9);

    // 「ザラつき」成分：帯域ノイズを中央周波数ごと上昇させて混ぜる
    const ns = AC.createBufferSource(); ensureNoise(); ns.buffer = NOISE_BUF;
    const bp = AC.createBiquadFilter(); bp.type = 'bandpass';
    bp.frequency.setValueAtTime(900, tt);
    bp.frequency.exponentialRampToValueAtTime(1700, tt + dur * 0.9);
    bp.Q.value = 6;

    const ng = AC.createGain();  // ノイズ量
    ng.gain.setValueAtTime(0.12, tt);
    ng.gain.exponentialRampToValueAtTime(0.10, tt + dur);

    ns.connect(bp); bp.connect(ng);

    // 上の刺さりを少しだけ落とすLPF（ブィーーーの耳当たり調整）
    const lp = AC.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 2400;

    // ゲート包絡（素早い立上げ→保持→リリース）
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.42, tt + 0.016);    // Attack
    g.gain.setValueAtTime(0.42, tt + dur - 0.08);             // Hold
    g.gain.exponentialRampToValueAtTime(0.0001, tt + dur);    // Release

    // ルーティング
    o1.connect(lp); o2.connect(lp); lp.connect(g);
    ng.connect(g);
    g.connect(bus.sfx);

    // 発音
    o1.start(tt); o2.start(tt); ns.start(tt);
    o1.stop(tt + dur + 0.03); o2.stop(tt + dur + 0.03); ns.stop(tt + dur + 0.03);
  }
}
  };

  window.sfx = sfx; // 公開

})();


// === 固定アスペクトのプレイ領域（4:3 / 3:4） ===
const ASPECT_L = 4/3;
const ASPECT_P = 3/4;
const UI_TOP_BAR_CSS = 84; // 上帯の実寸(px)

// HUDをノッチから少し下げる（px）
const HUD_TOP_OFFSET_CSS = 10;

// === World size（実寸）===
const WORLD_L = { w: 1200, h: 900 }; // 横長
const WORLD_P = { w: 900, h: 1200 }; // 縦長
const WORLD   = { w: WORLD_L.w, h: WORLD_L.h };

const PLAY = { x:0, y:0, w:0, h:0, aspect:ASPECT_L, isPortrait:false };

function computePlayRect(){
  const vw = W / DPR, vh = H / DPR;

  // 向きとアスペクト
  const isPortrait = vw <= vh;
  const target = isPortrait ? ASPECT_P : ASPECT_L;

  // CSSの --safe-top を取得
  const safeTopPx = parseFloat(
    getComputedStyle(document.documentElement).getPropertyValue('--safe-top')
  ) || 0;

  // 縦向きのときだけ、上に「ノッチ＋オフセット＋HUD高」を確保
  const topBar = isPortrait ? (safeTopPx + HUD_TOP_OFFSET_CSS + UI_TOP_BAR_CSS) : 0;
  const availH = Math.max(0, vh - topBar);

  // 3:4 / 4:3 を残り領域にフィット
  let w, h;
  if (vw / availH > target){ h = availH; w = h * target; }
  else { w = vw; h = w / target; if (h > availH){ h = availH; w = h * target; } }

  const x = Math.floor((vw - w)/2);
  // ★縦は“HUDの直下にぴったり”配置／横は中央寄せ
  const y = isPortrait ? Math.floor(topBar) : Math.floor((vh - h)/2);

  PLAY.x = x; PLAY.y = y; PLAY.w = w; PLAY.h = h;
  PLAY.aspect = target; PLAY.isPortrait = isPortrait;

  // WORLD 切替（従来どおり）
  if (isPortrait){ WORLD.w = WORLD_P.w; WORLD.h = WORLD_P.h; }
  else           { WORLD.w = WORLD_L.w; WORLD.h = WORLD_L.h; }
}

function updateDock(){
  const dock = document.getElementById('dock');
  if(!dock) return;
  const vw = W / DPR, vh = H / DPR;

  if(PLAY.isPortrait){
    // 縦長：下の黒帯に
    dock.style.left   = PLAY.x + 'px';
    dock.style.top    = (PLAY.y + PLAY.h) + 'px';
    dock.style.width  = PLAY.w + 'px';
    dock.style.height = Math.max(0, vh - (PLAY.y + PLAY.h)) + 'px';
    dock.className = 'portrait';
  }else{
    // 横長：右の黒帯に
    dock.style.left   = (PLAY.x + PLAY.w) + 'px';
    dock.style.top    = PLAY.y + 'px';
    dock.style.width  = Math.max(0, vw - (PLAY.x + PLAY.w)) + 'px';
    dock.style.height = PLAY.h + 'px';
    dock.className = 'landscape';
  }

  // 面積が取れない時は非表示
  const ww = parseFloat(dock.style.width)||0, hh = parseFloat(dock.style.height)||0;
  dock.style.display = (ww > 1 && hh > 1) ? 'block' : 'none';
}

function updateHudTop(){
  const el = document.getElementById('hudTop');
  if (!el) return;

  // 縦向きだけ表示（横では隠す）
  if (!PLAY.isPortrait){
    el.style.display = 'none';
    return;
  }

  // 幅はプレイ面に合わせ、上端は「ノッチ分＋オフセット」だけ下げる
  el.style.left   = PLAY.x + 'px';
  el.style.top    = `calc(var(--safe-top) + ${HUD_TOP_OFFSET_CSS}px)`;
  el.style.width  = PLAY.w + 'px';
  el.style.height = UI_TOP_BAR_CSS + 'px';
  el.style.display = 'block';
}

function ensurePcTimer(){
  let el = document.getElementById('pcTimer');
  if (!el) {
    el = document.createElement('div');
    el.id = 'pcTimer';
    el.textContent = '0:00';
    document.body.appendChild(el);        // ← dock ではなく body へ
  }
  // 表示はJS側で制御したいならここで block に
  el.style.display = 'block';
}

function positionPcTimer(){
  const el = document.getElementById('pcTimer');
  if (!el || !window.PLAY) return;
  
  // 横画面＆小さめ画面(=タッチ端末想定)ならタイマーを 1/3 に
const isLandscape = window.matchMedia && window.matchMedia('(orientation: landscape)').matches;
const isSmallTouch = (Math.min(window.innerWidth, window.innerHeight) <= 900) && ((navigator.maxTouchPoints || 0) > 0);
pcTimer.classList.toggle('pc-mini', isLandscape && isSmallTouch);


  const isPortrait = !!PLAY.isPortrait;
  if (isPortrait){
    // 縦：プレイ領域の下黒帯に幅ピッタリで中央表示
    el.style.left   = PLAY.x + 'px';
    el.style.width  = PLAY.w + 'px';
    el.style.textAlign = 'center';
    el.style.top    = 'auto';
    el.style.right  = 'auto';
    el.style.bottom = 'calc(env(safe-area-inset-bottom) + 12px)';
    el.style.transform = 'none';
  } else {
    // 横：右上（HUDの下）＋muteボタン幅を避ける
    el.style.width  = '';
    el.style.left   = 'auto';
    el.style.right  = 'calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px))';
    el.style.top    = 'calc(env(safe-area-inset-top) + 92px)';
    el.style.bottom = 'auto';
    el.style.textAlign = 'right';
    el.style.transform = 'none';
  }
  el.style.display = 'block';
}


  
function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const r = cv.getBoundingClientRect();
  W = Math.floor(r.width * DPR);
  H = Math.floor(r.height * DPR);
  cv.width = W; 
  cv.height = H;

  // 等倍描画（縮小はしない）
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

// プレイ枠の再計算 → ドック配置 → HUD生成 → HUD位置更新（この順）
computePlayRect();
updateDock();
ensurePcTimer();  // ← 追加：PC用タイマーを一度作っておく
ensureTopHud();
ensureSoundButton(); 
layoutTopRightUI(); 
positionPcTimer();
updateHudTop();

}

// 画面にサウンドボタンを必ず作る（縦=HUD内 / 横=ドック右寄せ）
function ensureSoundButton(){
  let el = document.getElementById('btnSound');
  if (!el){
    el = document.createElement('button');
    el.id = 'btnSound';
    el.innerHTML = `<span class="icon">🔊</span><span class="label">SOUND</span>`;
    el.title = 'Sound On/Off (M)';
    el.addEventListener('click', ()=>{
      initAudioOnce();
      const next = !window.AUDIO_MUTED;
      if (typeof window.setAudioMuted === 'function') setAudioMuted(next);
      else {
        // フォールバック
        window.AUDIO_MUTED = next;
        const AC = window.AC;
        if (window.bus && bus.master && AC){
          const t = AC.currentTime;
          bus.master.gain.setTargetAtTime(next ? 0.0001 : 1.0, t, 0.03);
        }
      }
      if (typeof saveMute === 'function') saveMute(next);
      refreshSoundIcon();
    }, {passive:true});
    document.body.appendChild(el); // canvasより上に固定
  }
  refreshSoundIcon();
  layoutTopRightUI();
}

function refreshSoundIcon(){
  const el = document.getElementById('btnSound');
  if (!el) return;
  const muted = !!window.AUDIO_MUTED;
  el.dataset.muted = String(muted);
  const icon  = el.querySelector('.icon');
  const label = el.querySelector('.label');
  if (icon)  icon.textContent  = muted ? '🔇' : '🔊';
  if (label) label.textContent = muted ? 'MUTE' : 'SOUND';
}


// 保存されたミュート状態を起動時に反映
(function(){
  const m = loadSavedMute();
  if (typeof window.setAudioMuted === 'function') setAudioMuted(m);
  else window.AUDIO_MUTED = !!m;
})();

  new ResizeObserver(resize).observe(cv); resize();
  
  window.addEventListener('orientationchange', resize);
window.addEventListener('resize', resize);
window.addEventListener('resize', layoutTopRightUI);



  const rnd = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  
// 置換：ワールド内の絶対境界（移動・アイテム用）
function worldBounds(radius = 0){
  return {
    minX: 0 + radius,
    maxX: WORLD.w - radius,
    minY: 0 + radius,
    maxY: WORLD.h - radius
  };
}

// 追加：現在ズームで見えている中央の切り抜き（スポーン用）
function visibleBounds(radius = 0){
  const z = (typeof state?.cameraZoom === 'number' && state.cameraZoom > 1) ? state.cameraZoom : 1;
  // z=1 なら WORLD 全面が見えている。z>1 なら中央を (1/z) 倍で切り抜き
  const vw = WORLD.w / z;
  const vh = WORLD.h / z;
  const minX = (WORLD.w - vw) * 0.5 + radius;
  const maxX = (WORLD.w + vw) * 0.5 - radius;
  const minY = (WORLD.h - vh) * 0.5 + radius;
  const maxY = (WORLD.h + vh) * 0.5 - radius;
  return { minX, maxX, minY, maxY };
}

  
  
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy;}
  const pick=(arr)=>arr[(Math.random()*arr.length)|0];

  const state = {
    t:0, last:performance.now(), paused:true, started:false,
    player:{ x:200, y:200, r:14, speed:170, maxHp:110, hp:110, xp:0, level:1, nextXp: (lv)=> 24 + (lv*lv*6), iTime: 0, // 無敵残り時間（秒）
  kbx: 0, kby: 0, // ノックバック速度（px/s）
},
    input:{ vx:0, vy:0, keys:{} , lastDir:{x:1,y:0}},
    enemies:[], bullets:[], enemyBullets:[], gems:[], sparks:[], effects:[], items:[],
    weapons:{}, upgradesTaken:new Set(), owned:new Set(['blaster']),
    spawnTimer:0, difficulty:1, timeSec:0, finalSpawned:false,
    mods:{ sizeMul:1.0, rateMul:1.0, dmgMul:1.0 },
    pickupLv: 0,
    bossTimer: 9999, bigBossTimer: 9999,
        gather:{ active:false, time:0, dur:0.5, totalXP:0 },
        gather:{ active:false, time:0, dur:0.5, totalXP:0 },
magnet:{ active:false, time:0, dur:1.0, speed:1800 },
    winCountdown: 0,
  mode: {
    hardcore: false,          // 現在ハードコアか？
    unlockedHardcore: false,  // ハードコア解放済み？
  }
  
  };
  
  window.state = state; // ← これを必ず追加（参照を単一化）

  // UI
  const lvEl = document.getElementById('lv');
  const hpw = document.getElementById('hpw');
  const hpValEl = document.getElementById('hpval'); // ← 追加
  const xpw = document.getElementById('xpw');
const timeFloatEl = document.getElementById('timeFloat');
  const levelupEl = document.getElementById('levelup');
  const cardRow = document.getElementById('cardRow');
  const wepEl = document.getElementById('wep');
// #bossmsg を削除していても落ちないようにダミーを当てる
const bossMsg = document.getElementById('bossmsg') || {
  style: {},
  classList: { add(){}, remove(){}, toggle(){}, contains(){ return false; } },
  remove(){},
  set textContent(_){}, get textContent(){ return ''; }
};
  const gatherEl = document.getElementById('gather');
  const gbar = document.getElementById('gbar');
  const chestEl = document.getElementById('chest');
  const chestRow = document.getElementById('chestRow');
  const chestHUD = document.getElementById('chestHUD');
  const pickLeftEl = document.getElementById('pickLeft');
  const startEl = document.getElementById('start');
if (!startBtn) {
  console.warn('[init] start button not found');
}  
// Start押下でBGMを読み込み＆再生（1回だけ）
(function(){
  const btn = document.getElementById('startBtn');
  if (!btn || !window.bgm) return;

  btn.addEventListener('click', ()=>{
    try{
      // AudioContext を確実に用意＆再開
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();

      // BGM を必ずロード→音量設定→再生
      bgm.load('main.mp3');      // index.html と同じ階層のファイル名
      bgm.setVolume(0.30);       // 初期音量（お好みで）
      const p = bgm.play();
      if (p && p.catch) p.catch(e=>console.warn('BGM play blocked:', e));
    }catch(e){
      console.warn('BGM start error:', e);
    }
  }, {once:true});
})();

  
  const goEl = document.getElementById('gameover');
  // === 大きいスコア表示 用スタイル注入（1回だけ） ===
(() => {
  if (document.getElementById('score-style')) return;
  const st = document.createElement('style'); st.id = 'score-style';
  st.textContent = `
  .final-score{
    font-size: clamp(36px, 9vw, 84px);
    font-weight: 900;
    letter-spacing: .02em;
    line-height: 1.05;
    margin: .2rem 0 .6rem;
    text-shadow: 0 4px 20px rgba(0,0,0,.35);
  }
  .final-sub{
    font-size: clamp(12px, 2.8vw, 18px);
    opacity: .9;
    margin-bottom: .6rem;
  }
  `;
  document.head.appendChild(st);
})();
  const retryBtn = document.getElementById('retryBtn');
  const clearEl = document.getElementById('gameclear');
const replayBtn = document.getElementById('replayBtn');

// === camera zoom resolver（全端末で等倍固定。拡大・縮小を禁止） ===
function computeCameraZoom(){
  state.cameraZoom = 1.0;
}

function ensureTopHud(){
  const host = document.getElementById('hudTop');
  if (!host || host.dataset.init) return;

  host.dataset.init = '1';
  host.innerHTML = `
    <div class="tophud tophud3" style="height:100%;display:flex;flex-direction:column;gap:6px;padding:0 10px;">
      <!-- 1行目：HP -->
      <div class="row row1" style="display:flex;align-items:center;gap:8px;">
        <span class="label" style="font-size:12px;opacity:.9;min-width:28px;text-align:right;">HP</span>
        <div class="bar hp" style="position:relative;flex:1;height:14px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);border-radius:8px;overflow:hidden">
          <!-- 初期は緑で描画（後でJSが％に応じて赤へ切替）-->
          <i id="hpTop" style="position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#27e38a,#12c574)"></i>
        </div>
        <span class="v" id="hpTopVal" style="font-weight:700;letter-spacing:.02em;white-space:nowrap"></span>
      </div>

      <!-- 2行目：EX -->
      <div class="row row2" style="display:flex;align-items:center;gap:8px;">
        <span class="label" style="font-size:12px;opacity:.9;min-width:28px;text-align:right;">EX</span>
        <div class="bar xp" style="position:relative;flex:1;height:14px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);border-radius:8px;overflow:hidden">
          <i id="xpTop" style="position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#6ae3ff,#4da6ff)"></i>
        </div>
        <span class="v" id="xpTopVal" style="font-weight:700;letter-spacing:.02em;white-space:nowrap"></span>
      </div>

      <!-- 3行目：Lv / WL / タイマー -->
      <div class="row row3" style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
        <span class="v" style="font-weight:700;letter-spacing:.02em">Lv <b id="lvTop">1</b> / WL <b id="wlTop">1</b></span>
        <span class="v" id="timeTop" style="font-weight:800;letter-spacing:.03em">0:00</span>
      </div>
    </div>
  `;
}



const pauseBtn = document.getElementById('btnPause'); 

// === Floating Joystick listeners ===
let joyBase = document.getElementById('joyBase');
let joyKnob = document.getElementById('joyKnob');
// 無ければ動的に作る（HTML追記漏れ対策）
if (!joyBase) { joyBase = document.createElement('div'); joyBase.id = 'joyBase'; document.body.appendChild(joyBase); }
if (!joyKnob) { joyKnob = document.createElement('div'); joyKnob.id = 'joyKnob'; document.body.appendChild(joyKnob); }


function joyShow(x,y){
  joyBase.style.left = x+'px'; joyBase.style.top = y+'px';
  joyKnob.style.left = x+'px'; joyKnob.style.top = y+'px';
  joyBase.style.display = 'block'; joyKnob.style.display = 'block';
}
function joyMove(x,y){
  const r = state.touchJoy.radius;
  let dx = x - state.touchJoy.x0, dy = y - state.touchJoy.y0;
  const len = Math.hypot(dx,dy) || 1;
  const clamp = Math.min(1, len / r);
  dx = dx / len * clamp; dy = dy / len * clamp;
  state.touchJoy.dx = dx; state.touchJoy.dy = dy;
  joyKnob.style.left = (state.touchJoy.x0 + dx * r) + 'px';
  joyKnob.style.top  = (state.touchJoy.y0 + dy * r) + 'px';
}
function joyHide(){
  joyBase.style.display = 'none'; joyKnob.style.display = 'none';
  state.touchJoy.active = false; state.touchJoy.id = null;
  state.touchJoy.dx = 0; state.touchJoy.dy = 0;
}

// どこを押してもジョイスティック出現（PCは無視される）
cv.addEventListener('touchstart', (ev)=>{
  const t = ev.changedTouches[0];
  if (!t) return;
  // 既に他の指でジョイスティック使用中なら何もしない（必要なら2本目は攻撃などに拡張可能）
  if (state.touchJoy.active) return;

  state.touchJoy.active = true;
  state.touchJoy.id = t.identifier;
  state.touchJoy.x0 = t.clientX; state.touchJoy.y0 = t.clientY;
  joyShow(state.touchJoy.x0, state.touchJoy.y0);
  joyMove(t.clientX, t.clientY);
  ev.preventDefault();
}, {passive:false});

cv.addEventListener('touchmove', (ev)=>{
  if (!state.touchJoy.active) return;
  for (const t of ev.changedTouches){
    if (t.identifier === state.touchJoy.id){
      joyMove(t.clientX, t.clientY);
      ev.preventDefault(); break;
    }
  }
}, {passive:false});

cv.addEventListener('touchend', (ev)=>{
  if (!state.touchJoy.active) return;
  for (const t of ev.changedTouches){
    if (t.identifier === state.touchJoy.id){
      joyHide(); ev.preventDefault(); break;
    }
  }
}, {passive:false});

cv.addEventListener('touchcancel', ()=>{ joyHide(); }, {passive:true});



const scoreVal = document.getElementById('scoreVal');



// === Start画面: H/N/F デバッグキー（タイトル表示中のみ有効） ===
(function(){
  function showStartToast(msg){
    const host = document.getElementById('start') || document.body;
    let t = host.querySelector?.('#startToast');
    if (!t){
      t = document.createElement('div');
      t.id = 'startToast';
      t.style.cssText = 'position:absolute;left:50%;transform:translateX(-50%);top:14%;padding:.4em .8em;background:rgba(0,0,0,.6);color:#fff;border-radius:8px;font-weight:600;opacity:0;transition:opacity .12s ease;pointer-events:none;z-index:9999';
      host.appendChild(t);
    }
    t.textContent = msg;
    requestAnimationFrame(()=>{ t.style.opacity = '1'; });
    setTimeout(()=>{ t.style.opacity = '0'; }, 900);
  }

  document.addEventListener('keydown', (ev)=>{
    // タイトル表示中のみ有効
    const s = document.getElementById('start');
    if (!s || s.style.display === 'none') return;
    window.state = window.state || {};
    state.mode = state.mode || {};

    const k = ev.key;
    if (k === 'h' || k === 'H') {
      state.mode.hardcore = true;
      document.body.dataset.hc = state.mode.hardcore ? '1' : '';
      state._debugSkipToFinal = false;
      state._didSkipFinal = false;
      showStartToast('HARDCORE: ON');
    } else if (k === 'n' || k === 'N') {
      state.mode.hardcore = false;
      document.body.dataset.hc = state.mode.hardcore ? '1' : '';
      state._debugSkipToFinal = false;
      state._didSkipFinal = false;
      showStartToast('NORMAL: ON');
    } else if (k === 'f' || k === 'F') {
      // 次のゲーム開始時に最終戦へスキップ
      state._debugSkipToFinal = true;
      state._didSkipFinal = false;
      const startBtn = document.getElementById('startBtn') || s.querySelector('button');
      if (startBtn) startBtn.click();
      showStartToast('Skip to FINAL BOSS');
    }
  }, {passive:true});
})();


// クリックで再スタート
replayBtn.onclick = () => {
  state.mode.hardcore = false;      // ← ノーマルで再挑戦
  clearEl.style.display='none';
  resetGame();
  syncPauseButton();
};

// resetGame() の最後あたりでクリア画面も隠す
clearEl.style.display = 'none';
  
async function tryFullscreenAndLandscape(){
  try{
    // タッチ端末判定
    const isTouch =
      (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ||
      ('ontouchstart' in window) ||
      (navigator.maxTouchPoints > 0);

    // PCや file: ではフルスクリーンを行わない（ESCガイド抑止）
    if (!isTouch || location.protocol === 'file:') return;

    // フルスクリーン（可能な端末）
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();

    // 画面回転ロック（Fullscreen後は成功率UP）
    if (screen.orientation && screen.orientation.lock) {
      try { await screen.orientation.lock('landscape'); } catch(e){}
    }
  } catch (e) {
    console.error('LOOP_CRASH', e);
    if (e && e.stack) console.error('STACKTRACE ↓↓↓\n' + e.stack);
  }
}


// === Start ボタン：単一の完成版ハンドラ（重複禁止） ===
if (typeof window.__START_BOUND === 'undefined') window.__START_BOUND = false;

if (!window.__START_BOUND) {
  const startBtn = document.getElementById('startBtn') || document.querySelector('#start .btn');
  if (startBtn) {
    window.__START_BOUND = true;
    startBtn.onclick = async () => {
      ensureEndScoreNodes();
      await tryFullscreenAndLandscape();
      resetGame();                     // ゲーム初期化
      state.started = true;
      state.paused  = false;
      document.getElementById('start').style.display = 'none';
      state.last = performance.now();
      syncPauseButton();
    };
  } else {
    console.warn('[init] start button not found');
  }
}


retryBtn.onclick = () => { ensureEndScoreNodes();resetGame(); syncPauseButton(); };


function syncPauseButton(){
  if (!pauseBtn) return;
  // 表示は manualPaused を見て決める（▶=停止中／⏸=動作中）
  const showingPlay = !!state.manualPaused;
  pauseBtn.textContent = showingPlay ? '▶' : '⏸';
  pauseBtn.setAttribute('aria-label', showingPlay ? 'Resume' : 'Pause');
}



if (pauseBtn){
  pauseBtn.onclick = () => {
    // レベルアップ/宝箱オーバーレイ中は無効化
    const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
    const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
    if (lvlOpen || chestOpen) return;

    state.manualPaused = !state.manualPaused;
    syncPauseButton();
  };
}

// === Game Over 一括処理 ===
function triggerGameOver(){
  if (state.gameover) return;
  state.gameover = true;

  // 入力を止める
  state.manualPaused = false;
  if (state.input){ state.input.vx = 0; state.input.vy = 0; }

  // プレイヤー非表示（描画側でも見ない）
  if (state.player) state.player.visible = false;

  // UI
  if (goEl) goEl.style.display = 'flex';
  
ensureEndScoreNodes();
updateEndScore('over');

  // フローティング・ジョイスティックOFF
  delete document.body.dataset.fjoy;
}

// === エンド画面（GO/クリア）に大スコアを差し込む ===
function ensureEndScoreNodes(){
  // GameOver
  if (goEl){
    let big = goEl.querySelector('.final-score');
    if (!big){
      big = document.createElement('div');
      big.className = 'final-score';
      goEl.insertBefore(big, goEl.firstChild);
    }
    let sub = goEl.querySelector('.final-sub');
    if (!sub){
      sub = document.createElement('div');
      sub.className = 'final-sub';
      goEl.insertBefore(sub, big.nextSibling);
    }
  }
  // Clear
  if (clearEl){
    let big = clearEl.querySelector('.final-score');
    if (!big){
      big = document.createElement('div');
      big.className = 'final-score';
      clearEl.insertBefore(big, clearEl.firstChild);
    }
    let sub = clearEl.querySelector('.final-sub');
    if (!sub){
      sub = document.createElement('div');
      sub.className = 'final-sub';
      clearEl.insertBefore(sub, big.nextSibling);
    }
  }
}

function updateEndScore(kind){ // kind: 'over' | 'clear'
  const kill = Math.max(0, Math.floor(state.killScore || 0));
  const boss = Math.max(0, Math.floor(state.bossBonus || 0));
  const n    = kill + boss;  // Kill + Boss の合計

  const root = (kind === 'clear') ? clearEl : goEl;
  if (!root) return;
  const big = root.querySelector('.final-score');
  const sub = root.querySelector('.final-sub');

  const key  = (state.mode && state.mode.hardcore) ? 'best_hc' : 'best';
  let prev = 0;
  try { prev = +(localStorage.getItem(key) || 0) || 0; } catch(_) {}
  const best = Math.max(n, prev);
  try { localStorage.setItem(key, String(best)); } catch(_) {}

  if (big) big.textContent = `SCORE  ${n.toLocaleString()}` + (n > prev ? '  ★NEW!' : '');
  const detail = `Kill: ${kill.toLocaleString()}  /  BOSS TIME BONUS ${boss.toLocaleString()}   Best: ${best.toLocaleString()}`;
  if (sub) sub.textContent = detail;
}




  function resetGame(){
    // Clear arrays
    state.enemies.length=0; state.bullets.length=0; state.enemyBullets.length=0;
    state.gems.length=0; state.sparks.length=0; state.effects.length=0; state.items.length=0;



// Reset player
state.player.x = WORLD.w * 0.5;
state.player.y = WORLD.h * 0.5;
state.player.aimAngle = 0; // 初期向き（右向き相当）

    state.player.r = 14;
    state.player.speed = 170;
    state.player.maxHp = 110;
    state.player.hp = 110;
    state.player.xp = 0;
    state.player.level = 1;
    state.player.iTime = 0;
state.player.kbx = 0;
state.player.kby = 0;
state.pickupLv = 0;
    // Reset meta
    state.manualPaused = false;
    state.mods.sizeMul = 1.0;
    state.spawnTimer = 0;
    state.difficulty = 1;
    state.timeSec = 0;
    state.finalSpawned = false;
    state.bossTimer = 9999;
    state.bigBossTimer = 9999;
    state.gather.active = false; state.gather.time = 0; state.gather.totalXP = 0;
    state.gather.active = false; state.gather.time = 0; state.gather.totalXP = 0;
state.magnet.active = false; state.magnet.time = 0;

      state.winCountdown = 0;
    state.score = 0;
state.killScore = 0;
state.bossBonus = 0;
state.kills = 0;
state.bossKills = 0;


// === touch joystick state ===
// 既にあれば使い回し、無ければ作成
if (!state.touchJoy) {
  state.touchJoy = { active:false, id:null, x0:0, y0:0, x:0, y:0, dx:0, dy:0, radius:56 };
} else {
  state.touchJoy.active = false;
  state.touchJoy.id = null;
  state.touchJoy.x0 = 0; state.touchJoy.y0 = 0;
  state.touchJoy.x = 0;  state.touchJoy.y = 0;
  state.touchJoy.dx = 0; state.touchJoy.dy = 0;
  state.touchJoy.radius = 56; // 操作感はここで調整
}

    // Reset upgrades
    state.upgradesTaken = new Set();
    state.owned = new Set(['blaster']);
    // Reset weapons
    for(const k in state.weapons){
      const w = state.weapons[k];
      w.lv = (k==='blaster')? 1 : 0;
      w.awaken = false;
      if('cd' in w) w.cd = 0;
      if(k==='orbit'){ w.ang = 0; }
    }
    
    state.gameover = false;
if (state.player) state.player.visible = true;
    
    // UI
    levelupEl.style.display='none';
    chestEl.style.display='none';
    chestHUD.style.display='none';
if (gatherEl) gatherEl.style.display = 'none';
    goEl.style.display='none';
    state.started = true;
    state.paused = false;
    state.last = performance.now();
    clearEl.style.display='none';
    
    // === score & records ===
state.score = 0;                 // 現在スコア
state.killScore = 0;             // キルのみの加算追跡（任意）
state.bossBonus = 0;             // ボス撃破ボーナス

// === viewport zoom（縦画面は少し引く）===
computeCameraZoom();


state.records = JSON.parse(localStorage.getItem('vs_records') || '[]'); // [{score,timeSec,date,hardcore}]


  }

function hoistPcTimerToBody(){
  const el = document.getElementById('pcTimer');
  if (el && el.parentNode !== document.body){
    document.body.appendChild(el);
  }
}


function updateHUD(){
  lvEl.textContent = state.player.level;

  hpw.style.width = (100*state.player.hp/state.player.maxHp)+'%';
    // ★ HP数値の更新
  if (hpValEl) {
hpValEl.textContent = `${Math.max(0, Math.floor(state.player.hp))} / ${Math.floor(state.player.maxHp)}`;
  }
  
  xpw.style.width = (100*state.player.xp/state.player.nextXp(state.player.level))+'%';

const m   = Math.floor(state.timeSec/60);
const s   = (state.timeSec%60)|0;
const txt = `${m}:${String(s).padStart(2,'0')}`;
const tf  = document.getElementById('timeFloat'); // 常に浮遊タイマーへ
if (tf) tf.textContent = `⌛ ${txt}`;

  const names = Object.entries(state.weapons)
    .filter(([k,w])=>w.lv>0)
    .map(([k,w])=> `${w.short}${w.lv}${w.awaken?'★':''}`);
  wepEl.textContent = names.join(', ') || '-';
  
const bodyEl = document.body;
if (state.mode.hardcore) {
  bodyEl.dataset.hc = "1";
} else {
  delete bodyEl.dataset.hc;
}

if (scoreVal) scoreVal.textContent = Math.floor(state.score || 0);

// === Top HUD 同期 ===
(function(){
  const p = state.player;
  if (!p) return;

  const hpNow = Math.max(0, Math.min(p.hp, p.maxHp || 0));
  const hpPct = (p.maxHp > 0) ? (hpNow / p.maxHp) * 100 : 0;

  // XP / 次レベル必要量
  const xp = Math.max(0, state?.player?.xp || 0);
  let needXP = 0;
  if (typeof p.nextXp === 'function')           needXP = p.nextXp(p.level);
  else if (typeof state?.nextXp === 'function') needXP = state.nextXp(p.level);
  else if (typeof state?.xpToNext === 'function') needXP = state.xpToNext(p.level);
  const xpPct = needXP > 0 ? Math.min(100, (xp / needXP) * 100) : 0;

  // 参照要素
  const hpTop    = document.getElementById('hpTop');
  const hpTopVal = document.getElementById('hpTopVal');
  const xpTop    = document.getElementById('xpTop');
  const xpTopVal = document.getElementById('xpTopVal');
  const lvTop    = document.getElementById('lvTop');
  const wlTop    = document.getElementById('wlTop');
  const timeTop  = document.getElementById('timeTop');

  // HP：幅＆色（20%以下で赤／それ以外は緑）
  if (hpTop){
    hpTop.style.width = hpPct.toFixed(1) + '%';
    const low = hpPct <= 20;
    hpTop.style.background = low
      ? 'linear-gradient(90deg,#ff6464,#ff3a3a)'
      : 'linear-gradient(90deg,#27e38a,#12c574)';
  }
  if (hpTopVal) hpTopVal.textContent = `${Math.floor(hpNow)} / ${p.maxHp || 0}`;

  // EX：幅＆数値
  if (xpTop)    xpTop.style.width = xpPct.toFixed(1) + '%';
  if (xpTopVal) xpTopVal.textContent = needXP > 0 ? `${Math.floor(xp)} / ${needXP}` : `${Math.floor(xp)}`;

  // Lv / 武器Lv
  if (lvTop) lvTop.textContent = p.level || 1;
  const wl =
    (state?.weapons?.main?.level) ??
    (state?.weaponLevel) ??
    (p?.weaponLevel) ?? 1;
  if (wlTop) wlTop.textContent = wl;

  // タイマー（mm:ss）— 一度だけ計算して両方に使う
  const t  = Math.max(0, Math.floor(state?.timeSec || 0));
  const mm = String(Math.floor(t/60));
  const ss = String(t%60).padStart(2,'0');

  if (timeTop) timeTop.textContent = `${mm}:${ss}`;
// 大タイマーも同期（表示位置は positionPcTimer で調整）
const pcTimer = document.getElementById('pcTimer');
if (pcTimer){
  pcTimer.textContent = `${mm}:${ss}`;
  pcTimer.style.display = 'block';
  if (typeof positionPcTimer === 'function') positionPcTimer();
}

  
  
})();



  }

  
  
  
// 安全に #wrap を取得してからリスナー登録
{
  const wrapEl = document.getElementById('wrap');
  if (wrapEl) {
    wrapEl.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  } else {
    console.warn('[init] #wrap element not found (skipped touchmove preventDefault)');
  }
}

window.addEventListener('keydown', e=>{
if(e.key==='p'||e.key==='P'){ 
  const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
  const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
  if (!(lvlOpen || chestOpen)) {
    state.manualPaused = !state.manualPaused;
    syncPauseButton();
  }
}

// L：ラスボスにデバッグダメージ（Shift+L で即死級）
if (e.key === 'l' || e.key === 'L') {
  const finals = (state?.enemies || []).filter(en => en?.type === 'final');
  if (finals.length === 0) {
    console.warn('[debug] final boss not found');
  } else {
    const dmg = e.shiftKey ? 99999 : 5000;
    for (const b of finals) {
      if (!Number.isFinite(b.hp)) continue;
      const before = b.hp;
      b.hp = Math.max(0, b.hp - dmg);
      b.hitFlash = 0.2;

      if (typeof addEffect === 'function') {
        addEffect('text', { text: `-${Math.min(dmg, before).toFixed(0)}`, x: b.x, y: b.y - 22, life: 0.6, color: '#ff7a7a' });
      }
      // ★HPが0になったら確実に撃破処理へ
      if (b.hp <= 0 && typeof safeKillEnemy === 'function') {
        safeKillEnemy(b);
      }
    }
  }
}
if (e.key === 'j' || e.key === 'J') state.player.hp = Math.max(0, state.player.hp - 25);
if (e.key === 'k' || e.key === 'K') state.player.hp = Math.min(state.player.maxHp, state.player.hp + 25);


  state.input.keys[e.key]=true;
});
  window.addEventListener('keyup', e=>{ state.input.keys[e.key]=false; });
  function keyboardVec(){
    const k = state.input.keys; let x=0,y=0;
    if(k['ArrowLeft']||k['a']) x-=1; if(k['ArrowRight']||k['d']) x+=1;
    if(k['ArrowUp']||k['w']) y-=1; if(k['ArrowDown']||k['s']) y+=1;
    const m=Math.hypot(x,y)||1; return {x:x/m,y:y/m};
  }

// Spawns
function spawnEnemy(){
  const B = worldBounds();              // ← ズーム反映の表示境界
  const margin = 30;
  const side = Math.floor(Math.random()*4);
  let x, y;

  // 画面の四辺「外」から湧かせる（ズーム対応）
  if (side === 0) { // 上
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.minY - margin;
  } else if (side === 1) { // 右
    x = B.maxX + margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  } else if (side === 2) { // 下
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.maxY + margin;
  } else { // 左
    x = B.minX - margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  }

  const shooterProb = state.timeSec > 150 ? 0.04 : 0.0;

  if (Math.random() < shooterProb) {
    // 射撃タイプ
    let hp = (20 + state.difficulty*2.5) * 1.5;
    if (state.mode.hardcore) hp *= 1.5;

    // ねらい：プレイヤー（※画面中心にしたいなら (B.minX+B.maxX)/2 などでも可）
    const tx = state.player.x, ty = state.player.y;
    const dx = tx - x, dy = ty - y; const m = Math.hypot(dx, dy) || 1;
    const dir = { x: dx/m, y: dy/m };

    state.enemies.push({
      x, y, size:20, hp, maxHp:hp, type:'shooter',
      phase:'move', dir, moved:0, moveDist:rnd(240,360),
      moveSpeed:120, cd:rnd(0.2,0.8), hitFlash:0, kbx:0, kby:0
    });
  } else {
    // 近接タイプ
    let hp = 16 + state.difficulty*2.2;
    if (state.mode.hardcore) hp *= 1.5;
    if (state.timeSec >= 360) hp *= 2.0;

    const dForSpeed = Math.min(state.difficulty, 16);
    const sp = 30 + dForSpeed*4.5;

    state.enemies.push({
      x, y, size:18, hp, maxHp:hp, speed:sp, type:'minion',
      hitFlash:0, kbx:0, kby:0
    });
  }
}

function spawnMidBoss(){
  const B = worldBounds();           // ← ズーム反映の表示境界
  const margin = 80;
  const side = Math.floor(Math.random()*4);
  let x,y;

  // 画面の四辺「外」から湧かせる
  if (side===0){ // 上
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.minY - margin;
  } else if (side===1){ // 右
    x = B.maxX + margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  } else if (side===2){ // 下
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.maxY + margin;
  } else { // 左
    x = B.minX - margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  }

  let hp = 420 + state.difficulty*120;
  if (state.timeSec>=360) hp *= 1.6;
  if (state.mode.hardcore) hp *= 1.5;

  const e = {
    x,y, size:48, hp, maxHp:hp, speed:80, type:'mid',
    cd:0, hitFlash:0, kbx:0, kby:0
  };

  state.enemies.push(e);
  flashBossMsg();
}

function spawnBigBoss(){
  const B = worldBounds();           // ← ズーム反映の表示境界
  const margin = 100;
  const side = Math.floor(Math.random()*4);
  let x,y;

  // 画面の四辺「外」から湧かせる
  if (side===0){ // 上
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.minY - margin;
  } else if (side===1){ // 右
    x = B.maxX + margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  } else if (side===2){ // 下
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.maxY + margin;
  } else { // 左
    x = B.minX - margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  }

  let hp = 1000 + state.difficulty*240;
  if (state.timeSec>=360) hp *= 1.6;
  if (state.mode.hardcore) hp *= 1.5;

  const e = {
    x,y, size:70, hp, maxHp:hp, speed:95, type:'big',
    cd:0, phase:'shoot', tele:0, dashCD:6, dashDir:{x:0,y:0},
    hitFlash:0, kbx:0, kby:0
  };

  state.enemies.push(e);
  flashBossMsg();
}

// 旧：#bossmsg DOM を直接いじる実装 → 削除後にエラー化
// 新：ボス告知は別UIで出すため、ここは無害化しておく
function flashBossMsg(ms = 2000, text = '!! BOSS APPROACHING !!') {
  // no-op（何もしない）
}
  // XP & particles
  function dropGem(x,y,val=1){ state.gems.push({x,y,r:5+val, val}); }
  function spark(x,y,cnt=8){
    for(let i=0;i<cnt;i++){
      const a=rnd(0,Math.PI*2), v=rnd(40,160);
      state.sparks.push({x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, t:0, life:.4});
    }
  }
  
  function playerHit(dmg, sx, sy){
  // すでに無敵なら無視
  if (state.player.iTime > 0) return;

  state.player.hp -= dmg;
  state.player.iTime = 1.0; // 無敵1.0秒

  // ノックバック：被弾元→プレイヤーの逆方向へ
  const dx = state.player.x - sx;
  const dy = state.player.y - sy;
  const m = Math.hypot(dx, dy) || 1;
  const kb = 360; // 初速(px/s) 小さめノックバック
  state.player.kbx = (dx / m) * kb;
  state.player.kby = (dy / m) * kb;

  // ちょいフラッシュ
  addEffect('flash', { life: .03 });

  if (state.player.hp <= 0) {
    gameOver();
  }
}

  
function addEffect(type, data){
  state.effects.push({ type, ...data });
}
// Items
function spawnItemRandom(){
  let chance = 0.03;
  if (state.mods.doubleItem) chance *= 2;   // ← ここはそのまま

  if (Math.random() < chance) {
    const B = worldBounds();        // ← ズーム対応の表示境界
    const pad = 30;                 // 画面端から少し内側に出す
    const x = rnd(B.minX + pad, B.maxX - pad);
    const y = rnd(B.minY + pad, B.maxY - pad);

    const roll = Math.random();
    const kind = roll < 0.45 ? 'magnet' : roll < 0.75 ? 'nuke' : 'heal';
    const rByKind =
  kind==='magnet' ? 10 :
  kind==='nuke'   ? 10 :
  kind==='heal'   ? 14 :   // ★ ここを 18（= 12 * 1.5）
  kind==='chest'  ? 14 : 12;
state.items.push({ kind, x, y, r:rByKind, t:0 });
  }
}

  function applyItem(it){
if(it.kind==='magnet'){
  // ポーズ無し・全XP高速吸引（必達）
  state.magnet.active = true;
  state.magnet.time   = 0;
  state.magnet.dur    = 1.0;   // 効果時間（秒）
  state.magnet.speed  = 1800;  // 基準速度（通常220の約5倍）

  // 見た目（任意）：オーラの寿命を効果時間に合わせる
  addEffect('aura', { x: state.player.x, y: state.player.y, r: 60, life: state.magnet.dur, life0: state.magnet.dur });
}else if(it.kind==='nuke'){
  // 演出：白い光の円が素早く広がる
  const R = Math.hypot(cv.width / DPR, cv.height / DPR) * 0.85;
  addEffect('whiteCharge', { x: state.player.x, y: state.player.y, r0: 22, r1: 120, life: 0.08 });
  addEffect('megaNova',    { x: state.player.x, y: state.player.y, r: R, life: 0.35 });
  addEffect('flash',       { life: 0.03 });
  const NUKE_KILL_SCORE = 5;   // 1体あたりの少額スコア
  const NUKE_SCORE_CAP  = 50;  // 一掃1回あたりの上限

  let killed = 0, gained = 0;
  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const e = state.enemies[i];
    if (e.type === 'minion' || e.type === 'shooter') {
      // 少額スコア（上限あり）
      if (gained < NUKE_SCORE_CAP) {
        gained += NUKE_KILL_SCORE;
        if (gained > NUKE_SCORE_CAP) gained = NUKE_SCORE_CAP;
      }
      // XP控えめ
      dropGem(e.x, e.y, 1);
      spark(e.x, e.y, 16);
      state.enemies.splice(i, 1);
      killed++;
    }
  }
  if (gained > 0) {
    state.score += gained;
    state.killScore = (state.killScore || 0) + gained;
    if (scoreVal) scoreVal.textContent = Math.floor(state.score);
  }
  addEffect('text', { x: state.player.x, y: state.player.y, life: 1.2, text: `一掃(${killed})` });
}else if(it.kind==='heal'){
      const amount = Math.round(state.player.maxHp * 0.35);
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + amount);
      addEffect('text',{x:state.player.x,y:state.player.y,life:1.2,text:`回復 +${amount}`});
    addEffect('healSparkles', { x: state.player.x, y: state.player.y, r: 46, life: 0.7, life0: 0.7, count: 14 });
    }else if(it.kind==='chest'){
      openChest(it.picks||2);
    }
  }
function openChest(pickCount = 2) {
  state.paused = true;

  // オーバーレイ表示
  chestEl.style.display = 'flex';
  chestHUD.style.display = 'flex';

  // 見出し「1つ選択／2つ選択」を動的に用意
  let pickModeEl = document.getElementById('pickMode');
  if (!pickModeEl) {
    pickModeEl = document.createElement('div');
    pickModeEl.id = 'pickMode';
    pickModeEl.className = 'pickMode';
    // HUDの先頭に配置（残りバッジの左側）
    chestHUD.prepend(pickModeEl);
  }

  // 枚数表示（既存要素があれば更新）
  let picksLeft = pickCount;
  const updatePickHUD = () => {
    // 例：「2つ選択（残り1/2）」または「1つ選択」
    const modeText = (pickCount === 1) ? '1つ選択' : `${pickCount}つ選択`;
    pickModeEl.textContent = (pickCount > 1) ? `${modeText}（残り${picksLeft}/${pickCount}）` : modeText;
    if (typeof pickLeftEl !== 'undefined' && pickLeftEl) {
      pickLeftEl.textContent = picksLeft;
    }
  };

  // カード行の初期化
  chestRow.innerHTML = '';

  // 候補を抽選（can() を満たすものから最大5つ）
  const pool = ALL_UPGRADES.filter(u => u.can());
  const choices = [];
  while (choices.length < 5 && pool.length) {
    const i = (Math.random() * pool.length) | 0;
    choices.push(pool.splice(i, 1)[0]);
  }

  // 既定の“選択済み”状態は無し（クリックして初めて選択）
  const chosen = new Set();

  // カード生成
  for (const u of choices) {
    const c = document.createElement('button');
    c.className = 'card';
    c.innerHTML = `<h3>${u.name}</h3><p>${u.desc || ''}</p>`;

    c.onclick = () => {
      if (picksLeft <= 0 || chosen.has(u)) return;
      try {
        // 先に適用（失敗したら確定しない）
        const ret = (typeof u.apply === 'function') ? u.apply() : true;
        if (ret === false) return;

        chosen.add(u);
        c.classList.add('selected');
        picksLeft--;
        updatePickHUD();

        if (picksLeft <= 0) {
          // 少し演出を見せてから閉じる
          setTimeout(() => {
            chestEl.style.display = 'none';
            chestHUD.style.display = 'none';
            state.paused = false;
          }, 150);
        }
      } catch (err) {
        console.error('Chest upgrade apply failed:', u && u.name, err);
      }
    };

    chestRow.appendChild(c);
  }

  // 初期表示を更新
  updatePickHUD();
  
  // 選択数が2枚以上のときは、見出しを一瞬だけ軽く拡大（アクセシビリティ向上）
if (pickCount > 1) {
  pickModeEl.animate([{ transform: 'translateY(-2px) scale(1.0)' }, { transform: 'translateY(-2px) scale(1.06)' }, { transform: 'translateY(-2px) scale(1.0)' }], { duration: 380, easing: 'ease-out' });
}

}


function addXP(v){
  // 時間倍率
  v = Math.round(v * xpMulByTime());
  // Hardcore補正（例：取得 -25%）
  if (state.mode.hardcore) v = Math.round(v * 0.75);

  state.player.xp += v;
  while (state.player.xp >= state.player.nextXp(state.player.level)) {
    state.player.xp -= state.player.nextXp(state.player.level);
    state.player.level++;
    if (state.player.level === 3) {
      state.bossTimer = 60 + Math.random()*20;
      state.bigBossTimer = 140 + Math.random()*30;
    }
    offerUpgrades();
  }
}

// ==== 修正版 offerUpgrades（リロール対応） ====
function pickUpgradeChoices(n=3){
  const pool = ALL_UPGRADES.filter(u => u.can());
  const choices = [];
  while (choices.length < n && pool.length) {
    const i = (Math.random() * pool.length) | 0;
    choices.push(pool.splice(i, 1)[0]);
  }
  return choices;
}

function offerUpgrades(){
  // このレベルアップ中にリロールを使ったかどうか（1回だけ）
  window._rerollUsedThisLevel = false;
  const choices = pickUpgradeChoices(3);
  showLevelUp(choices);
}

function xpMulByTime(){
  if(state.timeSec < 360) return 1.0;              // 〜6:00 は等倍
  const t = Math.min(1, (state.timeSec - 360) / 240); // 6:00→10:00 の 240秒で段階上げ
  return 1.0 + t * 0.8;                            // 10:00で最大1.8倍（例）
}

// ==== 修正版 showLevelUp（リロール対応） ====
function showLevelUp(choices){
  // 参照は毎回取り直し（スコープ差異・重複定義対策）
  const levelupEl = document.getElementById('levelup');
  const cardRow   = document.getElementById('cardRow');
  if (!levelupEl || !cardRow) return;

  state.paused = true;
  levelupEl.style.display = 'flex';
  cardRow.innerHTML = '';

  // 選択カードを並べる（従来と同じ）
  for (const u of choices) {
    const c = document.createElement('button');
    c.className = 'card';
    c.innerHTML = `<h3>${u.name}</h3><p>${u.desc || ''}</p>`;
    c.onclick = () => {
      // 能力を適用して閉じる
      u.apply();
      state.paused = false;
      levelupEl.style.display = 'none';
      cardRow.innerHTML = '';
      // 次のレベルアップではまた1回リロール可能に
      window._rerollUsedThisLevel = false;
      // リロールボタンが残っていれば念のため無効化
      const btn = document.getElementById('rerollBtn');
      if (btn) btn.disabled = true;
    };
    cardRow.appendChild(c);
  }

  // ===== リロール・ボタン（このレベルアップ中は1回だけ） =====
  let rr = document.getElementById('rerollBtn');
  if (!rr){
    rr = document.createElement('button');
    rr.id = 'rerollBtn';
    rr.className = 'btn';
    rr.textContent = 'リロール（1回だけ）';
    // レイアウトは控えめに：カード行の下へ配置
    rr.style.margin = '12px auto 0';
    rr.style.display = 'block';
    levelupEl.appendChild(rr);
  }
  // 状態反映
  rr.disabled = !!window._rerollUsedThisLevel;
  rr.textContent = window._rerollUsedThisLevel ? 'リロール使用済み' : 'リロール（1回だけ）';

  rr.onclick = () => {
    if (window._rerollUsedThisLevel) return;
    window._rerollUsedThisLevel = true;
    // 新しい3択を作り直して、同じUIに差し替え
    const newChoices = pickUpgradeChoices(3);
    showLevelUp(newChoices);
    // 今回は使用済みにする
    const btn = document.getElementById('rerollBtn');
    if (btn){
      btn.disabled = true;
      btn.textContent = 'リロール使用済み';
    }
  };

  // 最初のカードにフォーカス（キーボード操作のしやすさ向上）
  const first = cardRow.querySelector('.card');
  if (first) first.focus();
}


  // === Weapons with Awaken ===
  const weapons = {
blaster:{ short:'BL', name:'ブラスター', lv:1, awaken:false, cd:0, baseRate:.48, baseDmg:12, baseSpeed:360, range:500, rangeAwaken:660,
      update(dt){
        if(this.lv<=0) return;
        this.cd-=dt; if(this.cd>0) return;
        const target = nearestEnemy(state.player.x,state.player.y); if(!target) return;
        const dmg = (this.baseDmg + 3*(this.lv-1)) * (this.awaken? 1.2:1);
        const rate = this.awaken ? 0.05 : Math.max(.05, this.baseRate * (1 - 0.22*(this.lv-1)));
        const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const off = 6;
        let positions;
        if(this.lv>=3){ positions = [0, -off, off]; }
        else if(this.lv>=2){ positions = [-off, off]; }
        else { positions = [0]; }
        // 弾数を考慮して1発あたりの威力を調整
const shotCount = positions.length;
const lifeEach = ((this.awaken ? this.rangeAwaken : this.range) / this.baseSpeed);


for(const o of positions){
  state.bullets.push({
    type:'bullet',
    x: state.player.x + nx*o,
    y: state.player.y + ny*o,
    vx: Math.cos(ang) * this.baseSpeed,
    vy: Math.sin(ang) * this.baseSpeed,
    r: 5 * state.mods.sizeMul,
    dmg: (dmg * state.mods.dmgMul) / Math.max(1, shotCount * 0.90), // ★ 調整
    life: lifeEach
      });

}
        this.cd = rate * state.mods.rateMul;
      }
    },
    shotgun:{
  short:'SG', name:'ショットガン',
  lv:0, awaken:false, cd:0,
  baseRate:1.2, baseDmg:20, baseSpeed:340, // ★ 基礎ダメージUP（12→15）
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const target = nearestEnemy(state.player.x, state.player.y);
    if(!target) return;

    const count = 5 + (this.lv-1)*2;                // 弾数は今のまま
    const spread = 0.2 - 0.02*(this.lv-1);           // 拡散も今のまま
    const dmg = (this.baseDmg + 3*(this.lv-1))      // ★ 伸び率を+3に強化（+2→+3）
                 * state.mods.dmgMul;

    for(let i=0;i<count;i++){
      const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x) + rnd(-spread,spread);
      state.bullets.push({
        type:'bullet',
        x: state.player.x, y: state.player.y,
        vx: Math.cos(ang)*this.baseSpeed,
        vy: Math.sin(ang)*this.baseSpeed,
        r: 4*state.mods.sizeMul,
        dmg,
        life: 1.0  // ★ 寿命を少し短縮（1.2→1.0）で「近距離専用感」
      });
    }

    if(this.awaken){
      const n = 24;
      for(let k=0;k<n;k++){
        const ang = (Math.PI*2*k)/n;
        state.bullets.push({
          type:'bullet',
          x: state.player.x, y: state.player.y,
          vx: Math.cos(ang)*this.baseSpeed*0.9,
          vy: Math.sin(ang)*this.baseSpeed*0.9,
          r: 4*state.mods.sizeMul,
          dmg: this.baseDmg * 0.85 * state.mods.dmgMul, // ★ 覚醒時は1発少し弱め
          life: 0.8
        });
      }
    }

    this.cd = Math.max(.45, this.baseRate * (1 - 0.15*(this.lv-1)))
              * (this.awaken? 0.8:1)
              * state.mods.rateMul;
  }
},

homing:{
  short:'HM', name:'ホーミング',
  lv:0, awaken:false, cd:0,
  baseRate:2.4, baseDmg:16,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const count = (2 + (this.lv-1)) * (this.awaken? 1.5:1);
    for(let i=0;i<Math.ceil(count);i++){
      const ang = Math.random()*Math.PI*2;
      const power = this.baseDmg * (this.awaken? 1.4:1);
      const life = this.awaken ? 6.0 : 8.0;

      state.bullets.push({
        type:'homing',
        x: state.player.x, y: state.player.y,
        vx: Math.cos(ang)*170,
        vy: Math.sin(ang)*170,
        r: 6*state.mods.sizeMul,
        dmg: power * state.mods.dmgMul,
        life: life,
        seek: 400,
        turn: 7.2,
        bigBoom: this.awaken,           // 爆発ON
        boomR: this.awaken ? 120 : 60,  // ★ 爆発半径（通常60 → 覚醒110）
        boomMul: this.awaken ? 1.0 : 0.7 // ★ 覚醒は等倍、通常はちょい減衰
      });
    }

    this.cd = Math.max(1.2, this.baseRate * (1 - 0.2*(this.lv-1)))
              * (this.awaken? 0.85:1)
              * state.mods.rateMul;
  }
},

lightning:{ short:'LT', name:'ライトニング', lv:0, awaken:false, cd:0, baseRate:2.2, baseDmg:16,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    // ★Lvで本数増／覚醒は常に7発
    let count = this.awaken ? 7 : Math.max(1, this.lv); // Lv1=1, Lv2=2, Lv3=3

    const targets = pickMultiple(state.enemies, count);
    if(!targets.length) return;
    for(const e of targets){
      strikeLightning(e, 1 + 0.25*(this.lv-1));
    }

    this.cd = Math.max(0.8, this.baseRate * (1 - 0.22*(this.lv-1))) * (this.awaken? 0.65:0.9) * state.mods.rateMul;
  }
},

rock:{
  short:'RK', name:'ロック', lv:0, awaken:false, cd:0, baseRate:1.0,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const activeRocks = state.bullets.filter(b=>b.type==='rock').length;
    if(activeRocks>0) return;

    let dir = state.input.lastDir;
    if(Math.hypot(dir.x,dir.y) < 0.1){
      const t = nearestEnemy(state.player.x,state.player.y);
      if(t){ const a = Math.atan2(t.y-state.player.y, t.x-state.player.x); dir = {x:Math.cos(a), y:Math.sin(a)}; }
      else { dir={x:1,y:0}; }
    }

    const sizeBase = (24 + (this.lv-1)*7) * state.mods.sizeMul; // 少しだけ大きめ
    const speed    = 190;                                      // 150→170
    const baseDmg  = (25 + 10*(this.lv-1)) * state.mods.dmgMul; // 18+6*(lv-1) → 28+10*(lv-1)
    const bossMul  = 1.1; // mid/big/final には25%増し

const addRock=(ang)=>{
  const sz  = sizeBase * (this.awaken ? 2.0 : 1.0);
  state.bullets.push({
    type:'rock',
    x:state.player.x, y:state.player.y,
    vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed,
    r:sz,
    dmg:baseDmg,
    life:3.4,                 // 3.2→3.4（少し長く転がる）
    pierce:true,
    bossMul,                  // 当たり側で参照
    spin: Math.random()*Math.PI*2   // ★ 初期自転角（0でもOK）
  });
};

    const base = Math.atan2(dir.y,dir.x);
    if(this.awaken){
      const spread = Math.PI * 2 / 3;
      addRock(base); addRock(base + spread); addRock(base - spread);
    }else{
      addRock(base);
    }
    this.cd = Math.max(0.9, this.baseRate * (1 - 0.10*(this.lv-1))) * (this.awaken? 1.25:1);
  }
},

orbit:{
  short:'OR', name:'オービット',
  lv:0, awaken:false, count:0,
  baseR:72,          // 72 → 84（序盤でも届きやすく）
  dmg:9,             // 7 → 9（接触DPSの元）
  ang:0,
  // 追加パラメータ
  hitRBase:14,       // 玉の当たり半径の基準（描画もこれに合わせる）
  dpsBase:10,        // 接触DPSの基準（レベルで伸ばす）
  kbBase:220,        // ノックバック基準（/秒）
  update(dt){
    if(this.lv<=0) return;
    this.ang += dt*(this.awaken? 3.6:1.8); // 回転ちょい速め
  }
},
    
blade:{
  short:'BD', name:'ブレード', lv:0, awaken:false, cd:0,
  // 調整しやすい基礎値
  short:'BD', name:'ブレード', lv:0, awaken:false, cd:0,
  baseRate: 1.10,     // ← 発生は少し遅め（近接リスクのご褒美に）
  baseDmg:  55,       // ← 威力UP（元:26）
  span:     Math.PI * 0.62, // 横に広い
  inner:    10,             // 足元の当たり開始
  outer:    130,            // 最大到達（基礎）
  fxSpeed:  360,            // ← 見た目の前進速度UP（元:220）
  reachLv:  22,             // ← Lvごとに“到達距離”を+18px


update(dt){
  if (this.lv <= 0) return;
  this.cd -= dt; if (this.cd > 0) return;

  // 向き：移動方向（停止中のみ最近敵へフォールバック）
  let dir = state.input.lastDir;
  if (Math.hypot(dir.x, dir.y) < 0.1){
    const t = nearestEnemy(state.player.x, state.player.y);
    if (t){
      const a = Math.atan2(t.y - state.player.y, t.x - state.player.x);
      dir = { x: Math.cos(a), y: Math.sin(a) };
    } else {
      dir = { x: 1, y: 0 };
    }
  }
  const baseAng = Math.atan2(dir.y, dir.x);

  // 連撃数：Lvで +1（最大3）、覚醒で6
  const count = this.awaken ? 6 : Math.min(1 + (this.lv - 1), 3);

  // ★ レベルに応じた“到達距離”ボーナスとダメージ補正
  const reachBonus = (this.reachLv || 0) * Math.max(0, this.lv - 1);
  const innerR = this.inner * state.mods.sizeMul;
  const outerR = (this.outer + reachBonus) * state.mods.sizeMul;
  const dmgBase = this.baseDmg * (1 + 0.25 * (this.lv - 1)); // ← 成長率UP（元:0.18）

  const comboDelay = 0.1; // 1発ごとの時差
  for (let i = 0; i < count; i++){
    const off = (i - (count - 1)/2) * 0.10; // 角度ずらし
    schedule(() => {
      const a = baseAng + off;

      // ---- ダメージ（当たり判定）：到達距離をLvで伸ばす ----
      const dmg = Math.round(dmgBase * state.mods.dmgMul);
      dealSlashDamage(
        state.player.x, state.player.y,
        a, this.span,
        innerR, outerR,
        dmg
      );

      // ---- 見た目（前へ出ながらフェード）：速度もLvで少し増加 ----
      const v = (this.fxSpeed || 360) + 100 * Math.max(0, this.lv - 1); // ← 前進距離をレベルで増やす
      addEffect('slash', {
        x: state.player.x, y: state.player.y,
        ang: a, span: this.span,
        inner: this.inner * state.mods.sizeMul,
        outer: (this.outer + reachBonus) * state.mods.sizeMul,
        life: 0.16 + 0.01 * Math.max(0, this.lv - 1), // 少し長く見せる
        life0: 0.16 + 0.01 * Math.max(0, this.lv - 1),
        vx: Math.cos(a) * v,
        vy: Math.sin(a) * v,
        comboIdx: i
      });
    }, i * comboDelay);
  }

// 次発までのクールダウン（Lvで短縮、覚醒でさらに少し短縮）
const lv = Math.max(1, this.lv);
// 係数 0.85 = 1LvごとにCTを15%短縮（幾何減衰）。下限は 0.35s
const ct = Math.max(0.35, this.baseRate * Math.pow(0.85, lv - 1) * (this.awaken ? 0.90 : 1.0));
this.cd = ct * state.mods.rateMul;


}

},
    
    
ghost:{
  short:'GH', name:'ゴースト', lv:0, awaken:false,
  cd:0, baseRate:1.10, ang:0,   // ← angを持たせて回転管理
  update(dt){
    if(this.lv<=0) return;

    // クールダウンを1回だけ減算
    this.cd -= dt;

    // ゴースト数 & 回転
    const count = this.awaken ? 6 : this.lv; // Lv1=1, Lv2=2, Lv3=3 / 覚醒=6
    this.ang += dt * (this.awaken ? 1.6 : 1.0);

    // 発射トリガ
    if(this.cd <= 0){
      // ▶ 発射間隔：短縮＆レベルでさらに短縮、覚醒で少し早め
      this.cd = Math.max(0.42, this.baseRate * (1 - 0.18*(this.lv-1))) * (this.awaken ? 0.85 : 1.0) * state.mods.rateMul;

      for(let k=0;k<count;k++){
        const a = this.ang + k * (Math.PI*2/count);
        const r = 40 + 6*(this.lv-1);
        const gx = state.player.x + Math.cos(a)*r;
        const gy = state.player.y + Math.sin(a)*r;

        const t = nearestEnemy(gx, gy);
        if(!t) continue;

        const base = Math.atan2(t.y-gy, t.x-gx);
        const spread = 0.3; // 3発の拡散
        for(const off of [0, -spread, spread]){
          state.bullets.push({
            type:'ghost',             // ← 区別できるよう変更
            x:gx, y:gy,
            vx:Math.cos(base+off)*360,
            vy:Math.sin(base+off)*360,
            r:6*state.mods.sizeMul,   // ← 少し大きめ
            dmg:(2.5 + 3*(this.lv-1)) * (this.awaken ? 1.1 : 1.0) * state.mods.dmgMul,
            life:3.0,
            pierce:3                  // ← 貫通回数3
          });
        }
      }
    }
    // ゴーストの見た目は draw() 側でOK（半透明の霊体など）
  }
},

poison:{
  short:'毒', name:'ポイズンフィールド',
  lv:0, awaken:false, cd:0,
  baseCd:2.0, baseR:80, dps:14, lifeSec:5,
  update(dt){
    if(this.lv<=0) return;

    this.cd -= dt;
    if(this.cd<=0){
      // 通常：足元に1枚、5秒維持
      state.effects.push({
        type:'poisonField',
        x: state.player.x, y: state.player.y,
        r: (this.baseR + (this.lv-1)*24) * state.mods.sizeMul,
        dps: this.dps * state.mods.dmgMul,
        life: this.lifeSec, life0: this.lifeSec
      });

      // 覚醒：自分の周囲に3枚を同時展開（固定）
      if(this.awaken){
        const baseR = (this.baseR + (this.lv-1)*24) * 0.9 * state.mods.sizeMul;
        const orbit = 110;
        for(let k=0;k<3;k++){
          const a = state.t + k * (Math.PI*2/3);
          state.effects.push({
            type:'poisonField',
            x: state.player.x + Math.cos(a)*orbit,
            y: state.player.y + Math.sin(a)*orbit,
            r: baseR,
            dps: this.dps * 0.9 * state.mods.dmgMul,
            life: this.lifeSec, life0: this.lifeSec
          });
        }
      }

      this.cd = this.baseCd * state.mods.rateMul;
    }
  }
},


    
    
    nova:{ short:'NV', name:'ノヴァ', lv:0, awaken:false, cd:0, baseRate:3.2, baseDmg:22, baseR:96, auraT:0,
      update(dt){
        if(this.lv<=0) return;
        this.cd -= dt; if(this.cd<=0){
          // 既存の距離式に倍率で上乗せ（覚醒でさらに広く）
const lv = Math.max(1,this.lv);
const baseR = (this.baseR + 22*(lv-1)) * state.mods.sizeMul;
const R = baseR * (1.35 + 0.12*(lv-1)) * (this.awaken ? 1.20 : 1.00);
          const dmg = (this.baseDmg + 10*(this.lv-1)) * state.mods.dmgMul;
          addEffect('nova',{x:state.player.x,y:state.player.y,r:R, life:.25});
          let hits = 0;
          for(const e of state.enemies){
            const d = Math.hypot(e.x-state.player.x, e.y-state.player.y);
            if(d<R) { e.hp -= dmg; e.hitFlash = Math.max(e.hitFlash, 0.12);
            hits++;


                // === ノヴァ・ノックバック付与（ここが今回の追加） ===
    const dx = e.x - state.player.x, dy = e.y - state.player.y;
    const m = Math.hypot(dx, dy) || 1;
    const nx = dx / m, ny = dy / m;
    const baseKB =
      (e.type === 'final') ? 260 :
      (e.type === 'big')   ? 340 :
      (e.type === 'mid')   ? 420 :
                             520 ;
    const edge = Math.min(1, Math.max(0, d / R));
    const falloff = 0.55 + 0.45*(1 - edge);
    const kb = baseKB * falloff;
    e.kbx = (e.kbx || 0) + nx * kb;
    e.kby = (e.kby || 0) + ny * kb;
    
      // === ここにスタン効果を追加 ===
  const base = 0.20; // 秒
  const resist = (e.type==='final') ? 0.35 : 
                 (e.type==='big'||e.type==='mid') ? 0.6 : 
                 1.0;
  e.stun = Math.max(e.stun||0, base * resist);
             }
          }
          
          
// ★敵ループの“直後”に 3% 回復（1回のノヴァにつき一度）
if (hits > 0){
const gained = healPlayerPercent(getNovaHitHealPercent()); // レベル/覚醒で 2/3/4%
  if (gained > 0){
    addEffect('text', {
      text: `+${gained.toFixed(gained < 1 ? 1 : 0)}`,
      x: state.player.x,
      y: state.player.y - 18,
      life: 0.8,
      color: '#7CFF7C'
    });
    addEffect('healSparkles', { x: state.player.x, y: state.player.y, r: 46, life: 0.7, life0: 0.7, count: 14 });
  }
}




          
          
          
          this.cd = Math.max(1.3, this.baseRate * (1 - 0.22*(this.lv-1))) * 0.32;
                  }
        if(this.awaken){
  this.auraT += dt;
  const R2 = (110 + 20*(this.lv-1)) * state.mods.sizeMul;
  addEffect('aura',{x:state.player.x,y:state.player.y,r:R2, life:.06});

  let auraHits = 0;
for (const e of state.enemies){
  const d = Math.hypot(e.x - state.player.x, e.y - state.player.y);
  if (d < R2){
    e.hp -= (14 + 3*(this.lv-1)) * state.mods.dmgMul * dt;
    e.hitFlash = Math.max(e.hitFlash, 0.05);
    auraHits++;
  }
}


// ★覚醒オーラ：命中1件ごとに 0.1% 回復（仕様）
if (auraHits > 0){
  const gained = healPlayerPercent(0.1 * auraHits);
  if (gained > 0){
    addEffect('text', {
      text: `+${gained.toFixed(1)}`,
      x: state.player.x,
      y: state.player.y - 18,
      life: 0.6,
      color: '#7CFF7C'
    });
    addEffect('healSparkles', { x: state.player.x, y: state.player.y, r: 40, life: 0.6, life0: 0.6, count: 10 });
  }
}



}
      }
    }
  };
  state.weapons = weapons;


function strikeLightning(hit, mult){
  // ダメージ
  hit.hp -= weapons.lightning.baseDmg * mult * state.mods.dmgMul;
  hit.hitFlash = Math.max(hit.hitFlash, 0.18);

  // 見た目（ヒット地点へ落雷）
  const path = buildZigPath(hit.x, hit.y, 8);
  addEffect('zig', { path, life:.22, thick: 6 * state.mods.sizeMul });
  addEffect('flash', { life:.02 }); 
  spark(hit.x, hit.y, 18);

  // ▼ チェーン
  const CHAIN_MAX     = 3;      // 追加ヒット数（元ヒット＋最大3回）
  const CHAIN_RADIUS  = 180;    // 次の跳躍の探索半径
  const FALLOFF       = 0.7;    // ダメージ減衰（70%ずつ）
  const SEEN = new Set();       // 同一敵に多重ヒットしない

  SEEN.add(hit);

  let cur = hit;
  let power = mult * FALLOFF;

  for (let i = 0; i < CHAIN_MAX; i++){
    // 候補を探す
    let next = null;
    let bestD2 = CHAIN_RADIUS * CHAIN_RADIUS;
    for (const e of state.enemies){
      if (e === cur || SEEN.has(e) || e.hp <= 0) continue;
      const d2 = dist2(cur.x, cur.y, e.x, e.y);
      if (d2 < bestD2){ bestD2 = d2; next = e; }
    }
    if (!next) break;

    // ダメージ（減衰）
    next.hp -= weapons.lightning.baseDmg * power * state.mods.dmgMul;
    next.hitFlash = Math.max(next.hitFlash, 0.16);

    // 見た目（カーブした稲妻）
    const path2 = [
      [cur.x, cur.y],
      [ (cur.x + next.x)/2 + rnd(-22,22), (cur.y + next.y)/2 + rnd(-22,22) ],
      [next.x, next.y]
    ];
    addEffect('zig', { path: path2, life:.18, thick: 5 * state.mods.sizeMul });

    SEEN.add(next);
    cur = next;
    power *= FALLOFF;  // さらに減衰
    if (power < 0.25) break; // さすがに弱くなりすぎたら終了
  }
}


  function nearestEnemy(x,y){
    let best=null, bestD=1e9;
    for(const e of state.enemies){
      const d=dist2(x,y,e.x,e.y);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  
  function pickMultiple(arr, n){
    const copy = arr.slice(); const out=[];
    for(let i=0;i<n && copy.length;i++){ out.push(copy.splice((Math.random()*copy.length)|0,1)[0]); }
    return out;
  }

// 扇形 [inner..outer] × [ang ± span/2] にいる敵へ一括ダメ＆軽いノックバック
function dealSlashDamage(cx, cy, ang, span, inner, outer, dmg){
  for(let j=state.enemies.length-1;j>=0;j--){
    const e = state.enemies[j];
    const dx = e.x - cx, dy = e.y - cy;
    const d  = Math.hypot(dx,dy);
    if (d < inner || d > outer) continue;
    let a = Math.atan2(dy,dx) - ang;
    // -PI..PI に正規化
    if (a >  Math.PI) a -= Math.PI*2;
    if (a < -Math.PI) a += Math.PI*2;
    if (Math.abs(a) <= span*0.5){
      e.hp -= dmg;
      e.hitFlash = Math.max(e.hitFlash || 0, 0.12);
      // ほんのりノックバック（手応え）
      const nx = Math.cos(ang), ny = Math.sin(ang);
      e.x += nx * 14; e.y += ny * 14;
      if (e.hp <= 0){ safeKillEnemy(j); } // 安全な既存死亡処理
    }
  }
}


  function buildZigPath(x2,y2,segments){
    const x1 = x2; const y1 = -30;
    const pts=[[x1,y1]];
    for(let i=1;i<=segments;i++){
      const t=i/segments;
      const nx = x1 + (x2-x1)*t + rnd(-18,18);
      const ny = y1 + (y2-y1)*t + rnd(-8,18);
      pts.push([nx,ny]);
    }
    return pts;
  }


// ===== 上限テーブル（U定義の前に置く）=====
const CAPS = {
  speedMax: 320,   // player.speed 上限（初期170）
  hpMax: 350,      // 最大HP上限（初期110）
  dmgMulMax: 3.0,  // ダメージ倍率上限（初期1.0）
  rateMulMin: 0.45,// 攻撃間隔倍率の下限（小さいほど速い／初期1.0）
  sizeMulMax: 2.2  // サイズ倍率上限（初期1.0）
};


// ===== U（上限付きアップグレード定義）=====
const U = {
  weaponAdd: (key) => ({
    id: `add:${key}`,
    name: `新武器: ${weapons[key].name}`,
    desc: '入手（最大Lv3まで強化可能）',
    can: () => weapons[key].lv === 0,
    apply: () => { weapons[key].lv = 1; state.owned.add(key); }
  }),

  weaponUp: (key) => ({
    id: `up:${key}`,
    name: `${weapons[key].name}強化`,
    desc: '武器レベル+1（最大Lv3）',
    can: () => weapons[key].lv > 0 && weapons[key].lv < 3,
    apply: () => { weapons[key].lv++; }
  }),

  weaponAwaken: (key) => ({
    id: `aw:${key}`,
    name: `${weapons[key].name} 覚醒`,
    desc: '特別な性能を解放！',
    can: () => weapons[key].lv === 3 && !weapons[key].awaken,
    apply: () => { weapons[key].awaken = true; }
  }),

  // ---- ステータス系（上限付き） ----
  speed: {
    id: 'speed+',
    name: '移動速度アップ',
    desc: '+15%移動速度（上限あり）',
    can: () => state.player.speed < CAPS.speedMax - 1,
    apply: () => {
      const before = state.player.speed;
      state.player.speed = Math.min(CAPS.speedMax, state.player.speed * 1.15);
      if (state.player.speed === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: '上限!' });
      }
    }
  },

  maxhp: {
    id: 'maxhp+',
    name: '最大HPアップ',
    desc: '+10%最大HP（上限あり）',
    can: () => state.player.maxHp < CAPS.hpMax - 1,
    apply: () => {
      const before = state.player.maxHp;
      state.player.maxHp = Math.min(CAPS.hpMax, Math.round(state.player.maxHp * 1.10));
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + Math.round(state.player.maxHp * 0.15));
      if (state.player.maxHp === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: '上限!' });
      }
    }
  },

  regen: {
    id: 'regen',
    name: '自然回復',
    desc: '毎秒 最大HPの0.8% 回復',
    can: () => !state.upgradesTaken.has('regen'),
    apply: () => {
      state.upgradesTaken.add('regen');
      addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'リジェネ+' });
    }
  },

  pickup: {
    id: 'pickup+',
    name: '吸引範囲アップ',
    desc: '経験値吸引範囲アップ（Lv3で全域）',
    can: () => state.pickupLv < 3,
    apply: () => { state.pickupLv++; }
  },

  atkRate: {
    id: 'rate+',
    name: '攻撃速度アップ',
    desc: 'クールダウン -10%（下限あり）',
    can: () => state.mods.rateMul > CAPS.rateMulMin + 1e-6,
    apply: () => {
      state.mods.rateMul = Math.max(CAPS.rateMulMin, state.mods.rateMul * 0.90);
      if (state.mods.rateMul === CAPS.rateMulMin) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: '最速!' });
      }
    }
  },

  atkDmg: {
    id: 'dmg+',
    name: '与ダメージアップ',
    desc: 'ダメージ +8%（上限あり）',
    can: () => state.mods.dmgMul < CAPS.dmgMulMax - 1e-6,
    apply: () => {
      const before = state.mods.dmgMul;
      state.mods.dmgMul = Math.min(CAPS.dmgMulMax, state.mods.dmgMul * 1.08);
      if (state.mods.dmgMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: '上限!' });
      }
    }
  },

  sizeUp: {
    id: 'size+',
    name: '弾サイズアップ',
    desc: '弾・範囲 +10%（上限あり）',
    can: () => state.mods.sizeMul < CAPS.sizeMulMax - 1e-6,
    apply: () => {
      const before = state.mods.sizeMul;
      state.mods.sizeMul = Math.min(CAPS.sizeMulMax, state.mods.sizeMul * 1.10);
      if (state.mods.sizeMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: '上限!' });
      }
    }
  },
  
  doubleItem: {
  id:'doubleItem',
  name:'アイテム出現率２倍',
  desc:'回復/核/磁石/宝箱などの出現率が２倍になる',
  can: ()=> !state.mods.doubleItem,
  apply: ()=> { state.mods.doubleItem = true; }
},
};

// ===== ここから選択肢リスト =====
const ALL_UPGRADES = [
  U.weaponAdd('shotgun'),   U.weaponUp('shotgun'),   U.weaponAwaken('shotgun'),
  U.weaponAdd('orbit'),     U.weaponUp('orbit'),     U.weaponAwaken('orbit'),
  U.weaponAdd('lightning'), U.weaponUp('lightning'), U.weaponAwaken('lightning'),
  U.weaponAdd('nova'),      U.weaponUp('nova'),      U.weaponAwaken('nova'),
  U.weaponAdd('rock'),      U.weaponUp('rock'),      U.weaponAwaken('rock'),
  U.weaponAdd('homing'),    U.weaponUp('homing'),    U.weaponAwaken('homing'),
  U.weaponAdd('ghost'),     U.weaponUp('ghost'),     U.weaponAwaken('ghost'),
  U.weaponAdd('poison'), U.weaponUp('poison'), U.weaponAwaken('poison'),
    U.weaponAdd('blade'), U.weaponUp('blade'), U.weaponAwaken('blade'),
  U.weaponUp('blaster'),    U.weaponAwaken('blaster'), // 既存武器の強化/覚醒
  U.speed, U.maxhp, U.regen, U.pickup, U.atkRate, U.atkDmg, U.sizeUp ,U.doubleItem
];

// --- tiny per-frame scheduler (global & safe) ---
if (typeof window.schedule !== 'function') {
  window.schedule = function(fn, delaySec) {
    (state._q || (state._q = [])).push({ fn, t: Math.max(0, delaySec || 0) });
  };
}

// ==== メインループ ====

// 安全に表示/非表示を切る小ヘルパ
function hideById(id){ const el=document.getElementById(id); if(el) el.style.display='none'; }
function showById(id, display='block'){ const el=document.getElementById(id); if(el) el.style.display=display; }


// --- remove legacy HUDs & stub old notifiers ---
{
  const kill = id => { const el = document.getElementById(id); if (el) el.remove(); };
  kill('bossmsg');
  kill('gather');

  // もし古い関数がどこかで呼ばれても無害化しておく
  window.flashBossMessage ??= function(){};
  window.showStartToast   ??= function(){};
  window.showToast        ??= function(){};
  window.notify           ??= function(){};
}

function loop(now){

  if (state.player && state.player.hp <= 0 && !state.gameover){
    triggerGameOver();
  }
  if (!state.started) { requestAnimationFrame(loop); return; }

  // dt はこの1回だけ計算し、state.last もここで1回だけ更新
let dt = Math.min((now - state.last) / 1000, 0.05);
  state.last = now;
  
  // ---- tiny per-frame scheduler (pausable) ----
state._q ||= [];
for (let i = state._q.length - 1; i >= 0; i--) {
  const t = state._q[i];
  if (!state.paused) t.t -= dt;     // ポーズ中は進めない
  if (t.t <= 0) { try { t.fn(); } catch (_) {} state._q.splice(i, 1); }
}



try {
// === Debug: Skip to FINAL BOSS (once, unified) ===
if (state._debugSkipToFinal && !state._didSkipFinal){
  // いったん掃除
  if (Array.isArray(state.enemies))      state.enemies.length = 0;
  if (Array.isArray(state.enemyBullets)) state.enemyBullets.length = 0;
  if (Array.isArray(state.items))        state.items.length = 0;

  // 9:58 に寄せる（10:00出現前提）
  const target = 600 - 2;
  const tNow = Math.max(0, Math.floor(state.timeSec || 0));
  if (tNow < target){
    state.timeSec = target;
    if (typeof state.elapsedMs === 'number') state.elapsedMs = target * 1000;
    if (typeof state.elapsed   === 'number') state.elapsed   = target * 1000;
  }

  // タイムボーナス用の初期化
  state.bossBonus = 0;
  state._finalBonusAwarded = false;
  state.finalSpawnAt = state.timeSec || 0;

  // ★最終ボスは正規のスポーン関数で出す
  if (typeof spawnFinalBoss === 'function') spawnFinalBoss();

  state.paused = false;
  state._didSkipFinal = true;
}



// === GameOverは完全停止（描画だけして抜ける）
if (state.gameover){
  draw();
  requestAnimationFrame(loop);
  return;
}

// 合成 pause を先に反映（手動ポーズ／レベルアップ／宝箱）
const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
state.paused = !!(lvlOpen || chestOpen || state.manualPaused);

// オーバーレイ/手動いずれかで停止していたらここで抜ける
if (state.paused){
  draw();
  requestAnimationFrame(loop);
  return;
}


// === GameOverは完全停止（描画だけして抜ける）
if (state.gameover){
  draw(); requestAnimationFrame(loop); return;
}

if (state.paused){
  draw(); requestAnimationFrame(loop); return;
}

    state.t += dt; 
    state.timeSec += dt;
    const B = worldBounds(); // そのフレームで実際に見えているワールド境界

    
    // Final Boss spawn
    if (!state.finalSpawned && state.timeSec >= 600) {
      spawnFinalBoss();
      state.finalSpawned = true;
    }
    
    state.difficulty = 1 + Math.floor(state.timeSec/20);

    // Boss timers
    if(state.player.level>=3){
      state.bossTimer -= dt; 
      state.bigBossTimer -= dt;
      if(state.bossTimer<=0){
        spawnMidBoss();
        state.bossTimer = (state.timeSec>=360 ? 40 + Math.random()*15 : 60 + Math.random()*20);
      }
      if(state.bigBossTimer<=0){
        spawnBigBoss();
        state.bigBossTimer = (state.timeSec>=360 ? 100 + Math.random()*25 : 140 + Math.random()*30);
      }
    }

// === movement input（浮遊スティック最優先 → なければキーボード/既存入力） ===
let vx = 0, vy = 0;

if (state.touchJoy && state.touchJoy.active) {
  // フローティング・ジョイスティック
  vx = state.touchJoy.dx;
  vy = state.touchJoy.dy;
} else {
  // 既存の入力ベクトル（固定ジョイスティックが無くても0扱い）
  if (state.input) {
    if (typeof state.input.vx === 'number') vx += state.input.vx;
    if (typeof state.input.vy === 'number') vy += state.input.vy;
  }
  // キーボード
  if (typeof keyboardVec === 'function') {
    const kv = keyboardVec(); vx += kv.x; vy += kv.y;
  }
}

// 正規化 & 最終向き
const pm = Math.hypot(vx, vy) || 0;
if (pm > 0) { vx /= pm; vy /= pm; state.input.lastDir = { x:vx, y:vy }; }

// ★ 進行方向を角度で保持（移動中のみ更新）
if (state.player && pm > 0) {
  state.player.aimAngle = Math.atan2(vy, vx);  // -π..π
}



    // regen
    if (state.upgradesTaken.has('regen')) {
      const healPerSec = state.player.maxHp * 0.008; // 0.8%/sec
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + healPerSec * dt);
    }

    // move player
{
  const b = worldBounds(state.player.r);
  state.player.x = clamp(state.player.x + vx*state.player.speed*dt, b.minX, b.maxX);
  state.player.y = clamp(state.player.y + vy*state.player.speed*dt, b.minY, b.maxY);
}

    // invincible timer
    if (state.player.iTime > 0) {
      state.player.iTime = Math.max(0, state.player.iTime - dt);
    }

    // knockback
    if (Math.abs(state.player.kbx) + Math.abs(state.player.kby) > 0.1) {
{
  const b = worldBounds(state.player.r);
  state.player.x = clamp(state.player.x + state.player.kbx * dt, b.minX, b.maxX);
  state.player.y = clamp(state.player.y + state.player.kby * dt, b.minY, b.maxY);
}
      const drag = 8.0;
      state.player.kbx += -state.player.kbx * drag * dt;
      state.player.kby += -state.player.kby * drag * dt;
    } else {
      state.player.kbx = state.player.kby = 0;
    }

// spawn enemies
state.spawnTimer -= dt;

// 序盤はゆっくり、だんだん短く。下限は0.38s
let spawnRate = Math.max(0.38, 1.20 - state.timeSec * 0.004);
// 後半(6分〜)は少し加速
if (state.timeSec >= 360) spawnRate = Math.max(0.34, spawnRate * 0.85);

if (state.spawnTimer <= 0) {
  // いまの雑魚数と上限
  const cap   = currentTrashCap(state.timeSec);
  const alive = countTrash();
  const room  = Math.max(0, cap - alive);

  if (room > 0) {
    // バッチ数は緩やかに増える（最大3体/サイクル）
    // 0〜220s: 1体, 220〜440s: 2体, 440s〜: 3体
    const batchBase = 1 + Math.min(2, Math.floor(state.timeSec / 220));
    const batch = Math.min(batchBase, room); // 上限までに抑える

    for (let n = 0; n < batch; n++) spawnEnemy();
  }

  state.spawnTimer = spawnRate;
  spawnItemRandom();
}

    // weapons update
    for(const k in state.weapons){ state.weapons[k].update(dt); }

// === プレイヤー弾 ===
for(let i=state.bullets.length-1;i>=0;i--){
  const b=state.bullets[i];
  
  // ホーミングは敵を追尾
  if(b.type==='homing'){
    const t = nearestEnemy(b.x,b.y);
    if(t){
      const dx=t.x-b.x, dy=t.y-b.y;
      const ang = Math.atan2(dy,dx);
      const speed = Math.hypot(b.vx,b.vy);
      const cur = Math.atan2(b.vy,b.vx);
      const diff = ((ang-cur+Math.PI*3)%(Math.PI*2))-Math.PI;
      const maxTurn = b.turn * dt;
      const newAng = cur + clamp(diff, -maxTurn, maxTurn);
      b.vx = Math.cos(newAng)* speed;
      b.vy = Math.sin(newAng)* speed;
    }
  }

if (b.type === 'rock') {
  const spinRate = 1.4;     // ★ 自転速度(rad/秒)。ゆっくり=0.8〜1.6、速め=3〜6
  b.spin += spinRate * dt;
}

  // 移動と寿命処理
  b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
 if (
  b.x < B.minX - 60 || b.x > B.maxX + 60 ||
  b.y < B.minY - 60 || b.y > B.maxY + 60 ||
  b.life <= 0
){
  state.bullets.splice(i,1);
  continue;
}



 // 敵との当たり判定
let rockHitThisFrame = false; // rock は複数体に当てるためのフラグ
for(let j=state.enemies.length-1;j>=0;j--){
  const e=state.enemies[j];
  const r = (e.type==='big'? e.size*0.55
           : e.type==='mid'? e.size*0.6
           : e.type==='minion'? e.size*0.7
           : e.size*0.7);

  if(dist2(b.x,b.y,e.x,e.y) < (b.r + r)**2){
    // --- ヒット ---
    let dmg = b.dmg;
    if(b.type === 'rock'){
      // ボス種へボーナス
      if (e.type==='mid' || e.type==='big' || e.type==='final') {
        dmg *= (b.bossMul || 1.0);
      }
    }
    e.hp -= dmg;
    e.hitFlash = Math.max(e.hitFlash, 0.12);
    
// ★ 即死チェック：ヒット直後に確定ドロップ（finalは既存ルートに任せる）
if (e.hp <= 0) {
  if (e.type === 'final') {
    // ラスボスは従来の処理に任せる（演出や遷移があるため）
  } else if (e.type === 'mid' || e.type === 'big') {
    // 中/大型ボスは宝箱ドロップ
state.items.push({ kind:'chest', picks:1, x:e.x, y:e.y, r:14, t:0 }); // ← 中ボスは1つ選択
    if (typeof addEffect === 'function') addEffect('pop', {x:e.x, y:e.y});
    state.killScore = (state.killScore||0) + 1;
    state.enemies.splice(j, 1);
    break;
  } else {
    // 通常ザコは安全即死関数に寄せる（XPドロップ保証）
    if (typeof safeKillEnemy === 'function') {
      safeKillEnemy(j);
    } else if (typeof dropGem === 'function') {
      dropGem(e.x, e.y, 1);
      state.enemies.splice(j, 1);
    } else {
      (state.gems||(state.gems=[])).push({x:e.x, y:e.y, r:6, val:1});
      state.enemies.splice(j, 1);
    }
    state.killScore = (state.killScore||0) + 1;
    break;
  }
}

    
    spark(b.x,b.y, b.type==='rock'? 5 : 4);

    if(b.type==='homing'){
      const R = (b.bigBoom ? 90 : 46) * state.mods.sizeMul;
      addEffect('nova',{x:b.x,y:b.y,r:R, life:.26});
      for(const e2 of state.enemies){
        const d = Math.hypot(e2.x-b.x, e2.y-b.y);
        if(d<R) { e2.hp -= b.dmg * (b.bigBoom? 1.2:1); e2.hitFlash = Math.max(e2.hitFlash, 0.12); }
      }
      state.bullets.splice(i,1);
      break; // homing は消滅

    } else if(b.type==='bullet'){
      state.bullets.splice(i,1);
      break; // 通常弾は1体で終了

    } else if(b.type==='ghost'){
      if(b.pierce > 0){ b.pierce--; } else { state.bullets.splice(i,1); }
      break; // ゴーストも1体で次フレームへ

      } else if (b.type === 'slash') {
        // 斬撃：寿命で消える。1体につき1回だけダメージ
        if (!b._hit) b._hit = new Set();
        if (!b._hit.has(e)) {
          e.hp -= b.dmg;
          e.hitFlash = Math.max(e.hitFlash||0, 0.12);

          // 軽いノックバック（方向＝斬撃の向き）
          const a = b.ang || Math.atan2(b.vy, b.vx);
          const kb = (state.weapons && state.weapons.blade && state.weapons.blade.awaken) ? 220 : 160;
          e.kbx = (e.kbx||0) + Math.cos(a)*kb;
          e.kby = (e.kby||0) + Math.sin(a)*kb;

          b._hit.add(e);
          // （斬撃は貫通扱いなので弾は消さない）
if (e.hp <= 0) {
  safeKillEnemy(j);
}
        }


    } else if(b.type==='rock'){
      // rock は消さずに次の敵判定も続行（同フレームで複数体に当たる）
      rockHitThisFrame = true;
      // break しない
    }
  }
}
// rock でも画面外/寿命では通常通り消える（既存処理のまま）

// === Orbit contact damage (no knockback) ===
if (state.weapons.orbit.lv > 0){
  const w = state.weapons.orbit;
  const count = w.awaken ? 8 : (3 + w.lv);
  const ring = w.baseR + 14*(w.lv-1) + (w.awaken? 12:0);
  const orbR = (w.hitRBase + (w.awaken? 4:0)) * state.mods.sizeMul; // 当たり半径
  const dps = (w.dpsBase + 4*(w.lv-1)) * (w.awaken? 1.4:1.0) * state.mods.dmgMul;

  for (const e of state.enemies){
    for (let k=0; k<count; k++){
      const ang = w.ang + k*(Math.PI*2/count);
      const ox = state.player.x + Math.cos(ang)*ring;
      const oy = state.player.y + Math.sin(ang)*ring;
      const dx = e.x - ox, dy = e.y - oy;
      if (dx*dx + dy*dy <= orbR*orbR){
        // 接触DPS（ノックバックなし）
        e.hp -= dps * dt;
        e.hitFlash = Math.max(e.hitFlash, 0.05);
      }
    }
  }
}
}


// === 敵弾 ===
for (let i = state.enemyBullets.length - 1; i >= 0; i--) {
  const b = state.enemyBullets[i];

  // 位置更新
  b.x += b.vx * dt;
  b.y += b.vy * dt;
  b.life -= dt;

  // 画面外・寿命切れ → 除去
  if (
    b.life <= 0 ||
    b.x < B.minX - 40 || b.x > B.maxX + 40 ||
    b.y < B.minY - 40 || b.y > B.maxY + 40
  ) {
    state.enemyBullets.splice(i, 1);
    continue;
  }

  // Orbit が弾を相殺
  let canceled = false;
  if (state.weapons.orbit.lv > 0) {
    const count = state.weapons.orbit.awaken ? 8 : (3 + state.weapons.orbit.lv);
    for (let k = 0; k < count && !canceled; k++) {
      const ang = state.weapons.orbit.ang + k * (Math.PI * 2 / count);
      const rad = state.weapons.orbit.baseR + 14 * (state.weapons.orbit.lv - 1) + (state.weapons.orbit.awaken ? 12 : 0);
      const ox = state.player.x + Math.cos(ang) * rad;
      const oy = state.player.y + Math.sin(ang) * rad;
      const or = (state.weapons.orbit.awaken ? 18 : 14) * state.mods.sizeMul;
      if (dist2(b.x, b.y, ox, oy) < (b.r + or) ** 2) {
        state.enemyBullets.splice(i, 1);
        spark(b.x, b.y, 8);
        canceled = true;
      }
    }
    if (canceled) continue;
  }

  // プレイヤー命中
  if (dist2(b.x, b.y, state.player.x, state.player.y) < (b.r + state.player.r) ** 2) {
    state.enemyBullets.splice(i, 1);
    playerHit(b.dmg, b.x, b.y);
    spark(b.x, b.y, 6);
    if (state.player.hp <= 0 && !state.gameover) {
      triggerGameOver();
      break; // このフレームの残り弾処理を終了
    }
  }
}


    // === 敵・ボス ===
    for(let i=state.enemies.length-1;i>=0;i--){
      const e=state.enemies[i];
      e.hitFlash = Math.max(0, e.hitFlash - dt*2.5);
      
      // 敵ノックバック速度の適用（減衰つき）
if (e.kbx || e.kby){
  e.x += e.kbx * dt;
  e.y += e.kby * dt;
  const drag = 6.0;
  e.kbx += -e.kbx * drag * dt;
  e.kby += -e.kby * drag * dt;
  if (Math.abs(e.kbx) + Math.abs(e.kby) < 1){
    e.kbx = 0; e.kby = 0;
  }
}
      
// --- スタン減衰 ---
e.stun = Math.max(0, (e.stun||0) - dt);

// --- ポイズン減速の取得（その敵が“今”毒に触れているなら遅くする）---
let slowMul = 1;                 // 1=等速（遅くするほど小さく）
const SLOW_IN_FIELD = 0.55;      // フィールド中の移動倍率（=45%低下）
for(const ef of state.effects){
  if(ef.type !== 'poisonField') continue;
  const dx = e.x - ef.x, dy = e.y - ef.y;
  if(dx*dx + dy*dy <= ef.r*ef.r){
    slowMul = Math.min(slowMul, SLOW_IN_FIELD);
    break; // 1枚見つけたら十分（2枚でも“移動”は最大減速のみにする）
  }
}

// --- まとめて移動倍率（スタン中はさらに重く）---
const stunMul = (e.stun > 0) ? 0.18 : 1.0;  // スタン中は18%の速度だけ動ける＝実質ほぼ停止
const moveMul = slowMul * stunMul;

// --- ノックバック（kbx/kby）を位置に反映＆減衰 ---
e.kbx = e.kbx || 0;
e.kby = e.kby || 0;
if (Math.abs(e.kbx) + Math.abs(e.kby) > 0.1){
  e.x += e.kbx * dt;
  e.y += e.kby * dt;
  const drag = 7.5;              // ノックバックの減衰
  e.kbx += -e.kbx * drag * dt;
  e.kby += -e.kby * drag * dt;
} else {
  e.kbx = e.kby = 0;
}

      

  // ★ここにハードコア回復を追加
  if (state.mode.hardcore) {
    if (e.hitFlash < 0.03 && e.hp > 0 && e.hp < e.maxHp) {
      const ramp = Math.min(0.006, state.timeSec * 0.00020);
      const base = 0.0035;
      const byType = (e.type === 'minion') ? 0.6
                   : (e.type === 'shooter') ? 0.8
                   : (e.type === 'mid')    ? 1.5
                   : (e.type === 'big')    ? 1.75
                   : (e.type === 'final')  ? 2.00
                   : 1.0;

      const rate = (base + ramp) * byType;
      e.hp = Math.min(e.maxHp, e.hp + e.maxHp * rate * dt);
    }
  }


      if(e.type==='minion'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        e.x += Math.cos(a)*e.speed*dt*moveMul; 
e.y += Math.sin(a)*e.speed*dt*moveMul;

      }else if(e.type==='shooter'){
        if(e.phase==='move'){
          const step = e.moveSpeed * dt * moveMul;
e.x += e.dir.x * step; e.y += e.dir.y * step; e.moved += step;
          if(e.moved >= e.moveDist){ e.phase='stop'; }
        }else{
          e.cd -= dt;
          if(e.cd<=0){
            const angS = Math.atan2(state.player.y-e.y, state.player.x-e.x);
            state.enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(angS)*200, vy:Math.sin(angS)*200, r:4, dmg: (state.mode.hardcore ? 10*1.5 : 10), life:60 });
            e.cd = rnd(1.9, 2.1);
          }
        }

      }else if(e.type==='mid'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        e.x += Math.cos(a)*e.speed*dt*0.9*moveMul; 
e.y += Math.sin(a)*e.speed*dt*0.9*moveMul;
        e.cd -= dt;
        if(e.cd<=0){
          const n = 8;
          for(let k=0;k<n;k++){
            const ang = (Math.PI*2*k)/n;
            state.enemyBullets.push({ x:e.x,y:e.y, vx:Math.cos(ang)*120, vy:Math.sin(ang)*120, r:4, dmg:(state.mode.hardcore ? 12*1.5 : 12), life:3 });
          }
          e.cd = 7.0;
        }

      }else if(e.type==='big' || e.type==='final'){
        const ang = Math.atan2(state.player.y - e.y, state.player.x - e.x);
        e.cd -= dt;
        e.dashCD -= dt;

        if(e.type === 'final'){
        // --- 共通：ゆるく追尾 ---
e.x += Math.cos(ang) * e.speed * dt * 0.45 * moveMul;
e.y += Math.sin(ang) * e.speed * dt * 0.45 * moveMul;

// 初期化保護
if(e.shootCD === undefined) e.shootCD = 0;
if(e.patternCD === undefined) e.patternCD = 3.5; // 初期も短め

if(e.phase === 'shoot'){
  // 通常拡散射撃（頻度UP/やや濃い）
  e.shootCD -= dt;
  if(e.shootCD <= 0){
    for(let k=-4;k<=4;k++){
      const a2 = ang + k * 0.11;
      state.enemyBullets.push({
        x:e.x, y:e.y,
        vx:Math.cos(a2)*180, vy:Math.sin(a2)*180, // 少し速く
        r:4, dmg: (state.mode.hardcore ? 18*1.5 : 18), life:3.8
      });
    }
    e.shootCD = 1.8; // ★ 2.6→1.8
  }

  // ダッシュ（頻度UP）
  if(e.dashCD <= 0){
    e.phase = 'tele';
    e.tele  = 0.7; // 0.9→0.7
    e.target = { x: state.player.x, y: state.player.y };
    const dx = e.target.x - e.x, dy = e.target.y - e.y;
    const m = Math.hypot(dx,dy) || 1;
    e.dashDir = { x: dx/m, y: dy/m };
  }

  // 特殊行動（レーザー or 大爆発）頻度UP
  e.patternCD -= dt;
  if(e.patternCD <= 0){
    const r = Math.random();
    if(r < 0.55){
      e.phase = 'charge_laser';
      e.laserAimT = 0.8; // ★ 1.0→0.8
      e.laserAng  = Math.atan2(state.player.y - e.y, state.player.x - e.x);
    }else{
      e.phase   = 'charge_boom';
      e.chargeT = 0.9;   // 1.0→0.9
      e.didBoomDamage = false;
    }
    e.patternCD = rnd(3.0, 5.0); // ★ 6–8 → 3–5
  }

}else if(e.phase === 'tele'){
  e.tele -= dt;
  addEffect('aim', { x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06 });
  if(e.tele <= 0){ e.phase = 'dash'; }

}else if(e.phase === 'dash'){
  const dashSpeed = 1200;
  e.x += e.dashDir.x * dashSpeed * dt;
  e.y += e.dashDir.y * dashSpeed * dt;
  const rx = e.target.x - e.x, ry = e.target.y - e.y;
  if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
    e.cd = 1.6;          // 2.0→1.6
    e.dashCD = 4.8;      // 6.0→4.8
    e.phase = 'shoot';
  }

}else if(e.phase === 'charge_laser'){
  e.laserAimT -= dt;
  const L = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;

  // 目立つ“半透明の太い予備線”
  addEffect('laserGhost', { x1:e.x, y1:e.y, x2, y2, w:56, life:.06 });

  if(e.laserAimT <= 0){
    e.phase = 'laser';
    e.laserDur = 1.6;
  }

}else if(e.phase === 'laser'){
  e.laserDur -= dt;
  const L  = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;

  const beamW = 56; // 描画と合わせる
  addEffect('laserBeam', { x1:e.x, y1:e.y, x2, y2, w:beamW, life:.06 });

  // 当たり判定：レーザーは連続HIT（無敵時間を無視して削る）
  const d    = pointLineDist(state.player.x, state.player.y, e.x, e.y, x2, y2);
  const hitR = beamW * 1.00;                // 
  const DPS  = state.mode.hardcore ? 75 : 50; // 体感強化

  if (d < hitR){
    state.player.hp -= DPS * dt;            // 直接HPを削る（ノックバックなし）
    if (state.player.hp <= 0) { gameOver(); return; }
  }

  if (e.laserDur <= 0){ e.cd = 1.8; e.phase = 'shoot'; }
}

else if(e.phase === 'charge_boom'){
  // 予備動作：小さめの白パルス（短め）
  e.chargeT -= dt;
  const r0 = 60, r1 = 120;
  addEffect('whitePulse', { x:e.x, y:e.y, r0, r1, life:.06 });
  if(e.chargeT <= 0){
    // 本番：時間差で2本の“波リング”
    e.phase = 'boom';
    // パラメータ（避けやすく、でも2連）
    const dur  = 5.0;   // ★ 拡大をゆっくり
    const r0   = 80;

    // ← ここをズーム対応に：ボス位置から画面内で最も遠い角まで届く半径
    const B  = worldBounds();                       // {minX,maxX,minY,maxY}
    const dx = Math.max(e.x - B.minX, B.maxX - e.x);
    const dy = Math.max(e.y - B.minY, B.maxY - e.y);
    const r1 = Math.hypot(dx, dy) + 40;             // 余裕分+40

    // セグメントリング（大きな隙間）
    const segCount   = 10;      // リング分割数（多すぎない）
    const gapFrac    = 0.50;    // ★ 1セグメント中の“隙間率”をガッツリ
    const thickness  = 22;      // 見た目＆当たり幅
    const wavAmp     = 10;      // 波の振幅（px）
    const wavFreq    = 6;       // 角度方向の波の山個数
    const rot0       = Math.random()*Math.PI*2;

    // 2本用意（timeOffsetで時間差）
    e.boomWaves = [
      { t: dur, dur, r0, r1, did:false, segCount, gapFrac, rot:rot0,                    w:thickness, wavAmp, wavFreq, timeOffset:0.0 },
      { t: dur, dur, r0, r1, did:false, segCount, gapFrac, rot:rot0 + Math.PI/segCount, w:thickness, wavAmp, wavFreq, timeOffset:1.00 }
    ];
    
        e.boomClock = 0; // 描画側の波アニメ位相用
  }

}else if(e.phase === 'boom'){
  e.boomClock += dt;

  // 2本のリングを更新
  let allDone = true;
  for(const wv of e.boomWaves){
    // 時間差スタート
    if (wv.timeOffset > 0){
      wv.timeOffset -= dt;
      allDone = false;
      continue;
    }

    wv.t -= dt;
    const p = 1 - Math.max(0, wv.t) / wv.dur; // 0..1
    const R = wv.r0 + (wv.r1 - wv.r0) * p;

    // 見た目：セグメント＋波形のリング
    addEffect('boomWaveSeg', {
      x:e.x, y:e.y, r:R, w:wv.w, life:.06,
      segCount: wv.segCount, gapFrac: wv.gapFrac,
      rot: wv.rot, wavAmp: wv.wavAmp, wavFreq: wv.wavFreq,
      phase: e.boomClock        // 波アニメ位相
    });

    // 当たり判定：厚み付きリング＆隙間免除
    const dx = state.player.x - e.x, dy = state.player.y - e.y;
    const d  = Math.hypot(dx, dy);
    const th = wv.w * 0.5;              // 当たりの半厚
    if (!wv.did && d >= R - th && d <= R + th){
      // 角度から“隙間”かどうかを判定
      const ang = Math.atan2(dy, dx);   // -PI..PI
      if (!angleInGap(ang, wv)){        // 隙間でなければヒット
        if (state.player.iTime <= 0) playerHit(60, e.x, e.y);
        wv.did = true;
      }
    }

    if (wv.t > 0) allDone = false;
  }

  if(allDone){
    e.cd = 2.4;
    e.phase = 'shoot';
  }
 }
 } 
 else {
  // === 既存 big の処理 ===
  
            if(e.phase==='shoot'){
            e.x += Math.cos(ang)*e.speed*dt*0.6*moveMul;
e.y += Math.sin(ang)*e.speed*dt*0.6*moveMul;
            if(e.cd<=0)
            {
              for(let k=-3;k<=3;k++){
                const a2 = ang + k*0.12;
                state.enemyBullets.push({
                  x:e.x, y:e.y,
                  vx:Math.cos(a2)*160, vy:Math.sin(a2)*160,
                  r:4, dmg:(state.mode.hardcore ? 14*1.5 : 14), life:3.5
                });
              }
              e.cd = 3.0;
            }
            if(e.dashCD<=0){
              e.phase='tele'; 
              e.tele=0.9;
              e.target = { x: state.player.x, y: state.player.y };
              const dx = e.target.x - e.x, dy = e.target.y - e.y;
              const m = Math.hypot(dx,dy)||1;
              e.dashDir = { x: dx/m, y: dy/m };
            }

          } else if(e.phase==='tele'){
            e.tele -= dt;
            addEffect('aim',{x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06});
            if(e.tele<=0){ 
              e.phase='dash'; 
              e.tele=0; 
            }

          } else if(e.phase==='dash'){
            const dashSpeed = 980;
            e.x += e.dashDir.x * dashSpeed * dt;
            e.y += e.dashDir.y * dashSpeed * dt;
            const rx = e.target.x - e.x, ry = e.target.y - e.y;
            if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
              e.cd = 2.0; 
              e.dashCD = 6.5; 
              e.phase='shoot';
            }
          }
        }
      }
      

// プレイヤー接触判定
let touchDmg =
  (e.type === 'big' || e.type === 'final')
    ? (e.phase === 'dash'
        ? (e.type === 'final' ? 65 : 50)
        : (e.type === 'final' ? 40 : 32))
    : (e.type === 'mid')
      ? 24
      : 18;

if (state.mode.hardcore) touchDmg *= 1.5;


      if (dist2(e.x, e.y, state.player.x, state.player.y) < (state.player.r + e.size * 0.6) ** 2) {
        if (state.player.iTime <= 0) {
          playerHit(touchDmg, e.x, e.y);
          if (state.player.hp <= 0) {
            gameOver();
            requestAnimationFrame(loop);
            return;
          }
        }
      }
// --- 毒フィールド（最大2枚までスタック） ---
let top1 = 0, top2 = 0;  // 上位2つのDPS
for (const ef of state.effects) {
  if (ef.type !== 'poisonField') continue;
  const dx = e.x - ef.x, dy = e.y - ef.y;
  if (dx*dx + dy*dy <= ef.r * ef.r) {
    const dps = ef.dps || 20;
    if (dps > top1) { top2 = top1; top1 = dps; }
    else if (dps > top2) { top2 = dps; }
  }
}
const poisonDps = top1 + top2; // ← 最大2枚ぶん
if (poisonDps > 0) {
  e.hp -= poisonDps * dt;
  e.hitFlash = Math.max(e.hitFlash, 0.06);
}
      // 敵死亡処理
      if(e.hp <= 0) {
          
          // ▼ キルスコア（敵種別で配点）
{
  let add = 0;
  if (e.type === 'final') add = 5000;
  else if (e.type === 'big') add = 150;
  else if (e.type === 'mid') add = 60;
  else if (e.type === 'shooter') add = 30;
  else add = 20; // minion 等

  state.score += add;
  state.killScore = (state.killScore || 0) + add;
  if (scoreVal) scoreVal.textContent = Math.floor(state.score);
}

          
if (e.type === 'final') {
  // 見た目：強い発光＋爆発
  addEffect('bossExplode', { x: e.x, y: e.y, R: 420, life: 0.9, life0: 0.9 });
  addEffect('flash', { life: 0.08 });


  // 後始末：敵・敵弾・アイテムをクリア＆スポーン停止
  state.enemies.length = 0;
  state.enemyBullets.length = 0;
  state.items.length = 0;
  state.spawnTimer = 9999;



  // クリア遷移（少し見せてから）
state.winCountdown = 1.2;
state._winLast = performance.now();   // ← カウントの基準時刻を初期化
state.paused = false;                 // ← ポーズ中でも tick が効くが、ここで一旦解除しておくと確実
} else if (e.type === 'mid' || e.type === 'big') {
          const picks = (e.type === 'big') ? 2 : 1;
          state.items.push({ kind: 'chest', x: e.x, y: e.y, r: 14, t: 0, picks });
          addEffect('text', { x: e.x, y: e.y, life: 1.2, text: (picks === 2 ? '宝箱×2！' : '宝箱！') });
          spark(e.x, e.y, e.type === 'mid' ? 22 : 34);
        } else {
          const val = 1 + (Math.random() < 0.2 ? 1 : 0);
          dropGem(e.x, e.y, val);
          spark(e.x, e.y, 10);
        }
        state.enemies.splice(i, 1);
      }
      // ====== 追記ここまで ======

      }

    // === アイテム ===
    for(let i=state.items.length-1;i>=0;i--){
      const it=state.items[i]; it.t += dt;
      if(dist2(it.x,it.y,state.player.x,state.player.y) < (it.r + state.player.r)**2){
        applyItem(it); state.items.splice(i,1); spark(state.player.x,state.player.y,14);
      }
      if(it.t>20){ state.items.splice(i,1); }
    }


    // === Magnet timer ===
    if (state.magnet?.active) {
      state.magnet.time += dt;
      if (state.magnet.time >= (state.magnet.dur || 0.8)) {
        state.magnet.active = false;
      }
    }
    // === ジェム ===
    let pickupR = 70 * (1 + 0.6 * state.pickupLv);
    if (state.pickupLv >= 3) {
      pickupR = Math.hypot(W / DPR, H / DPR);
    }
        if (state.magnet?.active) {
      pickupR = Math.hypot(W / DPR, H / DPR);
    }
    for(let i=state.gems.length-1;i>=0;i--){
      const g=state.gems[i];
      const d = Math.hypot(state.player.x-g.x, state.player.y-g.y);
      if(d<pickupR){
        const ax = (state.player.x-g.x)/Math.max(1,d);
        const ay = (state.player.y-g.y)/Math.max(1,d);
                const sp = state.magnet?.active ? (state.magnet.speed || 900) : 220;
        g.x += ax * sp * dt; g.y += ay * sp * dt;
      }
      if(dist2(g.x,g.y,state.player.x,state.player.y) < (state.player.r+g.r)**2){
        addXP(g.val*5); state.gems.splice(i,1);
      }
    }

    // === パーティクル ===
    for(let i=state.sparks.length-1;i>=0;i--){
      const p=state.sparks[i]; 
      p.t+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      if(p.t>p.life) state.sparks.splice(i,1);
    }
    for(let i=state.effects.length-1;i>=0;i--){
      const e=state.effects[i]; 
      if (e.vx) e.x += e.vx * dt;
if (e.vy) e.y += e.vy * dt;

      e.life-=dt; 
      if(e.life<=0){ state.effects.splice(i,1); }
    }


    // === クリア遷移カウントダウン ===
    if (state.winCountdown > 0){
      state.winCountdown -= dt;
      if (state.winCountdown <= 0){
        state.winCountdown = 0;
        showGameClear();
      }
    }

    updateHUD(); 
    draw();
    requestAnimationFrame(loop);

  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    requestAnimationFrame(loop);
  }
}

// === item icons (magnet & bomb) ===
// XP青丸の中心に、上が開いた赤い「U」を余白つきで綺麗に収めて描く
function drawMagnet(ctx, x, y, r, t){
  ctx.save(); ctx.translate(x, y);

  // 1) 背景：XPと同じ青丸（単色）
  const XP = '#3fa9ff';
  const R  = r * 1.35;                     // バッジ半径（以前より少しだけ小さめ）
  ctx.fillStyle = XP;
  ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI * 2); ctx.fill();

  // 2) U字の寸法を「円の内側に収める」条件から計算
  const pad   = Math.max(2, R * 0.14);      // 円の縁からの余白（px）
  const Uout  = R - pad;                    // Uの外周（円の内側に接する半径）
  let thick   = Math.max(3, R * 0.32);      // Uの太さ（見た目バランス）
  thick       = Math.min(thick, Uout * 0.9);// 太さが外半径を食い潰さないように
  const RU    = Uout - thick / 2;           // Uの“中心半径”（ここにストローク中心が来る）
  const topY  = -Uout + thick / 2;          // 縦棒の上端：円内側にぴったり収まる高さ

  // 3) U字（左棒 → 下弧 → 右棒）を別パスでストローク
  ctx.strokeStyle = '#ef4444';
  ctx.lineWidth   = thick;
  ctx.lineCap     = 'round';
  ctx.lineJoin    = 'round';

  // 左の縦棒
  ctx.beginPath();
  ctx.moveTo(-RU, topY);
  ctx.lineTo(-RU, 0);
  ctx.stroke();

  // 下半円（Uの底）— 反時計回り true で“下側”を通る
  ctx.beginPath();
  ctx.arc(0, 0, RU, Math.PI, 0, true);
  ctx.stroke();

  // 右の縦棒
  ctx.beginPath();
  ctx.moveTo( RU, 0);
  ctx.lineTo( RU, topY);
  ctx.stroke();

  ctx.restore();
}




function drawBomb(ctx, x, y, r, t){
  ctx.save(); ctx.translate(x,y);
  const R = r*1.25;

  // 本体
  ctx.fillStyle = '#773333';                                // ほぼ黒（少し赤み）
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  // ハイライト
  ctx.fillStyle = 'rgba(255,255,255,.08)';
  ctx.beginPath(); ctx.arc(-R*0.35,-R*0.35,R*0.55,0,Math.PI*2); ctx.fill();

  // 導火線
  ctx.strokeStyle = '#c4b5fd';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(R*0.3,-R*0.2);
  ctx.quadraticCurveTo(R*0.9,-R*0.9, R*1.15,-R*1.25);
  ctx.stroke();

  // 火花（アニメ）
  const a = t*8;
  const sx = R*1.15, sy = -R*1.25;
  ctx.translate(sx, sy);
  ctx.rotate(a);
  ctx.fillStyle = '#fde68a';
  for(let i=0;i<6;i++){
    ctx.rotate(Math.PI/3);
    ctx.beginPath();
    ctx.moveTo(0,0); ctx.lineTo(6,0); ctx.lineTo(0,12); ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

// === Heal: 緑丸 + 白十字（軽いグロー & 鼓動）===
function drawHealIcon(ctx, x, y, r, t){
  ctx.save();
  // 鼓動（ほんの少しだけ拡縮）
  const s = 1 + Math.sin(t*4.0)*0.06;
  ctx.translate(x, y); ctx.scale(s, s);

  // 下地のグロー
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#22c55e';
  ctx.beginPath(); ctx.arc(0,0,r*1.3,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // 本体の緑丸（経験値とは色を明確に分ける）
  const g = ctx.createRadialGradient(-r*0.3,-r*0.3, r*0.2, 0,0, r);
  g.addColorStop(0, '#34d399');
  g.addColorStop(1, '#16a34a');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();

  // 白十字
  ctx.fillStyle = '#fff';
  const w = r*0.55, th = Math.max(2, r*0.22);
  ctx.fillRect(-th/2, -w/2, th, w);       // 縦棒
  ctx.fillRect(-w/2, -th/2, w, th);       // 横棒

  // 輪郭（薄く）
  ctx.strokeStyle = 'rgba(0,0,0,.25)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();

  ctx.restore();
}

// === Chest: 金の宝箱（蓋・金帯・錠前・軽い上下揺れ）===
function drawChestIcon(ctx, x, y, r, t){
  // ★保険：非数を回避
  r = Math.max(8, Number(r) || 14);
  x = Number.isFinite(x) ? x : 0;
  y = Number.isFinite(y) ? y : 0;

  ctx.save();
  // ちょっとだけ上下にふわふわ
  y += Math.sin(t*3.2) * Math.min(6, r*0.18);
  ctx.translate(x, y);

  const W = r*2.0, H = r*1.5;
  const lidH = H*0.45;
  const baseH = H - lidH;

  // 影
  ctx.globalAlpha = .20;
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(0, H*0.65, W*0.6, r*0.45, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // 本体（底）
  const bodyGrad = ctx.createLinearGradient(0, -H*0.2, 0, baseH);
  bodyGrad.addColorStop(0, '#d97706');  // 明るい金
  bodyGrad.addColorStop(1, '#b45309');  // 濃い金
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(-W*0.5, 0, W, baseH);
  // 角Rっぽく見せる線
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;
  ctx.strokeRect(-W*0.5, 0, W, baseH);

  // 蓋
  const lidGrad = ctx.createLinearGradient(0, -lidH, 0, 0);
  lidGrad.addColorStop(0, '#f59e0b');
  lidGrad.addColorStop(1, '#d97706');
  ctx.fillStyle = lidGrad;
  ctx.beginPath();
  ctx.moveTo(-W*0.5, 0);
  ctx.lineTo(W*0.5, 0);
  ctx.quadraticCurveTo(W*0.5, -lidH, 0, -lidH);
  ctx.quadraticCurveTo(-W*0.5, -lidH, -W*0.5, 0);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.stroke();

  // 金属帯（縦2本 + 横1本）
  ctx.fillStyle = '#facc15';
  const bandW = Math.max(3, r*0.22);
  ctx.fillRect(-W*0.25 - bandW/2, -lidH*0.2, bandW, baseH + lidH*0.2);
  ctx.fillRect( W*0.25 - bandW/2, -lidH*0.2, bandW, baseH + lidH*0.2);
  ctx.fillRect(-W*0.5, baseH*0.55, W, bandW);

  // 錠前
  ctx.fillStyle = '#eab308';
  const lockW = Math.max(8, r*0.6)*0.6, lockH = Math.max(10, r*0.6)*0.75;
  ctx.fillRect(-lockW/2, baseH*0.25, lockW, lockH);
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(0, baseH*0.25 + lockH*0.6, Math.max(2, r*0.12), 0, Math.PI*2); ctx.fill();

  ctx.restore();
}


// ==== 描画 ====
function draw(){

  try {
    ctx.clearRect(0,0,cv.width,cv.height);

    // ===== 背景 =====
    const vw = cv.width / DPR, vh = cv.height / DPR;
    const px = PLAY.x, py = PLAY.y, pw = PLAY.w, ph = PLAY.h;

    // 余白（情報エリア側を含む）をうっすら暗く
    ctx.fillStyle = '#0b0b0b';
    // 上下
    ctx.fillRect(0, 0, vw, py);
    ctx.fillRect(0, py + ph, vw, Math.max(0, vh - (py + ph)));
    // 左右
    ctx.fillRect(0, py, px, ph);
    ctx.fillRect(px + pw, py, Math.max(0, vw - (px + pw)), ph);

    // プレイ面の下地
    ctx.fillStyle = '#101010';
    ctx.fillRect(px, py, pw, ph);

    // ===== グリッド（WORLD単位で一定の間隔）=====
    ctx.save();
    ctx.beginPath(); ctx.rect(px, py, pw, ph); ctx.clip();

    // WORLD座標で描くため、先に同じ変換を掛ける
    ctx.translate(px + pw*0.5, py + ph*0.5);
    const sFitOnly = Math.min(pw / WORLD.w, ph / WORLD.h);
    ctx.scale(sFitOnly, sFitOnly);
    ctx.translate(-WORLD.w * 0.5, -WORLD.h * 0.5);

    ctx.globalAlpha = .06;
    ctx.strokeStyle = '#666';

    const stepWorld = 64; // WORLD上のマス目サイズ（お好みで）
    for (let x = 0; x <= WORLD.w; x += stepWorld){
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD.h); ctx.stroke();
    }
    for (let y = 0; y <= WORLD.h; y += stepWorld){
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD.w, y); ctx.stroke();
    }
    ctx.restore();

    // ===== ワールド変換：プレイ面の中心を原点に（WORLD基準）=====
    ctx.save();

    // 画面のプレイ枠(PLAY)に、WORLD(実寸)を等倍で入れるスケール
    const sFit = Math.min(pw / WORLD.w, ph / WORLD.h);

    // 既存のカメラズームがあれば掛け合わせ
    const z = (typeof state?.cameraZoom === 'number') ? state.cameraZoom : 1;

    // プレイ枠の中心へ → WORLDをフィット倍率×ズームでスケール → WORLD(0..w,0..h)の左上を原点へ
    ctx.translate(px + pw*0.5, py + ph*0.5);
    ctx.scale(sFit * z, sFit * z);
    ctx.translate(-WORLD.w * 0.5, -WORLD.h * 0.5);

    // プレイ枠外（黒帯）に描かれないよう、WORLD内でクリップ
ctx.beginPath();
ctx.rect(0, 0, WORLD.w, WORLD.h);
ctx.clip();

    // ▼▼ この下は既存のワールド描画（items, enemies, bullets など） ▼▼

// ▼▼ ここからプレイヤー／敵／弾／床など“ワールド”の描画（既存） ▼▼

// items
for (const it of state.items){
  const t = state.t || 0;

  if (it.kind === 'magnet'){
    drawMagnet(ctx, it.x, it.y, it.r, t);

  } else if (it.kind === 'nuke'){
    drawBomb(ctx, it.x, it.y, it.r, t);

  } else if (it.kind === 'heal'){
    drawHealIcon(ctx, it.x, it.y, it.r, t);

} else if (it.kind === 'chest'){
  const rr = Number.isFinite(it.r) ? it.r : 14;   // rが無い/NaNなら14に
  const xx = Number.isFinite(it.x) ? it.x : 0;    // 念のため
  const yy = Number.isFinite(it.y) ? it.y : 0;
  drawChestIcon(ctx, xx, yy, rr * 1.2, t);
} else {
    // フォールバック（未定義）
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath(); ctx.arc(it.x, it.y, it.r, 0, Math.PI*2); ctx.fill();
  }
}

  // gems
  for(const g of state.gems){
    ctx.fillStyle='#3fa9ff';
    ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2); ctx.fill();
  }

// bullets
for (const b of state.bullets){
  if (b.type === 'rock'){
    // 既存そのまま
    ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.spin||0);
    ctx.fillStyle = '#b39c82';
    const n=8, r=b.r;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a=(i/n)*Math.PI*2, px=Math.cos(a)*r, py=Math.sin(a)*r;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill(); ctx.restore();

    } else if (b.type === 'slash') {
      // 三日月っぽい斬撃
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.ang || Math.atan2(b.vy, b.vx));
      const outer = b.r * 1.2;
      const inner = Math.max(outer * 0.45, 8);
      ctx.beginPath();
      ctx.arc(0, 0, outer, -0.6, 0.6);
      ctx.arc(0, 0, inner, 0.6, -0.6, true);
      ctx.closePath();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();

  } else if (b.type === 'homing'){
    // 既存そのまま
    ctx.save(); ctx.translate(b.x,b.y);
    ctx.fillStyle = '#a0e1ff';
    ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.restore();

  } else if (b.type === 'ghost') {
    // ★ ゴースト弾：紫＋発光
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.fillStyle = '#a56bff';      // 紫
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#cfa9ff';    // 薄紫に光らせる
    ctx.beginPath();
    ctx.arc(0, 0, b.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

  } else {
    // ★ 自分の通常弾：白系に変更（見分けやすい軽い発光）
    ctx.save();
    ctx.fillStyle = '#f5f7ff';          // 明るい白
    ctx.shadowBlur = 8;                  // うっすら光る
    ctx.shadowColor = '#ffffff';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}



  // enemy bullets（視認性強化）
  for (const b of state.enemyBullets){
    const x = b.x, y = b.y;
    const rPhys = b.r || 5;        // 当たり判定半径（変更なし）
    const rVis  = rPhys + 2.5;     // 見た目は少し大きく

    ctx.save();

    // 1) 外縁（ダークアウトライン）
    ctx.beginPath();
    ctx.arc(x, y, rVis + 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fill();

    // 2) コア（白→オレンジの放射グラデ＋やわらかい発光）
    const g = ctx.createRadialGradient(x, y, 0, x, y, rVis);
    g.addColorStop(0.00, '#F47A4D');
    g.addColorStop(0.55, '#F47A4D');
    g.addColorStop(1.00, '#E15A28');
    ctx.beginPath();
    ctx.arc(x, y, rVis, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.shadowColor = 'rgba(255,255,255,0.85)';
    ctx.shadowBlur  = 8;
    ctx.fill();

    // 3) リムハイライト（白い細縁）
    const dpr = (typeof DPR !== 'undefined' && DPR) ? DPR : (window.devicePixelRatio || 1);
    ctx.lineWidth = 0.2 * dpr;
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.stroke();

    ctx.restore();

    // 速度が速い弾は1pxの白点でチラ見せ（任意）
    if ((b.vx*b.vx + b.vy*b.vy) > 120*120){
      ctx.fillStyle = '#fff';
      ctx.fillRect((x|0)-0.5, (y|0)-0.5, 1, 1);
    }
  }

// 無敵中は点滅
if (state.player.iTime > 0 && ((state.t * 20 | 0) % 2 === 0)) {
  ctx.globalAlpha = 0.38; // 薄く
} else {
  ctx.globalAlpha = 1;
}
// player

if (state.player && state.player.visible === false) {
  // 何も描かない
} else {
ctx.fillStyle = '#2ecc71';
ctx.beginPath(); ctx.arc(state.player.x, state.player.y, state.player.r, 0, Math.PI*2); ctx.fill();
ctx.lineWidth = 3; ctx.strokeStyle = '#ffffff'; ctx.stroke();
ctx.fillStyle = '#0b0b0b';
ctx.beginPath(); ctx.arc(state.player.x-5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(state.player.x+5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();

ctx.globalAlpha = 1;  // ← ここまでが既存
}

/* ===== ここから追記：プレイヤー周囲リング（HP/XP） ===== */
{
  const hpRatio = Math.max(0, Math.min(1, state.player.hp / state.player.maxHp));
  const xpRatio = Math.max(0, Math.min(1, state.player.xp / state.player.nextXp(state.player.level)));

  const R0 = state.player.r + 7;   // HPリング半径
  const R1 = state.player.r + 12;  // XPリング半径

  ctx.save();
  ctx.lineCap = 'round';

  // 背景リング（薄グレー）
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R0, 0, Math.PI*2); ctx.stroke();
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R1, 0, Math.PI*2); ctx.stroke();

  // ★ HPリング（20%以下で赤、それ以外は緑）
  const hpColor = (hpRatio <= 0.20) ? '#ff5a5a' : '#2ecc71';
  ctx.strokeStyle = hpColor;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R0,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*hpRatio
  );
  ctx.stroke();

  // XPリング（青）
  ctx.strokeStyle = '#3498db';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R1,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*xpRatio
  );
  ctx.stroke();

  // （狭い画面向け）HP数値の小表示はそのままでOK
  if (window.innerWidth <= 480) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${Math.ceil(state.player.hp)}/${state.player.maxHp}`,
      state.player.x, state.player.y - R0 - 6);
  }

  ctx.restore();
}
/* ===== 追記ここまで ===== */


// Ghosts render
if(state.weapons.ghost.lv>0){
  const w = state.weapons.ghost;
  const count = w.awaken ? 6 : w.lv;
  ctx.save();
  ctx.globalAlpha = 0.85;
  for(let k=0;k<count;k++){
    const a = w.ang + k * (Math.PI*2/count);
    const r = 40 + 6*(w.lv-1);
    const gx = state.player.x + Math.cos(a)*r;
    const gy = state.player.y + Math.sin(a)*r;

    // --- 本体 ---
    ctx.fillStyle = '#7ee4ff'; // 水色ボディ
    ctx.beginPath();
    ctx.arc(gx, gy, 9, 0, Math.PI*2);
    ctx.fill();

    // --- 顔（目＋口） ---
    ctx.fillStyle = '#000';  // 黒目
    ctx.beginPath(); ctx.arc(gx - 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();

ctx.strokeStyle = '#000';
ctx.lineWidth = 1.5;       // 少し太めに
ctx.lineCap = 'round';     // 端を丸くして自然に
ctx.beginPath();
ctx.moveTo(gx - 3, gy + 2);
ctx.lineTo(gx + 3, gy + 2);
ctx.stroke();
  }
  ctx.restore();
}

// orbitals
if(state.weapons.orbit.lv>0){
  const w = state.weapons.orbit;
  const count = w.awaken ? 8 : (2 + w.lv);
  const rad = w.baseR + 14*(w.lv-1) + (w.awaken? 12:0);
  const orbR = (w.hitRBase + (w.awaken? 4:0)) * state.mods.sizeMul;

  ctx.fillStyle = '#9b59b6';
  for(let k=0;k<count;k++){
    const ang = w.ang + k*(Math.PI*2/count);
    const ox = state.player.x + Math.cos(ang)*rad;
    const oy = state.player.y + Math.sin(ang)*rad;
    ctx.beginPath(); ctx.arc(ox, oy, orbR, 0, Math.PI*2); ctx.fill();
  }
}

  // enemies with HP bars
  for(const e of state.enemies){
    const s=e.size;
    if(e.type==='minion'){ ctx.fillStyle='#e74c3c'; }
    else if(e.type==='shooter'){ ctx.fillStyle='#f39c12'; }
    else if(e.type==='mid'){ ctx.fillStyle='#00bcd4'; }
    else if(e.type==='final'){ ctx.fillStyle='#ffd700'; }
    else { ctx.fillStyle='#ff00aa'; }
    ctx.fillRect(e.x-s/2, e.y-s/2, s, s);
    if(e.hitFlash>0){
      ctx.save(); ctx.globalAlpha=e.hitFlash; ctx.fillStyle='#fff';
      ctx.fillRect(e.x-s/2,e.y-s/2,s,s); ctx.restore();
    }
    const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
    const bw = s, bh = 4; const bx = e.x - bw/2, by = e.y - s/2 - 6;
    ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
    ctx.fillRect(bx, by, bw*ratio, bh);
    ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
  }

 // effects
for (const ef of state.effects) {
  if (ef.type === 'nova') {
    ctx.save();
    const life0 = 0.25;                 // ef.life は 0.25 付近を想定
    const a = Math.max(0, ef.life / life0);

    // 外輪（強めの発光＋太め）
    ctx.globalAlpha = 0.85 * a;
    ctx.strokeStyle = '#6fbaff';
    ctx.lineWidth = 6;
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#9fd3ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.55), 0, Math.PI * 2);
    ctx.stroke();

    // うっすら塗り
    ctx.globalAlpha = 0.20 * a;
    ctx.fillStyle = '#6fbaff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.65), 0, Math.PI * 2);
    ctx.fill();

    // 内側ハイライト輪
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.95 * a;
    ctx.strokeStyle = '#e7fbff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.70), 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

} else if (ef.type === 'healText') {
  const a = Math.max(0, ef.life / (ef.life0 || 0.8)); // 残存率
  const t = 1 - a;                                    // 経過率 0→1
  // カメラオフセットは "nova" の直前のブロックと同じ変数を流用してください
  const ox = (state.cam && state.cam.x) || (state.viewX || 0);
  const oy = (state.cam && state.cam.y) || (state.viewY || 0);
  const sx = (ef.x - ox);
  const sy = (ef.y - oy) - (18 + 14 * t); // 上にふわっと
  ctx.save();
  ctx.globalAlpha = a;
  ctx.font = '700 16px system-ui, -apple-system, Segoe UI, Roboto';
  const txt = '+' + (ef.val % 1 === 0 ? ef.val.toFixed(0) : ef.val.toFixed(1));
  // 縁取り→塗り（視認性UP）
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(0,0,0,.55)';
  ctx.strokeText(txt, sx, sy);
  ctx.fillStyle = '#6ef08a'; // 明るい緑
  ctx.fillText(txt, sx, sy);
  ctx.restore();

  } else if (ef.type === 'aura') {
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#85c1ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

} else if (ef.type === 'slash') {
  const a = Math.max(0, ef.life / (ef.life0 || 0.18));
  ctx.save();
  ctx.translate(ef.x, ef.y);
  ctx.rotate(ef.ang);

  const R    = (ef.outer + ef.inner) * 0.5;
  // ★ 太さの基準：1/3（既に適用しているならそのまま）
  const Wbase = (ef.outer - ef.inner) * 0.33;

  // ★ 連撃の段に応じて少しだけ“強調”
  const boost = ef.comboIdx ? Math.min(0.12 * ef.comboIdx, 0.24) : 0; // 2段目=+0.12
  const W = Wbase * (1.0 + boost);          // 少しだけ太く
  const span = ef.span;
  const LAYERS = 6;

  // --- 外側ブルーグロー ---
  ctx.globalAlpha = (0.45 + boost*0.6) * a;  // 2段目は少し明るく
  ctx.strokeStyle = '#4cc3ff';
  ctx.lineCap     = 'round';
  ctx.shadowBlur  = 18;
  ctx.shadowColor = '#9fd3ff';
  for (let i = 0; i < LAYERS; i++) {
    const t = i / (LAYERS - 1);
    const lw   = W * (0.52 - 0.36 * t);
    const trim = span * (0.06 + boost*0.02) * t; // 端を少し多めに削って切れ味UP
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.arc(0, 0, R, -span * 0.5 + trim, span * 0.5 - trim);
    ctx.stroke();
  }

  // --- 白ハイライト ---
  ctx.shadowBlur  = 0;
  ctx.globalAlpha = (0.88 + boost*0.1) * a;
  ctx.strokeStyle = '#e8fbff';
  ctx.lineWidth   = Math.max(2, W * 0.18);
  ctx.beginPath();
  ctx.arc(0, 0, R, -span * 0.5 + span * (0.08 + boost*0.02), span * 0.5 - span * (0.08 + boost*0.02));
  ctx.stroke();

  ctx.restore();
} else if (ef.type === 'poisonField') {
  ctx.save();
  const a = Math.max(0, ef.life / (ef.life0 || 5));
  // 外グロー
  ctx.globalAlpha = 0.22 * a;
  ctx.fillStyle = '#7eff7e';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.fill();
  // 内ゆらぎ
  ctx.globalAlpha = 0.10 * a;
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r*0.7 + Math.sin(state.t*2.2)*6, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();


  } else if (ef.type === 'aim') {
    // 汎用の赤系予告線（ボスdashなど）
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ff66cc';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.beginPath();
    ctx.moveTo(ef.x1, ef.y1);
    ctx.lineTo(ef.x2, ef.y2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

  } else if (ef.type === 'line') {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ffcccc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(ef.x + ef.dx * 80, ef.y + ef.dy * 80);
    ctx.stroke();
    ctx.restore();

  } else if (ef.type === 'text') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life);
ctx.fillStyle = (ef.color || '#fff');
    ctx.font = 'bold 16px system-ui';
    ctx.fillText(ef.text, ef.x, ef.y - (1 - ef.life) * 20);
    ctx.restore();

} else if (ef.type === 'laserGhost') {
  // 予備線：太い半透明の帯。球が多くても視認しやすい
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0→1 に正規化

  // 外側のやわらかい“色つきハロ”
  ctx.globalAlpha = 0.35 * a;
  ctx.strokeStyle = '#7fd9ff';       // 薄いシアン系
  ctx.lineWidth = (ef.w || 48) * 2;  // 外ハロは太め
  ctx.shadowBlur = 28;
  ctx.shadowColor = '#90e4ff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // 内側の軸（さらに薄い）
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.22 * a;
  ctx.strokeStyle = '#dff6ff';
  ctx.lineWidth = (ef.w || 48);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  ctx.restore();

} else if (ef.type === 'laserBeam') {
  // レーザー本体：極太・高輝度。α正規化＋太さ増し
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0→1 に正規化

  // 外側の強い光
  ctx.globalAlpha = 0.95 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = (ef.w || 48) * 3; // さらに太く
  ctx.shadowBlur = 32;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // 内側ハイライト
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1.0 * a;
  ctx.strokeStyle = '#f5fbff';
  ctx.lineWidth = Math.max(8, ((ef.w || 48) * 3) - 8);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();
  ctx.restore();

  } else if (ef.type === 'whiteCharge') {
    // 爆発予備動作：白く強く光る玉
    ctx.save();
    const a = Math.max(0, ef.life); // 1 → 0
    const r = ef.r0 + (1 - a) * (ef.r1 - ef.r0);

    // 塗り（白）
    ctx.globalAlpha = 0.35 + 0.45 * a;
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 28;
    ctx.shadowColor = '#ffffff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r * 0.92, 0, Math.PI * 2);
    ctx.fill();

    // 輪郭（白）
    ctx.globalAlpha = 0.9;
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

} else if (ef.type === 'megaNova') {
  // 本爆発：でかい光輪＋淡い塗り、少し長め
  ctx.save();
  const a = Math.max(0, ef.life); // 0.9 → 0
  const R = ef.r * (1 - a * 0.5);

  // 外輪（強発光）
  ctx.globalAlpha = 0.95 * a;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth = 12;
  ctx.shadowBlur = 36;
  ctx.shadowColor = '#fffbe3';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, R, 0, Math.PI * 2);
  ctx.stroke();

  // 塗り
  ctx.globalAlpha = 0.28 * a;
  ctx.fillStyle = '#fff1b3';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, R * 0.95, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();


} else if (ef.type === 'whitePulse') {
  // 予備パルス：小さく白く光る玉（charge_boomで使用）
  ctx.save();
  const a = Math.max(0, ef.life / 0.06);           // 0→1
  const r = ef.r0 + (ef.r1 - ef.r0) * (1 - a);     // だんだん小→大 でも OK（好み）
  ctx.globalAlpha = 0.4 * a;
  ctx.fillStyle = '#ffffff';
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r * 0.9, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.9 * a;
  ctx.shadowBlur = 0;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r, 0, Math.PI*2); ctx.stroke();
  ctx.restore();

} else if (ef.type === 'boomWave') {
  // 半透明の“拡大リング” + 破線で隙間を作る
  ctx.save();
  const a = Math.max(0, ef.life / (ef.life0 || 0.06));
  const w = ef.w || 24;

  // 外側ハロ（そのまま）
  ctx.globalAlpha = 0.28 * a;
  ctx.strokeStyle = '#ffd27a';
  ctx.lineWidth = w * 1.6;
  ctx.shadowBlur = 24;
  ctx.shadowColor = '#ffe4ad';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // ★ 主リングを破線にする（ダッシュ間隔は好みで調整）
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9 * a;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth = w;

  // 破線（例：描18px / 空16px）。回転させて“波”っぽく
  const dash = 18, gap = 16;
  ctx.setLineDash([dash, gap]);
  ctx.lineDashOffset = -state.t * 120; // 時間で流れる

  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // 内ハイライト（こちらは細破線にしてもOK／無地でもOK）
  ctx.globalAlpha = 0.85 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = Math.max(4, w - 6);
  ctx.setLineDash([12, 14]);
  ctx.lineDashOffset = -state.t * 160;

  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // 後始末
  ctx.setLineDash([]);
  ctx.restore();

} else if (ef.type === 'boomWaveSeg') {
  // 角度方向に大きな“穴”を開けた、波打つリング
  ctx.save();
  const life0 = 0.06;
  const alpha = Math.max(0, ef.life / life0);
  const segCount = Math.max(3, ef.segCount|0);
  const gapFrac  = Math.max(0, Math.min(0.9, ef.gapFrac||0.35));
  const rot      = ef.rot || 0;
  const w        = ef.w || 20;
  const amp      = ef.wavAmp || 8;
  const freq     = Math.max(1, ef.wavFreq|0);
  const phase    = (ef.phase || 0) * 2.2; // 波アニメ

  const cx = ef.x, cy = ef.y;
  const segSpan = (Math.PI*2)/segCount;
  const gapSpan = segSpan*gapFrac;
  const drawSpan= segSpan-gapSpan;

  // 外ハロ
  ctx.globalAlpha = 0.26 * alpha;
  ctx.strokeStyle = '#ffd27a';
  ctx.lineWidth   = w * 1.5;
  ctx.shadowBlur  = 22;
  ctx.shadowColor = '#ffe4ad';

  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;      // 穴の後ろから描き始め
    const a1 = a0 + drawSpan;

    // ポリラインで“波”半径を与える
    ctx.beginPath();
    const steps = 28;                           // なめらかさ
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp; // 半径を波打たせる
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // 主リング
  ctx.shadowBlur  = 0;
  ctx.globalAlpha = 0.9 * alpha;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth   = w;
  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;
    const a1 = a0 + drawSpan;
    ctx.beginPath();
    const steps = 28;
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // 内ハイライト
  ctx.globalAlpha = 0.85 * alpha;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth   = Math.max(4, w-6);
  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;
    const a1 = a0 + drawSpan;
    ctx.beginPath();
    const steps = 28;
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  ctx.restore();

  } else if (ef.type === 'bossExplode') {
    // ボス撃破演出：画面フラッシュ＋多重リング
    ctx.save();
    const a = Math.max(0, ef.life / (ef.life0 || 0.8));

    // 画面フラッシュ
    ctx.globalAlpha = 0.4 * a;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);

    // 複数リング
    const rings = [
      { color: '#fff2b3', w: 16, blur: 24, mul: 1.00 },
      { color: '#ffe680', w: 10, blur: 16, mul: 0.75 },
      { color: '#ffd24d', w: 6,  blur: 10, mul: 0.55 },
    ];
    for (const r of rings) {
      ctx.globalAlpha = 0.9 * a;
      ctx.strokeStyle = r.color;
      ctx.lineWidth = r.w;
      ctx.shadowBlur = r.blur;
      ctx.shadowColor = r.color;
      ctx.beginPath();
      ctx.arc(ef.x, ef.y, ef.R * (1 - a * 0.7) * r.mul, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();

  } else if (ef.type === 'flash') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life * 0.8);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);
    ctx.restore();

    } else if (ef.type === 'healSparkles') {
    ctx.save();
    const a = Math.max(0, (ef.life0 ? (ef.life / ef.life0) : ef.life)); // 0→1
    const prog = 1 - a;
    const n = ef.count || 12;
    for (let i = 0; i < n; i++) {
      const th = (i / n) * Math.PI * 2;
      const rr = (ef.r || 40) * (0.3 + 0.8 * prog);
      const x = ef.x + Math.cos(th) * rr;
      const y = ef.y + Math.sin(th) * rr;

      // 本体（緑）
      ctx.globalAlpha = 0.85 * a;
      ctx.fillStyle = '#34d399';
      ctx.beginPath(); ctx.arc(x, y, 3.2, 0, Math.PI * 2); ctx.fill();

      // ハイライト（白寄り）
      ctx.globalAlpha = 0.9 * a;
      ctx.fillStyle = '#eafff1';
      ctx.beginPath(); ctx.arc(x - 0.8, y - 0.8, 1.6, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
 }else if (ef.type === 'zig') {
  // 稲妻（ライトニング）— 青黒系でやや落ち着いた発光
  const pts = ef.path;
  if (!pts || pts.length < 2) { continue; }

  ctx.save();
  const a = Math.max(0, ef.life / 0.22);

  // 少し抑えめの全体アルファ
  ctx.globalAlpha = 0.78 * a;

  // 外側（本体）：くすんだ青、弱めのグロー
  ctx.strokeStyle = '#6a93c2';   // 青黒寄り
  ctx.lineWidth   = ef.thick;
  ctx.lineJoin    = 'round';
  ctx.shadowBlur  = 10;          // 14 → 10（まぶしさ軽減）
  ctx.shadowColor = '#3c5b86';   // 暗い青の光
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.stroke();

  // 内側ハイライト：白ではなく淡い青で目に優しく
  ctx.shadowBlur  = 0;
  ctx.lineWidth   = Math.max(2, ef.thick - 2);
  ctx.globalAlpha = 0.72 * a;    // 0.9 → 0.72
  ctx.strokeStyle = '#b7cbea';   // 淡い青
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.stroke();

  ctx.restore();
}   }
  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    throw err; // loop 側でも拾えるように
  }
  
if (scoreVal) scoreVal.textContent = Math.floor(state.score || 0);  

// ▲▲ ワールド描画終わり（HUDを等倍に戻す） ▲▲
ctx.restore();

// ▼ この下でHUD/UI（等倍）を描く（既存のまま）
} // ← function draw の閉じカッコ

// ===== ここから下はヘルパ =====

// === 雑魚（minion/shooter）だけを数える現在数 ===
function countTrash() {
  let n = 0;
  for (const e of state.enemies) {
    if (e.type === 'minion' || e.type === 'shooter') n++;
  }
  return n;
}

// === 時間に応じた同時出現の上限（序盤は低い） ===
function currentTrashCap(tSec) {
  // 0–60s: 10体, 60–120s: 14, 120–180s: 18, 180–240s: 24
  // 240–360s: 30, 360s以降: 徐々に48まで
  if (tSec < 60)   return 10;
  if (tSec < 120)  return 18;
  if (tSec < 180)  return 25;
  if (tSec < 240)  return 40;
  if (tSec < 360)  return 60;
  // 6分以降は少しずつ上限↑（最大150）
  return Math.min(150, 30 + Math.floor((tSec - 360) / 20));
}

function normAngle(a){
  // 0..2PI に正規化
  const PI2 = Math.PI*2;
  return ((a % PI2) + PI2) % PI2;
}

// リングのセグメント“隙間”内に角度が入っているか？
function angleInGap(angle, wv){
  // segCount で 0..2PI を等分し、各セグメントの先頭側 gapFrac を“穴”とみなす
  const A = normAngle(angle - (wv.rot||0));
  const segSpan = (Math.PI*2) / wv.segCount;
  const idx = Math.floor(A / segSpan);
  const local = A - idx*segSpan;          // 0..segSpan
  const gapSpan = segSpan * wv.gapFrac;   // ★ 隙間の角度幅
  return local < gapSpan;                  // 先頭側に“穴”
}


function pointLineDist(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = Math.max(1e-6, vx * vx + vy * vy);
  const t = Math.max(0, Math.min(1, (vx * wx + vy * wy) / denom));
  const dx = x1 + vx * t - px, dy = y1 + vy * t - py;
  return Math.hypot(dx, dy);
}

function triggerFinalExplosion(x, y) {
  // 他の敵・弾・アイテムは即時消去
  state.enemies.length = 0;
  state.enemyBullets.length = 0;
  state.items.length = 0;
  state.spawnTimer = 9999;

  // 画面全体に近い大爆発を表示
  addEffect('flash', { life: .06 });
  addEffect('megaNova', {
    x, y,
    r: Math.hypot(W / DPR, H / DPR) * 0.85,
    life: 0.9
  });
  for (let k = 0; k < 22; k++) {
    spark(x + (Math.random() - 0.5) * 30, y + (Math.random() - 0.5) * 30, 18);
  }

  // 一定時間“見せる”→ クリア画面
state.winCountdown = 1.2;
state._winLast = performance.now();   // ← カウントの基準時刻を初期化
state.paused = false;                 // ← ポーズ中でも tick が効くが、ここで一旦解除しておくと確実
}


function showGameClear(){
  const el = document.getElementById('gameclear');
  const hardcoreBtn = document.getElementById('hardcoreBtn');
  if (el){
    // クリアで解放
    state.mode.unlockedHardcore = true;

    el.style.display = 'flex';
    state.paused = true;
    
    ensureEndScoreNodes();
updateEndScore('clear');

    // ハードコアボタンを表示
    if (hardcoreBtn){
      hardcoreBtn.style.display = 'inline-block';
      hardcoreBtn.onclick = () => {
        state.mode.hardcore = true;  // 次の周回をハードコアに
        el.style.display = 'none';
        resetGame();
        syncPauseButton();
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.4, text: 'HARDCORE START' });
      };
    }
  }else{
    state.paused = true;
    alert('GAME CLEAR');
  }
}

// === safeKillEnemy: 最終版（finalでCLEARへ） ===
function safeKillEnemy(idxOrEnemy){
  const e = (typeof idxOrEnemy === 'number') ? (state.enemies && state.enemies[idxOrEnemy]) : idxOrEnemy;
  if (!e || e.dead) return;

  try { if (typeof addEffect === 'function') addEffect('pop', { x:e.x, y:e.y }); } catch(_){}

// ---- 統一キルカウント（重複防止）----
if (!e._counted) {
  const isBoss = (e.type === 'mid' || e.type === 'big' || e.type === 'final');
  if (isBoss) {
    state.bossKills = (state.bossKills|0) + 1;
  } else {
    state.kills = (state.kills|0) + 1;
  }
  e._counted = true; // 弾・即死・多経路でも二重加算を防ぐ
}

  if (e.type === 'final') {
    try { finalExplosionAndClear(e.x, e.y); } catch(_){}
    try {
      state.enemies.length = 0;
      if (state.enemyBullets) state.enemyBullets.length = 0;
      if (state.items) state.items.length = 0;
      state.spawnTimer = 9999;
    } catch(_){}
  } else if (e.type === 'big') {
    state.items.push({ kind:'chest', x:e.x, y:e.y, r:16, t:0, picks:2 });
    try { addEffect('text', { x:e.x, y:e.y, life:1.2, text:'宝箱×2！' }); } catch(_){}
  } else if (e.type === 'mid') {
    state.items.push({ kind:'chest', x:e.x, y:e.y, r:14, t:0, picks:1 });
  } else {
    try { dropGem(e.x, e.y, 1); } catch(_){}
  }

  e.dead = true; e.hp = 0;
  try {
    const i = state.enemies ? state.enemies.indexOf(e) : -1;
    if (i >= 0) state.enemies.splice(i, 1);
  } catch(_){}
}




// ---- Heal helpers (robust, single source of truth) ----
function _getPlayer() {
  // どちらかから確実に取る（今後のリファクタでも壊れにくく）
  const ws = (typeof window !== 'undefined' ? window.state : null);
  if (ws && ws.player) return ws.player;
  if (typeof state !== 'undefined' && state && state.player) return state.player;
  return null;
}

// 実数回復（増えた“実量”を返す：0 のときは満タン）
function healPlayer(v){
  const p = _getPlayer();
  if (!p) return 0;
  const maxHp = p.maxHp ?? p.hpMax ?? p.hp_max ?? p.maxHP ?? 100;
  const before = Number.isFinite(p.hp) ? p.hp : maxHp;
  const add    = Math.max(0, Number(v) || 0);
  if (add <= 0) return 0;
  const after  = Math.min(maxHp, before + add);
  p.hp = after;
  const gained = after - before;
  return (Number.isFinite(gained) && gained > 0) ? gained : 0;
}

// 最大HPに対する % 回復（増えた“実量”を返す）
function healPlayerPercent(percent){
  const p = _getPlayer();
  if (!p) return 0;
  const maxHp = p.maxHp ?? p.hpMax ?? p.hp_max ?? p.maxHP ?? 100;
  const pct = Math.max(0, Number(percent) || 0) / 100;
  if (!(pct > 0)) return 0;
  return healPlayer(maxHp * pct);
}

// === NOVA 回復レート ===
function _getNovaLevel(){
  return (state?.weapons?.nova?.lv)
      ?? (state?.wlv?.nova)
      ?? (state?.wepLevel?.nova)
      ?? (state?.wep?.nova?.lv)
      ?? 1; // 見つからなければLV1扱い
}
function _isNovaAwakened(){
  return !!((state?.weapons?.nova?.awakened)
         || (state?.weapons?.nova?.isAwaken)
         || (state?.awaken?.nova)
         || (state?.wep?.nova?.awakened));
}
/** ノヴァの“ヒット時”に使う回復％（整数％を返す） */
function getNovaHitHealPercent(){
  if (_isNovaAwakened()) return 4; // 覚醒：ヒット時は4%
  const lv = _getNovaLevel();
  if (lv >= 3) return 4;  // LV3
  if (lv === 2) return 3; // LV2
  return 2;               // LV1
}


// === Unified final explosion & clear ===
function finalExplosionAndClear(x, y){
  try { addEffect('flash', { life: .06 }); } catch(_){}
  try {
    const W = cv.width, H = cv.height, DPR = window.devicePixelRatio||1;
    addEffect('megaNova', { x, y, r: Math.hypot(W/DPR, H/DPR)*0.85, life: 0.9 });
    for (let k = 0; k < 22; k++) spark(x + (Math.random()-0.5)*30, y + (Math.random()-0.5)*30, 18);
  } catch(_){}

  // === BOSS TIME BONUS（1回だけ） ===
  if (!state._finalBonusAwarded){
    const spawnAt = Number.isFinite(state.finalSpawnAt) ? state.finalSpawnAt : (state.timeSec||0);
    const now     = state.timeSec || 0;
    const took    = Math.max(0, now - spawnAt);

    const MAX_BONUS = 30000; // 最速撃破
    const FULL_TIME = 15;    // ここまで満額
    const ZERO_TIME = 90;    // ここを過ぎると0
    let ratio = 0;
    if (took <= FULL_TIME)       ratio = 1;
    else if (took >= ZERO_TIME)  ratio = 0;
    else                         ratio = (ZERO_TIME - took) / (ZERO_TIME - FULL_TIME);

    const bonus = Math.max(0, Math.round(MAX_BONUS * ratio));
    state.bossBonus = (state.bossBonus|0) + bonus;
    state.score     = (state.score|0)     + bonus;
    state._finalBonusAwarded = true;

    try { addEffect('text', { x, y, life: 1.3, text: `BOSS TIME BONUS +${bonus.toLocaleString()}` }); } catch(_){}
  }

  // 少し見せてからCLEAR
  state.winCountdown = 1.2;
  state._winLast = performance.now?.() || 0;
  state.paused = false;
}

// 旧名で呼ばれても必ず同じ処理に流す
function triggerFinalExplosion(x, y){
  return finalExplosionAndClear(x, y);
}

function gameOver(){
  state.paused = true;
  // ▼ XP回収の残りを強制停止
  state.gather.active = false;
  state.gather.time = 0;
  state.gather.totalXP = 0;
if (gatherEl) gatherEl.style.display='none';
  // ▼ ノックバック＆無敵も停止
  state.player.kbx = state.player.kby = 0;
  state.player.iTime = 0;
  goEl.style.display='flex';
}

// Final Boss spawn
function spawnFinalBoss(){
  const B = worldBounds();         // ← ズーム反映の表示境界
  const margin = 120;
  const side = Math.floor(Math.random()*4);
  let x, y;



  // 画面の四辺「外」から出現させる
  if (side === 0) {        // 上
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.minY - margin;
  } else if (side === 1) { // 右
    x = B.maxX + margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  } else if (side === 2) { // 下
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.maxY + margin;
  } else {                 // 左
    x = B.minX - margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  }

  const base = 1500 + state.difficulty*300;
  const hp0  = base * 10;
  const hp   = state.mode.hardcore ? hp0 * 1.5 : hp0;

  const e = {
    x, y,
    size: 84*2, hp, maxHp: hp, speed: 70, type: 'final',
    phase: 'shoot', cd: 0, tele: 0, dashCD: 5.5, dashDir: {x:0, y:0},
    patternCD: 4.5, blastCharge: 0, blastR: 220, laserAng: 0,
    laserAimT: 0, laserDur: 0, hitFlash: 0,
    kbx: 0, kby: 0
  };

  state.enemies.push(e);
  
  // ★ ボス出現時刻を記録（タイムボーナス計測用）
  state.finalSpawnAt = state.timeSec || 0;
  // ★ その周のボスボーナスをリセット
  state.bossBonus = 0;

  flashBossMsg();
}

  requestAnimationFrame(loop);

})();



</script>


<!-- Floating Joystick -->
<div id="joyBase"></div>
<div id="joyKnob"></div>




</body>

</html>
