<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>VSV-like+ Boss/Items (v4_35)</title>
<style>
  html,body { margin:0; height:100%; background:#0e0e0f; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
#wrap {
  position:relative;
  width:100%;
  height:100dvh;
  overflow:hidden;
  touch-action:none;
  padding-bottom: env(safe-area-inset-bottom);
}

@supports not (height: 100dvh) {
  #wrap { height:100svh; }
}

canvas {
  position:absolute;
  top:0; left:0; right:0; bottom:0;
  width:100%; height:100%;
  display:block;
}
#start { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:50; pointer-events:auto; }
.hud {
  position:absolute; left:0; right:0; top:0;
  display:flex; gap:.75rem; padding:.5rem .75rem;
  align-items:center; pointer-events:none;
  /* ã“ã“ã‹ã‚‰è¿½è¨˜ */
  padding-top: calc(.5rem + env(safe-area-inset-top));
  padding-left: calc(.5rem + env(safe-area-inset-left));
  padding-right: calc(.75rem + env(safe-area-inset-right));
}
  .badge { background:#1a1a1a; border:1px solid #333; border-radius:.5rem; padding:.2rem .5rem; font-weight:600; }
  .bar { flex:1; height:.6rem; background:#1a1a1a; border:1px solid #333; border-radius:.4rem; overflow:hidden; }
  .bar > i { display:block; height:100%; width:0%; background:linear-gradient(90deg,#2ecc71,#27ae60); }
  .xp > i { background:linear-gradient(90deg,#3498db,#2980b9); }
  #levelup, #chest { position:absolute; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:10;}
  #cardRow, #chestRow { display:grid; grid-template-columns:1fr; gap:1rem; width:min(900px,92vw); }
  @media (min-width:720px){ #cardRow, #chestRow{ grid-template-columns:repeat(3,1fr);} }
  @media (min-width:1000px){ #chestRow{ grid-template-columns:repeat(5,1fr);} }
  .card { background:#181818; border:1px solid #333; border-radius:.8rem; padding:1rem; box-shadow:0 4px 18px rgba(0,0,0,.45); cursor:pointer; text-align:left; color:#fff; }
  .card h3 { margin:.2rem 0 .4rem; font-size:1.08rem; color:#fff; }
  .card p { margin:0; color:#e5e5e5; line-height:1.38; font-size:.94rem; }
  .card:hover, .card.sel { outline:2px solid #4aa3ff; }
  .chestHUD { position:absolute; top:2.8rem; left:50%; transform:translateX(-50%); z-index:11; display:none; gap:.5rem; align-items:center; }
  .chestHUD .badge { pointer-events:auto; }
  #hint { position:absolute; right:.5rem; bottom:.5rem; font-size:.8rem; opacity:.7; }
  #joy { position:absolute; left:1rem; bottom:1rem; width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,.04); border:1px solid #333;}
  #joy i { position:absolute; left:50%; top:50%; translate:-50% -50%; width:60px; height:60px; border-radius:50%; background:rgba(255,255,255,.08); border:1px solid #444; }
  #bossmsg { position:absolute; top:40px; left:50%; transform:translateX(-50%); background:#2a1741; border:1px solid #5b2a8a; padding:.3rem .6rem; border-radius:.4rem; display:none; color:#fff; }
  #gather { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.5); z-index:9; }
  #gather .box { background:#151515; border:1px solid #333; border-radius:.8rem; padding:1rem 1.2rem; text-align:center; }
  #gather h3 { margin:.2rem 0 .4rem; }
  /* Start & GameOver overlays */
  #start, #gameover, #gameclear {
  position:absolute; inset:0;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  background:rgba(0,0,0,.7); z-index:20;
}
  #start h1 { font-size: clamp(28px, 6vw, 64px); margin:0 0 .5rem; color:#fff; letter-spacing:.02em; }
  #start p { font-size: clamp(14px, 3vw, 22px); margin:0 0 1rem; opacity:.9;}
  .btn { background:#1f6feb; color:#fff; border:none; padding:.7rem 1.1rem; border-radius:.6rem; font-weight:700; cursor:pointer; box-shadow:0 6px 20px rgba(31,111,235,.35); }
  .btn:hover { filter:brightness(1.05); }
  #gameover h2 { font-size: clamp(24px, 5vw, 44px); margin:.25rem 0 .75rem; }
  #gameover .sub { opacity:.85; margin-bottom:1rem; }
  /* ç¸¦æŒã¡ã®ã¨ãã¯HUDã‚’å°‘ã—ç¸®å° */
@media (orientation:portrait){
  .hud { transform: scale(.9); transform-origin: top center; opacity:.9; }
}

/* ã‹ãªã‚Šç‹­ã„ç«¯æœ«ã§ã¯HUDã‚’éè¡¨ç¤ºï¼ˆå¾Œã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨ã‚Šãƒªãƒ³ã‚°ã§ä»£æ›¿ï¼‰ */
@media (max-width:480px){
  .hud { display:none; }
  /* ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚‚å°ã•ã‚ã« */
  #joy { width:120px; height:120px; left:.7rem; bottom:.7rem; }
  #joy i { width:52px; height:52px; }
}

/* ã•ã‚‰ã«ç‹­ã„å¹…ãªã‚‰HUDã®ç¸®å°ã‚’å¼·ã‚ã‚‹ï¼ˆHUDã‚’ä½¿ã†æ§‹æˆã®ã¾ã¾ãªã‚‰ï¼‰ */
@media (max-width:380px){
  .hud { transform: scale(.8); }
}

.bar.hp.low > i {
  background: linear-gradient(90deg,#ff5a5a,#c0392b);
}

/* æµ®éŠã‚¿ã‚¤ãƒãƒ¼ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éè¡¨ç¤ºï¼‰ */
.time-float{
  position:absolute;
  right: calc(.5rem + env(safe-area-inset-right));
  top:   calc(.5rem + env(safe-area-inset-top));
  z-index: 15;
  pointer-events: none; /* ã‚¿ãƒƒãƒ—ã‚’é‚ªé­”ã—ãªã„ */
  display: none;
  font-weight: 700;
}

/* ç¸¦æŒã¡ or ã‹ãªã‚Šç‹­ã„ç”»é¢ã§ã¯HUDã‚’éš ã—ã€æµ®éŠã‚¿ã‚¤ãƒãƒ¼ã‚’å‡ºã™ */
@media (orientation:portrait){
  .time-float{ display:block; }
}
@media (max-width:480px){
  .hud{ display:none; }      /* æ—¢ã«å…¥ã‚Œã¦ã„ã‚‹è¨­å®šã¨æ•´åˆ */
  .time-float{ display:block; }
}

.hpval {
  min-width: 60px;
  text-align: right;
  font-size: 0.8rem;
  color: #fff;
  opacity: 0.85;
}


</style>
</head>
<body>
<div id="wrap">
  <div id="start" style="display:flex;">
    <h1>10åˆ†ç”Ÿãå»¶ã³ã‚ï¼</h1>
    <p>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§èƒ½åŠ›ã‚’é¸ã³ã€ãƒœã‚¹ã‚’å€’ã—ã¦ç”Ÿå­˜ã‚’ç›®æŒ‡ã›ã€‚</p>
    <button id="startBtn" class="btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
  <div id="gameover" style="display:none;">
    <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
    <div class="sub">ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã‚ˆã†ï¼</div>
    <button id="retryBtn" class="btn">ã‚„ã‚Šç›´ã™</button>
  </div>
    <div id="gameclear" style="display:none;">
    <h2 style="font-size:clamp(28px,6vw,64px); margin:0 0 .75rem;">GAME CLEAR</h2>
    <button id="replayBtn" class="btn">ã‚‚ã†ä¸€åº¦éŠã¶</button>
  </div>
  <canvas id="cv"></canvas>
  <div class="hud">
    <span class="badge">Lv <b id="lv">1</b></span>
    <div class="bar hp"><i id="hpw"></i></div>
    <span id="hpval" class="hpval"></span>   <!-- â˜… è¿½åŠ  -->
    <div class="bar xp"><i id="xpw"></i></div>
    <span class="badge">âŒ› <b id="tm">0:00</b></span>
    <span class="badge">æ­¦å™¨: <b id="wep">-</b></span>
  </div>
  <div id="bossmsg">!! BOSS APPROACHING !!</div>
  <div id="levelup"><div id="cardRow"></div></div>
  <div id="chest"><div id="chestRow"></div></div>
  <div class="chestHUD" id="chestHUD"><span class="badge">å®ç®±ï¼š<b id="pickLeft">2</b>ã¤é¸æŠ</span></div>
  <div id="gather"><div class="box"><h3>çµŒé¨“å€¤ã‚’é›†ã‚ã¦ã„ã¾ã™</h3><div class="bar xp" style="width:260px;margin:auto;"><i id="gbar"></i></div></div></div>
  <div id="joy"><i></i></div>
  <div id="hint">Pause: [P]</div>
</div>

<script>

// ===== ç”»é¢ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
function showErrorBanner(msg){
  let el = document.getElementById('errBanner');
  if(!el){
    el = document.createElement('div');
    el.id = 'errBanner';
    el.style.cssText = 'position:fixed;left:0;right:0;top:0;z-index:99999;background:#b00020;color:#fff;padding:.5rem 1rem;font:14px/1.4 system-ui;white-space:pre-wrap';
    document.body.appendChild(el);
  }
  el.textContent = 'âš  ' + msg;
}
// window.onerror ã§æœªæ•æ‰ã‚¨ãƒ©ãƒ¼ã‚’ãƒãƒŠãƒ¼è¡¨ç¤º
window.onerror = function(message, source, lineno, colno, error){
  showErrorBanner(`${message} @ ${source}:${lineno}:${colno}`);
};
// unhandledrejection ã‚‚æ•ã¾ãˆã‚‹
window.addEventListener('unhandledrejection', e=>{
  showErrorBanner('UnhandledPromiseRejection: ' + (e.reason && (e.reason.stack || e.reason.message || e.reason)));
});

// ===== JavaScript å…¨æ–‡ï¼ˆä¿®æ­£ç‰ˆé©ç”¨æ¸ˆã¿ï¼‰ =====
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let W=0,H=0,DPR=1;
  
  /* â–¼â–¼ ã“ã“ã‹ã‚‰è¿½åŠ ï¼šãƒ“ãƒ¥ãƒ¼ç¸®å°º â–¼â–¼ */
let VIEW_SCALE = 1; // 1=ç­‰å€, 0.92=ã¡ã‚‡ã„å¼•ã ãªã©

function recomputeViewScale(){
  const shortSide = Math.min(window.innerWidth, window.innerHeight);
  const isPortrait = window.matchMedia && window.matchMedia('(orientation: portrait)').matches;

  // ç«¯æœ«ã®çŸ­è¾ºã‚„ç¸¦æŒã¡ã§â€œå°‘ã—å¼•ãâ€
  if (shortSide <= 380) {
    VIEW_SCALE = 0.88;         // ã‹ãªã‚Šå°ã•ã„ç«¯æœ«
  } else if (shortSide <= 480 || isPortrait) {
    VIEW_SCALE = 0.92;         // ä¸€èˆ¬çš„ã‚¹ãƒãƒ›ç¸¦æŒã¡
  } else {
    VIEW_SCALE = 1;            // ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ/æ¨ªæŒã¡ç­‰ã¯ç­‰å€
  }
}
/* â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–² */
  
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const r = cv.getBoundingClientRect();
    W = Math.floor(r.width * DPR);
    H = Math.floor(r.height * DPR);
    cv.width = W; cv.height = H;
    
    // â–¼ è¿½åŠ ï¼šç«¯æœ«æ¡ä»¶ã«å¿œã˜ã¦ç¸®å°ºã‚’æ±ºã‚ã‚‹
  recomputeViewScale();

  // â–¼ å¤‰æ›´ï¼šã‚¹ã‚±ãƒ¼ãƒ«è¾¼ã¿ã§æç”»å¤‰æ›
  ctx.setTransform(DPR * VIEW_SCALE, 0, 0, DPR * VIEW_SCALE, 0, 0);
}
  new ResizeObserver(resize).observe(cv); resize();
  
  window.addEventListener('orientationchange', resize);
window.addEventListener('resize', resize);


  const rnd = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy;}
  const pick=(arr)=>arr[(Math.random()*arr.length)|0];

  const state = {
    t:0, last:performance.now(), paused:true, started:false,
    player:{ x:200, y:200, r:14, speed:170, maxHp:110, hp:110, xp:0, level:1, nextXp: (lv)=> 24 + (lv*lv*6), iTime: 0, // ç„¡æ•µæ®‹ã‚Šæ™‚é–“ï¼ˆç§’ï¼‰
  kbx: 0, kby: 0, // ãƒãƒƒã‚¯ãƒãƒƒã‚¯é€Ÿåº¦ï¼ˆpx/sï¼‰
},
    input:{ vx:0, vy:0, keys:{} , lastDir:{x:1,y:0}},
    enemies:[], bullets:[], enemyBullets:[], gems:[], sparks:[], effects:[], items:[],
    weapons:{}, upgradesTaken:new Set(), owned:new Set(['blaster']),
    spawnTimer:0, difficulty:1, timeSec:0, finalSpawned:false,
    mods:{ sizeMul:1.0, rateMul:1.0, dmgMul:1.0 },
    pickupLv: 0,
    bossTimer: 9999, bigBossTimer: 9999,
        gather:{ active:false, time:0, dur:0.5, totalXP:0 },
    winCountdown: 0,
  };

  // UI
  const lvEl = document.getElementById('lv');
  const hpw = document.getElementById('hpw');
  const hpValEl = document.getElementById('hpval'); // â† è¿½åŠ 
  const xpw = document.getElementById('xpw');
  const tmEl = document.getElementById('tm');
  const tm2El = document.getElementById('tm2'); // â† è¿½åŠ 
  const levelupEl = document.getElementById('levelup');
  const cardRow = document.getElementById('cardRow');
  const wepEl = document.getElementById('wep');
  const bossMsg = document.getElementById('bossmsg');
  const gatherEl = document.getElementById('gather');
  const gbar = document.getElementById('gbar');
  const chestEl = document.getElementById('chest');
  const chestRow = document.getElementById('chestRow');
  const chestHUD = document.getElementById('chestHUD');
  const pickLeftEl = document.getElementById('pickLeft');
  const startEl = document.getElementById('start');
  const startBtn = document.getElementById('startBtn');
  const goEl = document.getElementById('gameover');
  const retryBtn = document.getElementById('retryBtn');
  const clearEl = document.getElementById('gameclear');
const replayBtn = document.getElementById('replayBtn');

// ã‚¯ãƒªãƒƒã‚¯ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆ
replayBtn.onclick = () => { clearEl.style.display='none'; resetGame(); };

// resetGame() ã®æœ€å¾Œã‚ãŸã‚Šã§ã‚¯ãƒªã‚¢ç”»é¢ã‚‚éš ã™
clearEl.style.display = 'none';
  
  async function tryFullscreenAndLandscape(){
  try{
    // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ï¼ˆå¯èƒ½ãªç«¯æœ«ï¼‰
    const el = document.documentElement;
    if (el.requestFullscreen) await el.requestFullscreen();

    // ç”»é¢å›è»¢ãƒ­ãƒƒã‚¯ï¼ˆFullscreenå¾Œã¯æˆåŠŸç‡ãŒä¸ŠãŒã‚‹ï¼‰
    if (screen.orientation && screen.orientation.lock) {
      try { await screen.orientation.lock('landscape'); } catch(e){}
    }
  }catch(e){ /* iOSãªã©ã¯å¤±æ•—ã™ã‚‹ã®ã§é™ã‹ã«ç„¡è¦– */ }
}

startBtn.onclick = async () => {
  await tryFullscreenAndLandscape();  // â† è¿½åŠ 
  state.started = true; state.paused = false;
  startEl.style.display='none'; state.last = performance.now();
};
  

  retryBtn.onclick = () => { resetGame(); };



  function resetGame(){
    // Clear arrays
    state.enemies.length=0; state.bullets.length=0; state.enemyBullets.length=0;
    state.gems.length=0; state.sparks.length=0; state.effects.length=0; state.items.length=0;
    // Reset player
    state.player.x = (cv.width / DPR) / 2;
    state.player.y = (cv.height / DPR) / 2;
    state.player.r = 14;
    state.player.speed = 170;
    state.player.maxHp = 110;
    state.player.hp = 110;
    state.player.xp = 0;
    state.player.level = 1;
    state.player.iTime = 0;
state.player.kbx = 0;
state.player.kby = 0;
state.pickupLv = 0;
    // Reset meta
    state.mods.sizeMul = 1.0;
    state.spawnTimer = 0;
    state.difficulty = 1;
    state.timeSec = 0;
    state.finalSpawned = false;
    state.bossTimer = 9999;
    state.bigBossTimer = 9999;
    state.gather.active = false; state.gather.time = 0; state.gather.totalXP = 0;
      state.winCountdown = 0;

    // Reset upgrades
    state.upgradesTaken = new Set();
    state.owned = new Set(['blaster']);
    // Reset weapons
    for(const k in state.weapons){
      const w = state.weapons[k];
      w.lv = (k==='blaster')? 1 : 0;
      w.awaken = false;
      if('cd' in w) w.cd = 0;
      if(k==='orbit'){ w.ang = 0; }
    }
    // UI
    levelupEl.style.display='none';
    chestEl.style.display='none';
    chestHUD.style.display='none';
    gatherEl.style.display='none';
    goEl.style.display='none';
    state.started = true;
    state.paused = false;
    state.last = performance.now();
    clearEl.style.display='none';

  }

function updateHUD(){
  lvEl.textContent = state.player.level;

  hpw.style.width = (100*state.player.hp/state.player.maxHp)+'%';
    // â˜… HPæ•°å€¤ã®æ›´æ–°
  if (hpValEl) {
    hpValEl.textContent = `${Math.max(0, Math.floor(state.player.hp))} / ${state.player.maxHp}`;
  }
  
  xpw.style.width = (100*state.player.xp/state.player.nextXp(state.player.level))+'%';

  const m = Math.floor(state.timeSec/60), s = (state.timeSec%60)|0;
  const txt = `${m}:${String(s).padStart(2,'0')}`;
  tmEl.textContent = txt;
  if (tm2El) tm2El.textContent = txt; // â† è¿½åŠ ï¼ˆæµ®éŠã‚¿ã‚¤ãƒãƒ¼ã«ã‚‚åæ˜ ï¼‰

  const names = Object.entries(state.weapons)
    .filter(([k,w])=>w.lv>0)
    .map(([k,w])=> `${w.short}${w.lv}${w.awaken?'â˜…':''}`);
  wepEl.textContent = names.join(', ') || '-';
}


  // Joystick + keyboard
  const joy = document.getElementById('joy');
  const knob = joy.querySelector('i');
  let joyId = null, joyCenter=null;
  function setJoy(dx,dy){
    const mag = Math.hypot(dx,dy);
    const max = 55;
    const nx = (mag>0?dx/mag:0), ny=(mag>0?dy/mag:0);
    const r = Math.min(max, mag);
    knob.style.left = (70 + nx*r) + 'px';
    knob.style.top  = (70 + ny*r) + 'px';
    state.input.vx = nx; state.input.vy = ny;
    if(mag>6){ state.input.lastDir = {x:nx, y:ny}; }
  }
  function resetJoy(){ knob.style.left='50%'; knob.style.top='50%'; state.input.vx=0; state.input.vy=0;}
  joy.addEventListener('touchstart', e=>{
    const t = e.changedTouches[0]; joyId = t.identifier;
    const r = joy.getBoundingClientRect();
    joyCenter = { x:r.left + r.width/2, y:r.top + r.height/2 };
    setJoy(t.clientX - joyCenter.x, t.clientY - joyCenter.y);
  }, {passive:false});
  joy.addEventListener('touchmove', e=>{
    for(const t of e.changedTouches){
      if (t.identifier===joyId) { setJoy(t.clientX - joyCenter.x, t.clientY - joyCenter.y); e.preventDefault(); }
    }
  }, {passive:false});
  joy.addEventListener('touchend', e=>{
    for(const t of e.changedTouches){ if (t.identifier===joyId){ joyId=null; resetJoy(); } }
  });
  document.getElementById('wrap').addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
  window.addEventListener('keydown', e=>{ if(e.key==='p'||e.key==='P'){ state.paused=!state.paused; } state.input.keys[e.key]=true; });
  window.addEventListener('keyup', e=>{ state.input.keys[e.key]=false; });
  function keyboardVec(){
    const k = state.input.keys; let x=0,y=0;
    if(k['ArrowLeft']||k['a']) x-=1; if(k['ArrowRight']||k['d']) x+=1;
    if(k['ArrowUp']||k['w']) y-=1; if(k['ArrowDown']||k['s']) y+=1;
    const m=Math.hypot(x,y)||1; return {x:x/m,y:y/m};
  }

  // Spawns
  function spawnEnemy(){
    const margin = 30;
    const side = Math.floor(Math.random()*4);
    let x,y;
    if(side===0){ x=rnd(-margin,0); y=rnd(0,H/DPR); }
    else if(side===1){ x=rnd(W/DPR,W/DPR+margin); y=rnd(0,H/DPR); }
    else if(side===2){ x=rnd(0,W/DPR); y=rnd(-margin,0); }
    else { x=rnd(0,W/DPR); y=rnd(H/DPR,H/DPR+margin); }
    const shooterProb = state.timeSec>120 ? 0.05 : 0.0;
    if(Math.random()<shooterProb){
      const hp = (20 + state.difficulty*2.5) * 1.5;
      const cx = (W/DPR)/2, cy = (H/DPR)/2;
      const dx = cx - x, dy = cy - y; const m = Math.hypot(dx,dy)||1;
      const dir = {x:dx/m, y:dy/m};
      state.enemies.push({ x,y, size:20, hp, maxHp:hp, type:'shooter', phase:'move', dir, moved:0, moveDist: rnd(240, 360), moveSpeed: 120, cd: rnd(0.2,0.8), hitFlash:0 });
}else{
  let hp = 16 + state.difficulty*2.2;
  if(state.timeSec>=360){ hp *= 2.0; }

  // â˜… é€Ÿåº¦æˆé•·ã®ä¸Šé™ã‚’å°å…¥
  const dForSpeed = Math.min(state.difficulty, 16); // â† ä¸Šé™ï¼ˆä¾‹ï¼š16ï¼‰
  const sp = 30 + dForSpeed*4.5;                   // â† ä¼¸ã³ç‡ã‚‚å°‘ã—æŠ‘ãˆã‚‹

  state.enemies.push({ x,y, size:18, hp, maxHp:hp, speed:sp, type:'minion', hitFlash:0 });
}
  }

function spawnMidBoss(){
  const margin = 80;
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x=rnd(-margin,0); y=rnd(0,H/DPR); }
  else if(side===1){ x=rnd(W/DPR,W/DPR+margin); y=rnd(0,H/DPR); }
  else if(side===2){ x=rnd(0,W/DPR); y=rnd(-margin,0); }
  else { x=rnd(0,W/DPR); y=rnd(H/DPR,H/DPR+margin); }

  let hp = 420 + state.difficulty*120;
  if(state.timeSec>=360){ hp *= 1.6; }
  const e = { x,y, size:48, hp, maxHp:hp, speed:80, type:'mid', cd:0, hitFlash:0 };
  state.enemies.push(e);
  flashBossMsg();
}

function spawnBigBoss(){
  const margin = 100;
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x=rnd(-margin,0); y=rnd(0,H/DPR); }
  else if(side===1){ x=rnd(W/DPR,W/DPR+margin); y=rnd(0,H/DPR); }
  else if(side===2){ x=rnd(0,W/DPR); y=rnd(-margin,0); }
  else { x=rnd(0,W/DPR); y=rnd(H/DPR,H/DPR+margin); }

  let hp = 900 + state.difficulty*240;
  if(state.timeSec>=360){ hp *= 1.6; }
  const e = { x,y, size:70, hp, maxHp:hp, speed:95, type:'big', cd:0, phase:'shoot',
              tele:0, dashCD:6, dashDir:{x:0,y:0}, hitFlash:0 };
  state.enemies.push(e);
  flashBossMsg();
}

  function flashBossMsg(){ bossMsg.style.display='block'; setTimeout(()=>bossMsg.style.display='none',1500); }

  // XP & particles
  function dropGem(x,y,val=1){ state.gems.push({x,y,r:5+val, val}); }
  function spark(x,y,cnt=8){
    for(let i=0;i<cnt;i++){
      const a=rnd(0,Math.PI*2), v=rnd(40,160);
      state.sparks.push({x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, t:0, life:.4});
    }
  }
  
  function playerHit(dmg, sx, sy){
  // ã™ã§ã«ç„¡æ•µãªã‚‰ç„¡è¦–
  if (state.player.iTime > 0) return;

  state.player.hp -= dmg;
  state.player.iTime = 1.0; // ç„¡æ•µ1.0ç§’

  // ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼šè¢«å¼¾å…ƒâ†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€†æ–¹å‘ã¸
  const dx = state.player.x - sx;
  const dy = state.player.y - sy;
  const m = Math.hypot(dx, dy) || 1;
  const kb = 360; // åˆé€Ÿ(px/s) å°ã•ã‚ãƒãƒƒã‚¯ãƒãƒƒã‚¯
  state.player.kbx = (dx / m) * kb;
  state.player.kby = (dy / m) * kb;

  // ã¡ã‚‡ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
  addEffect('flash', { life: .03 });

  if (state.player.hp <= 0) {
    gameOver();
  }
}

  
function addEffect(type, data){
  state.effects.push({ type, ...data });
}
  // Items
  function spawnItemRandom(){
    const chance = 0.03;
    if(Math.random()<chance){
      const roll = Math.random();
      const kind = roll < 0.45 ? 'magnet' : roll < 0.75 ? 'nuke' : 'heal';
      state.items.push({ kind, x:rnd(30,W/DPR-30), y:rnd(30,H/DPR-30), r:12, t:0 });
    }
  }
  function applyItem(it){
    if(it.kind==='magnet'){
      let gained = 0; for(const g of state.gems){ gained += g.val*5; }
      state.gems.length = 0;
      state.gather.active = true; state.gather.time = 0; state.gather.totalXP = gained;
      state.paused = true; gatherEl.style.display='flex';
    }else if(it.kind==='nuke'){
  let killed=0;
  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    // âœ… æ®²æ»…ã¯é›‘é­šã®ã¿ï¼ˆfinal/mid/big ã¯é™¤å¤–ï¼‰
    if (e.type === 'minion' || e.type === 'shooter') {
      dropGem(e.x, e.y, 2);
      spark(e.x, e.y, 16);
      state.enemies.splice(i, 1);
      killed++;
    }
  }
  addEffect('text', { x: state.player.x, y: state.player.y, life: 1.2, text: `ä¸€æƒ(${killed})` });
}else if(it.kind==='heal'){
      const amount = Math.round(state.player.maxHp * 0.35);
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + amount);
      addEffect('text',{x:state.player.x,y:state.player.y,life:1.2,text:`å›å¾© +${amount}`});
    }else if(it.kind==='chest'){
      openChest(it.picks||2);
    }
  }

  // ==== ä¿®æ­£ç‰ˆ openChest ====
  function openChest(pickCount=2){
    state.paused = true;
    chestEl.style.display='flex'; chestHUD.style.display='flex';
    let picksLeft = pickCount; pickLeftEl.textContent = picksLeft;
    chestRow.innerHTML='';
    const pool = ALL_UPGRADES.filter(u=>u.can());
    const choices=[];
    while(choices.length<5 && pool.length){
      const i=(Math.random()*pool.length)|0; choices.push(pool.splice(i,1)[0]);
    }
    const chosen = new Set();
    for(const u of choices){
      const c = document.createElement('button'); c.className='card';
      c.innerHTML = `<h3>${u.name}</h3><p>${u.desc||''}</p>`;
      c.onclick = () => {
        if(picksLeft<=0 || chosen.has(u)) return;
        chosen.add(u); c.classList.add('sel'); u.apply();
        picksLeft--; pickLeftEl.textContent = picksLeft;
        if(picksLeft===0){
          state.paused = false;
          chestEl.style.display='none'; chestHUD.style.display='none';
          chestRow.innerHTML='';
        }
      };
      chestRow.appendChild(c);
    }
    const first = chestRow.querySelector('.card'); if(first) first.focus();
  }

function addXP(v){
  v = Math.round(v * xpMulByTime()); // â˜… ä¿‚æ•°é©ç”¨
  state.player.xp += v;
  while(state.player.xp >= state.player.nextXp(state.player.level)){
    state.player.xp -= state.player.nextXp(state.player.level);
    state.player.level++;
    if(state.player.level===3){
      state.bossTimer = 60 + Math.random()*20;
      state.bigBossTimer = 140 + Math.random()*30;
    }
    offerUpgrades();
  }
}


  // ==== ä¿®æ­£ç‰ˆ offerUpgrades ====
  function offerUpgrades(){
    const pool = ALL_UPGRADES.filter(u => u.can());
    const choices = [];
    while (choices.length < 3 && pool.length) {
      const i = (Math.random() * pool.length) | 0;
      choices.push(pool.splice(i, 1)[0]);
    }
    showLevelUp(choices);
  }

function xpMulByTime(){
  if(state.timeSec < 360) return 1.0;              // ã€œ6:00 ã¯ç­‰å€
  const t = Math.min(1, (state.timeSec - 360) / 240); // 6:00â†’10:00 ã® 240ç§’ã§æ®µéšä¸Šã’
  return 1.0 + t * 0.8;                            // 10:00ã§æœ€å¤§1.8å€ï¼ˆä¾‹ï¼‰
}

  // ==== ä¿®æ­£ç‰ˆ showLevelUp ====
function showLevelUp(choices){
  state.paused = true;
  levelupEl.style.display = 'flex';
  cardRow.innerHTML = '';

  for (const u of choices) {
    const c = document.createElement('button');
    c.className = 'card';                        // â† openChest ã¨åŒã˜
    c.innerHTML = `<h3>${u.name}</h3><p>${u.desc || ''}</p>`;
    c.onclick = () => {
      u.apply();
      state.paused = false;
      levelupEl.style.display = 'none';
      cardRow.innerHTML = '';
    };
    cardRow.appendChild(c);
  }

  const first = cardRow.querySelector('.card');  // â† æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
  if (first) first.focus();
}
  // === Weapons with Awaken ===
  const weapons = {
    blaster:{ short:'BL', name:'ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼', lv:1, awaken:false, cd:0, baseRate:.48, baseDmg:10, baseSpeed:360,
      update(dt){
        if(this.lv<=0) return;
        this.cd-=dt; if(this.cd>0) return;
        const target = nearestEnemy(state.player.x,state.player.y); if(!target) return;
        const dmg = (this.baseDmg + 3*(this.lv-1)) * (this.awaken? 1.2:1);
        const rate = this.awaken ? 0.05 : Math.max(.05, this.baseRate * (1 - 0.22*(this.lv-1)));
        const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const off = 6;
        let positions;
        if(this.lv>=3){ positions = [0, -off, off]; }
        else if(this.lv>=2){ positions = [-off, off]; }
        else { positions = [0]; }
        for(const o of positions){
          state.bullets.push({ type:'bullet', x:state.player.x + nx*o, y:state.player.y + ny*o,
            vx:Math.cos(ang)*this.baseSpeed, vy:Math.sin(ang)*this.baseSpeed,
            r:5*state.mods.sizeMul, dmg: dmg*state.mods.dmgMul, life:2 });
        }
        this.cd = rate * state.mods.rateMul;
      }
    },
    shotgun:{ short:'SG', name:'ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³', lv:0, awaken:false, cd:0, baseRate:1.2, baseDmg:10, baseSpeed:340,
      update(dt){
        if(this.lv<=0) return;
        this.cd-=dt; if(this.cd>0) return;
        const target = nearestEnemy(state.player.x,state.player.y); if(!target) return;
        const count = 4 + (this.lv-1)*2;
        const spread = 0.6 - 0.1*(this.lv-1);
        for(let i=0;i<count;i++){
          const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x) + rnd(-spread,spread);
          state.bullets.push({ type:'bullet', x:state.player.x, y:state.player.y,
            vx:Math.cos(ang)*this.baseSpeed, vy:Math.sin(ang)*this.baseSpeed,
            r:4*state.mods.sizeMul, dmg:(this.baseDmg + 2*(this.lv-1)) * state.mods.dmgMul, life:1.2 });
        }
        if(this.awaken){
          const n = 24;
          for(let k=0;k<n;k++){
            const ang = (Math.PI*2*k)/n;
            state.bullets.push({ type:'bullet', x:state.player.x, y:state.player.y,
              vx:Math.cos(ang)*this.baseSpeed*0.9, vy:Math.sin(ang)*this.baseSpeed*0.9,
              r:4*state.mods.sizeMul, dmg:this.baseDmg*state.mods.dmgMul, life:0.8 });
          }
        }
        this.cd = Math.max(.45, this.baseRate * (1 - 0.15*(this.lv-1))) * (this.awaken? 0.8:1) * state.mods.rateMul;
      }
    },
    homing:{ short:'HM', name:'ãƒ›ãƒ¼ãƒŸãƒ³ã‚°', lv:0, awaken:false, cd:0, baseRate:2.4, baseDmg:16,
      update(dt){
        if(this.lv<=0) return;
        this.cd-=dt; if(this.cd>0) return;
        const count = (2 + (this.lv-1)) * (this.awaken? 1.5:1);
        for(let i=0;i<Math.ceil(count);i++){
          const ang = Math.random()*Math.PI*2;
          const power = this.baseDmg * (this.awaken? 1.4:1);
          const life = this.awaken ? 6.0 : 8.0;
          state.bullets.push({ type:'homing', x:state.player.x, y:state.player.y,
            vx:Math.cos(ang)*170, vy:Math.sin(ang)*170,
            r:6*state.mods.sizeMul, dmg:power*state.mods.dmgMul, life:life,
            seek:400, turn:7.2, bigBoom:this.awaken });
        }
        this.cd = Math.max(1.2, this.baseRate * (1 - 0.2*(this.lv-1))) * (this.awaken? 0.85:1) * state.mods.rateMul;
      }
    },
lightning:{ short:'LT', name:'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', lv:0, awaken:false, cd:0, baseRate:2.2, baseDmg:30,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    // â˜…Lvã§æœ¬æ•°å¢—ï¼è¦šé†’ã¯å¸¸ã«7ç™º
    let count = this.awaken ? 7 : Math.max(1, this.lv); // Lv1=1, Lv2=2, Lv3=3

    const targets = pickMultiple(state.enemies, count);
    if(!targets.length) return;
    for(const e of targets){
      strikeLightning(e, 1 + 0.25*(this.lv-1));
    }

    this.cd = Math.max(0.8, this.baseRate * (1 - 0.22*(this.lv-1))) * (this.awaken? 0.65:0.9) * state.mods.rateMul;
  }
},

    rock:{ short:'RK', name:'ãƒ­ãƒƒã‚¯', lv:0, awaken:false, cd:0, baseRate:1.0,
      update(dt){
        if(this.lv<=0) return;
        this.cd -= dt; if(this.cd>0) return;
        const activeRocks = state.bullets.filter(b=>b.type==='rock').length;
        if(activeRocks>0) return;
        let dir = state.input.lastDir;
        if(Math.hypot(dir.x,dir.y) < 0.1){
          const t = nearestEnemy(state.player.x,state.player.y);
          if(t){ const a = Math.atan2(t.y-state.player.y, t.x-state.player.x); dir = {x:Math.cos(a), y:Math.sin(a)}; } else { dir={x:1,y:0}; }
        }
        const sizeBase = (22 + (this.lv-1)*8) * state.mods.sizeMul; // â† å°‘ã—å¤§ãã‚ã«
        const speed = 150;
        const dmg = (18 + 6*(this.lv-1)) * state.mods.dmgMul;
const addRock=(ang)=>{
  const sz = sizeBase * (this.awaken ? 2.0 : 1.0); // â† è¦šé†’ã§2å€
  state.bullets.push({ type:'rock', x:state.player.x, y:state.player.y,
    vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed, r:sz, dmg, life:3.2, pierce:true, spin:0 });
};
        const base = Math.atan2(dir.y,dir.x);
        if(this.awaken){
          const spread = Math.PI * 2 / 3;
          addRock(base); addRock(base + spread); addRock(base - spread);
        }else{ addRock(base); }
        this.cd = Math.max(0.9, this.baseRate * (1 - 0.10*(this.lv-1))) * (this.awaken? 1.25:1);
      }
    },
    orbit:{ short:'OR', name:'ã‚ªãƒ¼ãƒ“ãƒƒãƒˆ', lv:0, awaken:false, count:0, baseR:72, dmg:7, ang:0,
      update(dt){ if(this.lv<=0) return; this.ang += dt*(this.awaken? 3.4:1.6); }
    },
    
ghost:{
  short:'GH', name:'ã‚´ãƒ¼ã‚¹ãƒˆ', lv:0, awaken:false,
  cd:0, baseRate:1.10, ang:0,   // â† angã‚’æŒãŸã›ã¦å›è»¢ç®¡ç†
  update(dt){
    if(this.lv<=0) return;

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’1å›ã ã‘æ¸›ç®—
    this.cd -= dt;

    // ã‚´ãƒ¼ã‚¹ãƒˆæ•° & å›è»¢
    const count = this.awaken ? 6 : this.lv; // Lv1=1, Lv2=2, Lv3=3 / è¦šé†’=6
    this.ang += dt * (this.awaken ? 1.6 : 1.0);

    // ç™ºå°„ãƒˆãƒªã‚¬
    if(this.cd <= 0){
      // â–¶ ç™ºå°„é–“éš”ï¼šçŸ­ç¸®ï¼†ãƒ¬ãƒ™ãƒ«ã§ã•ã‚‰ã«çŸ­ç¸®ã€è¦šé†’ã§å°‘ã—æ—©ã‚
      this.cd = Math.max(0.42, this.baseRate * (1 - 0.18*(this.lv-1))) * (this.awaken ? 0.85 : 1.0) * state.mods.rateMul;

      for(let k=0;k<count;k++){
        const a = this.ang + k * (Math.PI*2/count);
        const r = 60 + 10*(this.lv-1);
        const gx = state.player.x + Math.cos(a)*r;
        const gy = state.player.y + Math.sin(a)*r;

        const t = nearestEnemy(gx, gy);
        if(!t) continue;

        const base = Math.atan2(t.y-gy, t.x-gx);
        const spread = 0.18; // 3ç™ºã®æ‹¡æ•£
        for(const off of [0, -spread, spread]){
          state.bullets.push({
            type:'ghost',             // â† åŒºåˆ¥ã§ãã‚‹ã‚ˆã†å¤‰æ›´
            x:gx, y:gy,
            vx:Math.cos(base+off)*360,
            vy:Math.sin(base+off)*360,
            r:6*state.mods.sizeMul,   // â† å°‘ã—å¤§ãã‚
            dmg:(10 + 4*(this.lv-1)) * (this.awaken ? 1.2 : 1.0) * state.mods.dmgMul,
            life:1.5,
            pierce:3                  // â† è²«é€šå›æ•°3
          });
        }
      }
    }
    // ã‚´ãƒ¼ã‚¹ãƒˆã®è¦‹ãŸç›®ã¯ draw() å´ã§OKï¼ˆåŠé€æ˜ã®éœŠä½“ãªã©ï¼‰
  }
},


    
    
    nova:{ short:'NV', name:'ãƒãƒ´ã‚¡', lv:0, awaken:false, cd:0, baseRate:3.2, baseDmg:22, baseR:96, auraT:0,
      update(dt){
        if(this.lv<=0) return;
        this.cd -= dt; if(this.cd<=0){
          const R = (this.baseR + 18*(this.lv-1)) * state.mods.sizeMul;
          const dmg = (this.baseDmg + 6*(this.lv-1)) * state.mods.dmgMul;
          addEffect('nova',{x:state.player.x,y:state.player.y,r:R, life:.25});
          for(const e of state.enemies){
            const d = Math.hypot(e.x-state.player.x, e.y-state.player.y);
            if(d<R) { e.hp -= dmg; e.hitFlash = Math.max(e.hitFlash, 0.12); }
          }
          this.cd = Math.max(1.6, this.baseRate * (1 - 0.18*(this.lv-1))) * 0.4;
                  }
        if(this.awaken){
          this.auraT += dt;
          const R2 = (110 + 20*(this.lv-1)) * state.mods.sizeMul;
          addEffect('aura',{x:state.player.x,y:state.player.y,r:R2, life:.06});
          for(const e of state.enemies){
            const d = Math.hypot(e.x-state.player.x, e.y-state.player.y);
            if(d<R2){ e.hp -= (14 + 3*(this.lv-1)) * state.mods.dmgMul * dt; e.hitFlash = Math.max(e.hitFlash, 0.05); }
          }
        }
      }
    }
  };
  state.weapons = weapons;


  function strikeLightning(e, mult){
    e.hp -= weapons.lightning.baseDmg*mult*state.mods.dmgMul;
    e.hitFlash = Math.max(e.hitFlash, 0.18);
    const path = buildZigPath(e.x, e.y, 8);
    addEffect('zig',{path, life:.22, thick: 6 * state.mods.sizeMul});
    addEffect('flash',{life:.04}); spark(e.x,e.y,18);
  }

  function nearestEnemy(x,y){
    let best=null, bestD=1e9;
    for(const e of state.enemies){
      const d=dist2(x,y,e.x,e.y);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  function pickMultiple(arr, n){
    const copy = arr.slice(); const out=[];
    for(let i=0;i<n && copy.length;i++){ out.push(copy.splice((Math.random()*copy.length)|0,1)[0]); }
    return out;
  }

  function buildZigPath(x2,y2,segments){
    const x1 = x2; const y1 = -30;
    const pts=[[x1,y1]];
    for(let i=1;i<=segments;i++){
      const t=i/segments;
      const nx = x1 + (x2-x1)*t + rnd(-18,18);
      const ny = y1 + (y2-y1)*t + rnd(-8,18);
      pts.push([nx,ny]);
    }
    return pts;
  }


// ===== ä¸Šé™ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆUå®šç¾©ã®å‰ã«ç½®ãï¼‰=====
const CAPS = {
  speedMax: 320,   // player.speed ä¸Šé™ï¼ˆåˆæœŸ170ï¼‰
  hpMax: 350,      // æœ€å¤§HPä¸Šé™ï¼ˆåˆæœŸ110ï¼‰
  dmgMulMax: 3.0,  // ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ä¸Šé™ï¼ˆåˆæœŸ1.0ï¼‰
  rateMulMin: 0.45,// æ”»æ’ƒé–“éš”å€ç‡ã®ä¸‹é™ï¼ˆå°ã•ã„ã»ã©é€Ÿã„ï¼åˆæœŸ1.0ï¼‰
  sizeMulMax: 2.2  // ã‚µã‚¤ã‚ºå€ç‡ä¸Šé™ï¼ˆåˆæœŸ1.0ï¼‰
};


// ===== Uï¼ˆä¸Šé™ä»˜ãã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å®šç¾©ï¼‰=====
const U = {
  weaponAdd: (key) => ({
    id: `add:${key}`,
    name: `æ–°æ­¦å™¨: ${weapons[key].name}`,
    desc: 'å…¥æ‰‹ï¼ˆæœ€å¤§Lv3ã¾ã§å¼·åŒ–å¯èƒ½ï¼‰',
    can: () => weapons[key].lv === 0,
    apply: () => { weapons[key].lv = 1; state.owned.add(key); }
  }),

  weaponUp: (key) => ({
    id: `up:${key}`,
    name: `${weapons[key].name}å¼·åŒ–`,
    desc: 'æ­¦å™¨ãƒ¬ãƒ™ãƒ«+1ï¼ˆæœ€å¤§Lv3ï¼‰',
    can: () => weapons[key].lv > 0 && weapons[key].lv < 3,
    apply: () => { weapons[key].lv++; }
  }),

  weaponAwaken: (key) => ({
    id: `aw:${key}`,
    name: `${weapons[key].name} è¦šé†’`,
    desc: 'ç‰¹åˆ¥ãªæ€§èƒ½ã‚’è§£æ”¾ï¼',
    can: () => weapons[key].lv === 3 && !weapons[key].awaken,
    apply: () => { weapons[key].awaken = true; }
  }),

  // ---- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç³»ï¼ˆä¸Šé™ä»˜ãï¼‰ ----
  speed: {
    id: 'speed+',
    name: 'ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—',
    desc: '+15%ç§»å‹•é€Ÿåº¦ï¼ˆä¸Šé™ã‚ã‚Šï¼‰',
    can: () => state.player.speed < CAPS.speedMax - 1,
    apply: () => {
      const before = state.player.speed;
      state.player.speed = Math.min(CAPS.speedMax, state.player.speed * 1.15);
      if (state.player.speed === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  maxhp: {
    id: 'maxhp+',
    name: 'æœ€å¤§HPã‚¢ãƒƒãƒ—',
    desc: '+15%æœ€å¤§HPï¼ˆä¸Šé™ã‚ã‚Šï¼‰',
    can: () => state.player.maxHp < CAPS.hpMax - 1,
    apply: () => {
      const before = state.player.maxHp;
      state.player.maxHp = Math.min(CAPS.hpMax, Math.round(state.player.maxHp * 1.15));
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + Math.round(state.player.maxHp * 0.15));
      if (state.player.maxHp === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  regen: {
    id: 'regen',
    name: 'è‡ªç„¶å›å¾©',
    desc: 'æ¯ç§’ æœ€å¤§HPã®0.8% å›å¾©ï¼ˆ1å›ãã‚Šï¼‰',
    can: () => !state.upgradesTaken.has('regen'),
    apply: () => {
      state.upgradesTaken.add('regen');
      addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ãƒªã‚¸ã‚§ãƒ+' });
    }
  },

  pickup: {
    id: 'pickup+',
    name: 'å¸å¼•ç¯„å›²ã‚¢ãƒƒãƒ—',
    desc: 'çµŒé¨“å€¤å¸å¼•ç¯„å›²ã‚¢ãƒƒãƒ—ï¼ˆLv3ã§å…¨åŸŸï¼‰',
    can: () => state.pickupLv < 3,
    apply: () => { state.pickupLv++; }
  },

  atkRate: {
    id: 'rate+',
    name: 'æ”»æ’ƒé€Ÿåº¦ã‚¢ãƒƒãƒ—',
    desc: 'ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ -12%ï¼ˆä¸‹é™ã‚ã‚Šï¼‰',
    can: () => state.mods.rateMul > CAPS.rateMulMin + 1e-6,
    apply: () => {
      state.mods.rateMul = Math.max(CAPS.rateMulMin, state.mods.rateMul * 0.88);
      if (state.mods.rateMul === CAPS.rateMulMin) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'æœ€é€Ÿ!' });
      }
    }
  },

  atkDmg: {
    id: 'dmg+',
    name: 'ä¸ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¢ãƒƒãƒ—',
    desc: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ +15%ï¼ˆä¸Šé™ã‚ã‚Šï¼‰',
    can: () => state.mods.dmgMul < CAPS.dmgMulMax - 1e-6,
    apply: () => {
      const before = state.mods.dmgMul;
      state.mods.dmgMul = Math.min(CAPS.dmgMulMax, state.mods.dmgMul * 1.15);
      if (state.mods.dmgMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  sizeUp: {
    id: 'size+',
    name: 'å¼¾ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—',
    desc: 'å¼¾ãƒ»ç¯„å›² +12%ï¼ˆä¸Šé™ã‚ã‚Šï¼‰',
    can: () => state.mods.sizeMul < CAPS.sizeMulMax - 1e-6,
    apply: () => {
      const before = state.mods.sizeMul;
      state.mods.sizeMul = Math.min(CAPS.sizeMulMax, state.mods.sizeMul * 1.12);
      if (state.mods.sizeMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },
};

// ===== ã“ã“ã‹ã‚‰é¸æŠè‚¢ãƒªã‚¹ãƒˆ =====
const ALL_UPGRADES = [
  U.weaponAdd('shotgun'),   U.weaponUp('shotgun'),   U.weaponAwaken('shotgun'),
  U.weaponAdd('orbit'),     U.weaponUp('orbit'),     U.weaponAwaken('orbit'),
  U.weaponAdd('lightning'), U.weaponUp('lightning'), U.weaponAwaken('lightning'),
  U.weaponAdd('nova'),      U.weaponUp('nova'),      U.weaponAwaken('nova'),
  U.weaponAdd('rock'),      U.weaponUp('rock'),      U.weaponAwaken('rock'),
  U.weaponAdd('homing'),    U.weaponUp('homing'),    U.weaponAwaken('homing'),
  U.weaponAdd('ghost'),     U.weaponUp('ghost'),     U.weaponAwaken('ghost'),
  U.weaponUp('blaster'),    U.weaponAwaken('blaster'), // æ—¢å­˜æ­¦å™¨ã®å¼·åŒ–/è¦šé†’
  U.speed, U.maxhp, U.regen, U.pickup, U.atkRate, U.atkDmg, U.sizeUp
];

// ==== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ====
function loop(now){

  try {
    const dt = clamp((now - state.last)/1000, 0, 0.033*2);
    state.last = now;

    // Magnet animation
    if(state.gather.active){
      state.gather.time += dt;
      const p = Math.min(1, state.gather.time / state.gather.dur);
      gbar.style.width = (p*100)+'%';
      if(p>=1){
        state.gather.active=false; 
        gatherEl.style.display='none';
        addXP(state.gather.totalXP);
        const lvlOpen = (levelupEl.style.display === 'flex');
        const chestOpen = (chestEl.style.display === 'flex');
        state.paused = (lvlOpen || chestOpen) ? true : false;
      }
      draw(); requestAnimationFrame(loop); return;
    }

    if(state.paused){ draw(); requestAnimationFrame(loop); return; }

    state.t += dt; 
    state.timeSec += dt;
    
    // Final Boss spawn
    if (!state.finalSpawned && state.timeSec >= 600) {
      spawnFinalBoss();
      state.finalSpawned = true;
    }
    
    state.difficulty = 1 + Math.floor(state.timeSec/20);

    // Boss timers
    if(state.player.level>=3){
      state.bossTimer -= dt; 
      state.bigBossTimer -= dt;
      if(state.bossTimer<=0){
        spawnMidBoss();
        state.bossTimer = (state.timeSec>=360 ? 40 + Math.random()*15 : 60 + Math.random()*20);
      }
      if(state.bigBossTimer<=0){
        spawnBigBoss();
        state.bigBossTimer = (state.timeSec>=360 ? 100 + Math.random()*25 : 140 + Math.random()*30);
      }
    }

    // input
    let vx=state.input.vx, vy=state.input.vy;
    if(!joyId){ const kv = keyboardVec(); vx=kv.x; vy=kv.y; }
    const pm = Math.hypot(vx,vy)||0; 
    if(pm>0){ vx/=pm; vy/=pm; state.input.lastDir={x:vx,y:vy}; }

    // regen
    if (state.upgradesTaken.has('regen')) {
      const healPerSec = state.player.maxHp * 0.008; // 0.8%/sec
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + healPerSec * dt);
    }

    // move player
    state.player.x = clamp(state.player.x + vx*state.player.speed*dt, 10, W/DPR-10);
    state.player.y = clamp(state.player.y + vy*state.player.speed*dt, 10, H/DPR-10);

    // invincible timer
    if (state.player.iTime > 0) {
      state.player.iTime = Math.max(0, state.player.iTime - dt);
    }

    // knockback
    if (Math.abs(state.player.kbx) + Math.abs(state.player.kby) > 0.1) {
      state.player.x = clamp(state.player.x + state.player.kbx * dt, 10, W / DPR - 10);
      state.player.y = clamp(state.player.y + state.player.kby * dt, 10, H / DPR - 10);
      const drag = 8.0;
      state.player.kbx += -state.player.kbx * drag * dt;
      state.player.kby += -state.player.kby * drag * dt;
    } else {
      state.player.kbx = state.player.kby = 0;
    }

    // spawn enemies
    state.spawnTimer -= dt;
    let spawnRate = Math.max(0.34, 1.0 - state.timeSec*0.0085);
    if(state.timeSec>=360){ spawnRate *= 0.75; }
    if(state.spawnTimer<=0){
      const batch = 1 + Math.min(3, Math.floor(state.timeSec/150));
      for(let n=0;n<batch;n++){ spawnEnemy(); }
      state.spawnTimer = spawnRate;
      spawnItemRandom();
    }

    // weapons update
    for(const k in state.weapons){ state.weapons[k].update(dt); }

// === ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ ===
for(let i=state.bullets.length-1;i>=0;i--){
  const b=state.bullets[i];
  
  // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ã¯æ•µã‚’è¿½å°¾
  if(b.type==='homing'){
    const t = nearestEnemy(b.x,b.y);
    if(t){
      const dx=t.x-b.x, dy=t.y-b.y;
      const ang = Math.atan2(dy,dx);
      const speed = Math.hypot(b.vx,b.vy);
      const cur = Math.atan2(b.vy,b.vx);
      const diff = ((ang-cur+Math.PI*3)%(Math.PI*2))-Math.PI;
      const maxTurn = b.turn * dt;
      const newAng = cur + clamp(diff, -maxTurn, maxTurn);
      b.vx = Math.cos(newAng)* speed;
      b.vy = Math.sin(newAng)* speed;
    }
  }

  if(b.type==='rock'){ b.spin += 6*dt; }

  // ç§»å‹•ã¨å¯¿å‘½å‡¦ç†
  b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
  if(b.x<-60||b.x>W/DPR+60||b.y<-60||b.y>H/DPR+60|| b.life<=0){ 
    state.bullets.splice(i,1); 
    continue; 
  }

  // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š
  for(let j=state.enemies.length-1;j>=0;j--){
    const e=state.enemies[j];
    const r = (e.type==='big'? e.size*0.55 : e.type==='mid'? e.size*0.6 : e.type==='minion'? e.size*0.7 : e.size*0.7);
    
    if(dist2(b.x,b.y,e.x,e.y) < (b.r + r)**2){
      // --- ãƒ’ãƒƒãƒˆ ---
      e.hp -= b.dmg; 
      e.hitFlash = Math.max(e.hitFlash, 0.12);
      spark(b.x,b.y, b.type==='rock'? 3 : 4);

      if(b.type==='homing'){
        // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ã¯çˆ†ç™ºã—ã¦æ¶ˆãˆã‚‹
        const R = (b.bigBoom ? 90 : 46) * state.mods.sizeMul;
        addEffect('nova',{x:b.x,y:b.y,r:R, life:.26});
        for(const e2 of state.enemies){
          const d = Math.hypot(e2.x-b.x, e2.y-b.y);
          if(d<R) { e2.hp -= b.dmg * (b.bigBoom? 1.2:1); e2.hitFlash = Math.max(e2.hitFlash, 0.12); }
        }
        state.bullets.splice(i,1);

      }else if(b.type==='bullet'){
        // é€šå¸¸å¼¾ã¯1ä½“ã«å½“ãŸã£ãŸã‚‰æ¶ˆãˆã‚‹
        state.bullets.splice(i,1);

      }else if(b.type==='ghost'){
        // ğŸ‘» ã‚´ãƒ¼ã‚¹ãƒˆå¼¾ï¼šè²«é€š3å›ã¾ã§
        if(b.pierce > 0){
          b.pierce--;   // æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã—ã¦å¼¾ã¯æ®‹ã™
        }else{
          state.bullets.splice(i,1); // ã‚‚ã†æ®‹å¼¾æ•°ãªã„ã®ã§æ¶ˆãˆã‚‹
        }

      }
      // rock ã¯æ—¢å­˜é€šã‚Šæ¶ˆã•ãªã„ï¼ˆæ®‹ã‚‹ï¼‰

      break; // 1ä½“ã«å½“ãŸã£ãŸã‚‰ã“ã®å¼¾ã®å‡¦ç†ã¯çµ‚ã‚ã‚Š
    }
  }
}


    // === æ•µå¼¾ ===
    for(let i=state.enemyBullets.length-1;i>=0;i--){
      const b=state.enemyBullets[i];
      b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
      if(b.life<=0 || b.x<-40||b.x>W/DPR+40||b.y<-40||b.y>H/DPR+40){ 
        state.enemyBullets.splice(i,1); 
        continue; 
      }

      // Orbit cancel bullets
      let canceled = false;
      if(state.weapons.orbit.lv>0){
        const count = state.weapons.orbit.awaken ? 8 : (2 + state.weapons.orbit.lv);
        for(let k=0;k<count && !canceled;k++){
          const ang = state.weapons.orbit.ang + k*(Math.PI*2/count);
          const rad = state.weapons.orbit.baseR + 14*(state.weapons.orbit.lv-1) + (state.weapons.orbit.awaken? 12:0);
          const ox = state.player.x + Math.cos(ang)*rad;
          const oy = state.player.y + Math.sin(ang)*rad;
          if(dist2(b.x,b.y,ox,oy) < (b.r + (state.weapons.orbit.awaken ? 15 : 10)*state.mods.sizeMul)**2){
            state.enemyBullets.splice(i,1);
            spark(b.x,b.y,8);
            canceled = true;
          }
        }
        if(canceled) continue;
      }

      if (dist2(b.x,b.y,state.player.x,state.player.y) < (b.r + state.player.r)**2){
        state.enemyBullets.splice(i,1);
        playerHit(b.dmg, b.x, b.y);
        spark(b.x,b.y,6);
        if(state.player.hp<=0){ gameOver(); requestAnimationFrame(loop); return; }
      }
    }

    // === æ•µãƒ»ãƒœã‚¹ ===
    for(let i=state.enemies.length-1;i>=0;i--){
      const e=state.enemies[i];
      e.hitFlash = Math.max(0, e.hitFlash - dt*2.5);

      if(e.type==='minion'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        e.x += Math.cos(a)*e.speed*dt; 
        e.y += Math.sin(a)*e.speed*dt;

      }else if(e.type==='shooter'){
        if(e.phase==='move'){
          const step = e.moveSpeed * dt;
          e.x += e.dir.x * step; e.y += e.dir.y * step; e.moved += step;
          if(e.moved >= e.moveDist){ e.phase='stop'; }
        }else{
          e.cd -= dt;
          if(e.cd<=0){
            const angS = Math.atan2(state.player.y-e.y, state.player.x-e.x);
            state.enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(angS)*200, vy:Math.sin(angS)*200, r:4, dmg:10, life:60 });
            e.cd = rnd(1.9, 2.1);
          }
        }

      }else if(e.type==='mid'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        e.x += Math.cos(a)*e.speed*dt*0.9; 
        e.y += Math.sin(a)*e.speed*dt*0.9;
        e.cd -= dt;
        if(e.cd<=0){
          const n = 8;
          for(let k=0;k<n;k++){
            const ang = (Math.PI*2*k)/n;
            state.enemyBullets.push({ x:e.x,y:e.y, vx:Math.cos(ang)*120, vy:Math.sin(ang)*120, r:4, dmg:12, life:3 });
          }
          e.cd = 7.0;
        }

      }else if(e.type==='big' || e.type==='final'){
        const ang = Math.atan2(state.player.y - e.y, state.player.x - e.x);
        e.cd -= dt;
        e.dashCD -= dt;

        if(e.type === 'final'){
        // --- å…±é€šï¼šã‚†ã‚‹ãè¿½å°¾ ---
e.x += Math.cos(ang) * e.speed * dt * 0.45;
e.y += Math.sin(ang) * e.speed * dt * 0.45;

// åˆæœŸåŒ–ä¿è­·
if(e.shootCD === undefined) e.shootCD = 0;
if(e.patternCD === undefined) e.patternCD = 3.5; // åˆæœŸã‚‚çŸ­ã‚

if(e.phase === 'shoot'){
  // é€šå¸¸æ‹¡æ•£å°„æ’ƒï¼ˆé »åº¦UP/ã‚„ã‚„æ¿ƒã„ï¼‰
  e.shootCD -= dt;
  if(e.shootCD <= 0){
    for(let k=-4;k<=4;k++){
      const a2 = ang + k * 0.11;
      state.enemyBullets.push({
        x:e.x, y:e.y,
        vx:Math.cos(a2)*180, vy:Math.sin(a2)*180, // å°‘ã—é€Ÿã
        r:4, dmg:18, life:3.8
      });
    }
    e.shootCD = 1.8; // â˜… 2.6â†’1.8
  }

  // ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆé »åº¦UPï¼‰
  if(e.dashCD <= 0){
    e.phase = 'tele';
    e.tele  = 0.7; // 0.9â†’0.7
    e.target = { x: state.player.x, y: state.player.y };
    const dx = e.target.x - e.x, dy = e.target.y - e.y;
    const m = Math.hypot(dx,dy) || 1;
    e.dashDir = { x: dx/m, y: dy/m };
  }

  // ç‰¹æ®Šè¡Œå‹•ï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼ or å¤§çˆ†ç™ºï¼‰é »åº¦UP
  e.patternCD -= dt;
  if(e.patternCD <= 0){
    const r = Math.random();
    if(r < 0.55){
      e.phase = 'charge_laser';
      e.laserAimT = 0.8; // â˜… 1.0â†’0.8
      e.laserAng  = Math.atan2(state.player.y - e.y, state.player.x - e.x);
    }else{
      e.phase   = 'charge_boom';
      e.chargeT = 0.9;   // 1.0â†’0.9
      e.didBoomDamage = false;
    }
    e.patternCD = rnd(3.0, 5.0); // â˜… 6â€“8 â†’ 3â€“5
  }

}else if(e.phase === 'tele'){
  e.tele -= dt;
  addEffect('aim', { x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06 });
  if(e.tele <= 0){ e.phase = 'dash'; }

}else if(e.phase === 'dash'){
  const dashSpeed = 1200;
  e.x += e.dashDir.x * dashSpeed * dt;
  e.y += e.dashDir.y * dashSpeed * dt;
  const rx = e.target.x - e.x, ry = e.target.y - e.y;
  if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
    e.cd = 1.6;          // 2.0â†’1.6
    e.dashCD = 4.8;      // 6.0â†’4.8
    e.phase = 'shoot';
  }

}else if(e.phase === 'charge_laser'){
  e.laserAimT -= dt;
  const L = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;

  // ç›®ç«‹ã¤â€œåŠé€æ˜ã®å¤ªã„äºˆå‚™ç·šâ€
  addEffect('laserGhost', { x1:e.x, y1:e.y, x2, y2, w:56, life:.06 });

  if(e.laserAimT <= 0){
    e.phase = 'laser';
    e.laserDur = 1.6;
  }

}else if(e.phase === 'laser'){
  e.laserDur -= dt;
  const L = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;
  addEffect('laserBeam', { x1:e.x, y1:e.y, x2, y2, w:56, life:.06 }); // å¤ªã‚

  // å½“ãŸã‚Šåˆ¤å®š
  const d = pointLineDist(state.player.x, state.player.y, e.x, e.y, x2, y2);
  if(d < 26 && state.player.iTime <= 0){ playerHit(38, e.x, e.y); }

  if(e.laserDur <= 0){ e.cd = 1.8; e.phase = 'shoot'; }

}else if(e.phase === 'charge_boom'){
  // äºˆå‚™å‹•ä½œï¼šå°ã•ã‚ã®ç™½ãƒ‘ãƒ«ã‚¹ï¼ˆçŸ­ã‚ï¼‰
  e.chargeT -= dt;
  const r0 = 60, r1 = 120;
  addEffect('whitePulse', { x:e.x, y:e.y, r0, r1, life:.06 }); // â† æ–°ã—ã„è»½ã„äºˆå‚™è¡¨ç¤º
  if(e.chargeT <= 0){
    // æœ¬ç•ªï¼šæ‹¡å¤§æ³¢ã®åˆæœŸåŒ–
    e.phase = 'boom';
    e.boomDur = 1.8;             // â˜… æ‹¡å¤§ã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆé¿ã‘çŒ¶äºˆï¼‰
    e.boomT   = e.boomDur;
    e.boomR0  = 80;               // â˜… é–‹å§‹åŠå¾„ï¼ˆå°ã•ãå§‹ã‚ã‚‹ï¼‰
    e.boomR1  = Math.hypot(W/DPR, H/DPR) * 0.9; // ç”»é¢å¯¾è§’ã®9å‰²ã¾ã§
    e.didBoomDamage = false;
  }

}else if(e.phase === 'boom'){
  // é€²è¡Œåº¦ï¼ˆ0â†’1ï¼‰ã¨ç¾åœ¨åŠå¾„
  e.boomT -= dt;
  const life0 = e.boomDur;
  const p = 1 - Math.max(0, e.boomT) / life0; // 0..1
  const R = e.boomR0 + (e.boomR1 - e.boomR0) * p;

  addEffect('boomWave', { x:e.x, y:e.y, r:R, w:28, life:.06, life0:.06 });

  const d = Math.hypot(state.player.x - e.x, state.player.y - e.y);
  if (!e.didBoomDamage && d <= R) {
    if (state.player.iTime <= 0) playerHit(40, e.x, e.y);
    e.didBoomDamage = true;
  }

  if(e.boomT <= 0){
    e.cd = 2.4;
    e.phase = 'shoot';
  }
  }
  }
  
else {
  // === æ—¢å­˜ big ã®å‡¦ç† ===
  
            if(e.phase==='shoot'){
            e.x += Math.cos(ang)*e.speed*dt*0.6;
            e.y += Math.sin(ang)*e.speed*dt*0.6;
            if(e.cd<=0)
            {
              for(let k=-3;k<=3;k++){
                const a2 = ang + k*0.12;
                state.enemyBullets.push({
                  x:e.x, y:e.y,
                  vx:Math.cos(a2)*160, vy:Math.sin(a2)*160,
                  r:4, dmg:14, life:3.5
                });
              }
              e.cd = 3.0;
            }
            if(e.dashCD<=0){
              e.phase='tele'; 
              e.tele=0.9;
              e.target = { x: state.player.x, y: state.player.y };
              const dx = e.target.x - e.x, dy = e.target.y - e.y;
              const m = Math.hypot(dx,dy)||1;
              e.dashDir = { x: dx/m, y: dy/m };
            }

          } else if(e.phase==='tele'){
            e.tele -= dt;
            addEffect('aim',{x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06});
            if(e.tele<=0){ 
              e.phase='dash'; 
              e.tele=0; 
            }

          } else if(e.phase==='dash'){
            const dashSpeed = 980;
            e.x += e.dashDir.x * dashSpeed * dt;
            e.y += e.dashDir.y * dashSpeed * dt;
            const rx = e.target.x - e.x, ry = e.target.y - e.y;
            if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
              e.cd = 2.0; 
              e.dashCD = 6.5; 
              e.phase='shoot';
            }
          }
        }
      }
      

      // ====== ã“ã“ã‹ã‚‰è¿½è¨˜ ======
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¥è§¦åˆ¤å®š
      const touchDmg =
        (e.type === 'big' || e.type === 'final')
          ? (e.phase === 'dash'
              ? (e.type === 'final' ? 80 : 60)
              : (e.type === 'final' ? 40 : 32))
          : (e.type === 'mid')
            ? 24
            : 18;

      if (dist2(e.x, e.y, state.player.x, state.player.y) < (state.player.r + e.size * 0.6) ** 2) {
        if (state.player.iTime <= 0) {
          playerHit(touchDmg, e.x, e.y);
          if (state.player.hp <= 0) {
            gameOver();
            requestAnimationFrame(loop);
            return;
          }
        }
      }

      // æ•µæ­»äº¡å‡¦ç†
      if (e.hp <= 0) {
if (e.type === 'final') {
  // è¦‹ãŸç›®ï¼šå¼·ã„ç™ºå…‰ï¼‹çˆ†ç™º
  addEffect('bossExplode', { x: e.x, y: e.y, R: 420, life: 0.9, life0: 0.9 });
  addEffect('flash', { life: 0.08 });

  // å¾Œå§‹æœ«ï¼šæ•µãƒ»æ•µå¼¾ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢ï¼†ã‚¹ãƒãƒ¼ãƒ³åœæ­¢
  state.enemies.length = 0;
  state.enemyBullets.length = 0;
  state.items.length = 0;
  state.spawnTimer = 9999;

  // ã‚¯ãƒªã‚¢é·ç§»ï¼ˆå°‘ã—è¦‹ã›ã¦ã‹ã‚‰ï¼‰
  state.winCountdown = 1.2; // 1.2ç§’å¾Œã« showGameClear() ãŒå‘¼ã°ã‚Œã‚‹æƒ³å®š
} else if (e.type === 'mid' || e.type === 'big') {
          const picks = (e.type === 'big') ? 2 : 1;
          state.items.push({ kind: 'chest', x: e.x, y: e.y, r: 14, t: 0, picks });
          addEffect('text', { x: e.x, y: e.y, life: 1.2, text: (picks === 2 ? 'å®ç®±Ã—2ï¼' : 'å®ç®±ï¼') });
          spark(e.x, e.y, e.type === 'mid' ? 22 : 34);
        } else {
          const val = 1 + (Math.random() < 0.2 ? 1 : 0);
          dropGem(e.x, e.y, val);
          spark(e.x, e.y, 10);
        }
        state.enemies.splice(i, 1);
      }
      // ====== è¿½è¨˜ã“ã“ã¾ã§ ======

      }

    // === ã‚¢ã‚¤ãƒ†ãƒ  ===
    for(let i=state.items.length-1;i>=0;i--){
      const it=state.items[i]; it.t += dt;
      if(dist2(it.x,it.y,state.player.x,state.player.y) < (it.r + state.player.r)**2){
        applyItem(it); state.items.splice(i,1); spark(state.player.x,state.player.y,14);
      }
      if(it.t>20){ state.items.splice(i,1); }
    }

    // === ã‚¸ã‚§ãƒ  ===
    let pickupR = 70 * (1 + 0.6 * state.pickupLv);
    if (state.pickupLv >= 3) {
      pickupR = Math.hypot(W / DPR, H / DPR);
    }
    for(let i=state.gems.length-1;i>=0;i--){
      const g=state.gems[i];
      const d = Math.hypot(state.player.x-g.x, state.player.y-g.y);
      if(d<pickupR){
        const ax = (state.player.x-g.x)/Math.max(1,d);
        const ay = (state.player.y-g.y)/Math.max(1,d);
        g.x += ax * 220 * dt; g.y += ay * 220 * dt;
      }
      if(dist2(g.x,g.y,state.player.x,state.player.y) < (state.player.r+g.r)**2){
        addXP(g.val*5); state.gems.splice(i,1);
      }
    }

    // === ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ« ===
    for(let i=state.sparks.length-1;i>=0;i--){
      const p=state.sparks[i]; 
      p.t+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      if(p.t>p.life) state.sparks.splice(i,1);
    }
    for(let i=state.effects.length-1;i>=0;i--){
      const e=state.effects[i]; 
      e.life-=dt; 
      if(e.life<=0){ state.effects.splice(i,1); }
    }

    // === ã‚¯ãƒªã‚¢é·ç§»ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ ===
    if (state.winCountdown > 0){
      state.winCountdown -= dt;
      if (state.winCountdown <= 0){
        state.winCountdown = 0;
        showGameClear();
      }
    }

    updateHUD(); 
    draw();
    requestAnimationFrame(loop);

  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    requestAnimationFrame(loop);
  }
}


// ==== æç”» ====
function draw(){
  try {
  ctx.clearRect(0,0,cv.width,cv.height);
  // grid
  ctx.save(); ctx.globalAlpha=.08; ctx.strokeStyle='#888';
  const step=40;
  for(let x=((state.player.x*0.4)%step); x< cv.width/DPR; x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,cv.height/DPR); ctx.stroke();
  }
  for(let y=((state.player.y*0.4)%step); y< cv.height/DPR; y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(cv.width/DPR,y); ctx.stroke();
  }
  ctx.restore();

  // items
  for(const it of state.items){
    ctx.save(); ctx.translate(it.x,it.y);
    if(it.kind==='magnet'){ ctx.fillStyle='#00d2ff'; }
    else if(it.kind==='nuke'){ ctx.fillStyle='#ff7675'; }
    else if(it.kind==='heal'){ ctx.fillStyle='#2ecc71'; }
    else { ctx.fillStyle='#c79a3b'; }
    ctx.beginPath(); ctx.arc(0,0,it.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    if(it.kind==='magnet'){
      ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,9,-.9,.9); ctx.stroke();
    }else if(it.kind==='nuke'){
      ctx.beginPath(); ctx.moveTo(-7,-7); ctx.lineTo(7,7);
      ctx.moveTo(-7,7); ctx.lineTo(7,-7); ctx.stroke();
    }else if(it.kind==='heal'){
      ctx.beginPath(); ctx.moveTo(-6,0); ctx.lineTo(6,0);
      ctx.moveTo(0,-6); ctx.lineTo(0,6); ctx.stroke();
    }else{ // chest
      ctx.beginPath(); ctx.rect(-7,-5,14,10); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-7,0); ctx.lineTo(7,0); ctx.stroke();
    }
    ctx.restore();
  }

  // gems
  for(const g of state.gems){
    ctx.fillStyle='#3fa9ff';
    ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2); ctx.fill();
  }

// bullets
for (const b of state.bullets){
  if (b.type === 'rock'){
    // æ—¢å­˜ãã®ã¾ã¾
    ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.spin||0);
    ctx.fillStyle = '#b39c82';
    const n=8, r=b.r;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a=(i/n)*Math.PI*2, px=Math.cos(a)*r, py=Math.sin(a)*r;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill(); ctx.restore();

  } else if (b.type === 'homing'){
    // æ—¢å­˜ãã®ã¾ã¾
    ctx.save(); ctx.translate(b.x,b.y);
    ctx.fillStyle = '#a0e1ff';
    ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.restore();

  } else if (b.type === 'ghost') {
    // â˜… ã‚´ãƒ¼ã‚¹ãƒˆå¼¾ï¼šç´«ï¼‹ç™ºå…‰
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.fillStyle = '#a56bff';      // ç´«
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#cfa9ff';    // è–„ç´«ã«å…‰ã‚‰ã›ã‚‹
    ctx.beginPath();
    ctx.arc(0, 0, b.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

  } else {
    // â˜… è‡ªåˆ†ã®é€šå¸¸å¼¾ï¼šç™½ç³»ã«å¤‰æ›´ï¼ˆè¦‹åˆ†ã‘ã‚„ã™ã„è»½ã„ç™ºå…‰ï¼‰
    ctx.save();
    ctx.fillStyle = '#f5f7ff';          // æ˜ã‚‹ã„ç™½
    ctx.shadowBlur = 8;                  // ã†ã£ã™ã‚‰å…‰ã‚‹
    ctx.shadowColor = '#ffffff';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}



  // enemy bullets
  for(const b of state.enemyBullets){
    ctx.fillStyle='#ff9f43';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
  }


// ç„¡æ•µä¸­ã¯ç‚¹æ»…
if (state.player.iTime > 0 && ((state.t * 20 | 0) % 2 === 0)) {
  ctx.globalAlpha = 0.38; // è–„ã
} else {
  ctx.globalAlpha = 1;
}
// player
ctx.fillStyle = '#2ecc71';
ctx.beginPath(); ctx.arc(state.player.x, state.player.y, state.player.r, 0, Math.PI*2); ctx.fill();
ctx.lineWidth = 3; ctx.strokeStyle = '#ffffff'; ctx.stroke();
ctx.fillStyle = '#0b0b0b';
ctx.beginPath(); ctx.arc(state.player.x-5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(state.player.x+5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();

ctx.globalAlpha = 1;  // â† ã“ã“ã¾ã§ãŒæ—¢å­˜

/* ===== ã“ã“ã‹ã‚‰è¿½è¨˜ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨å›²ãƒªãƒ³ã‚°ï¼ˆHP/XPï¼‰ ===== */
{
  const hpRatio = Math.max(0, Math.min(1, state.player.hp / state.player.maxHp));
  const xpRatio = Math.max(0, Math.min(1, state.player.xp / state.player.nextXp(state.player.level)));

  const R0 = state.player.r + 7;   // HPãƒªãƒ³ã‚°åŠå¾„
  const R1 = state.player.r + 12;  // XPãƒªãƒ³ã‚°åŠå¾„

  ctx.save();
  ctx.lineCap = 'round';

  // èƒŒæ™¯ãƒªãƒ³ã‚°ï¼ˆè–„ã‚°ãƒ¬ãƒ¼ï¼‰
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R0, 0, Math.PI*2); ctx.stroke();
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R1, 0, Math.PI*2); ctx.stroke();

  // â˜… HPãƒªãƒ³ã‚°ï¼ˆ20%ä»¥ä¸‹ã§èµ¤ã€ãã‚Œä»¥å¤–ã¯ç·‘ï¼‰
  const hpColor = (hpRatio <= 0.20) ? '#ff5a5a' : '#2ecc71';
  ctx.strokeStyle = hpColor;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R0,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*hpRatio
  );
  ctx.stroke();

  // XPãƒªãƒ³ã‚°ï¼ˆé’ï¼‰
  ctx.strokeStyle = '#3498db';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R1,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*xpRatio
  );
  ctx.stroke();

  // ï¼ˆç‹­ã„ç”»é¢å‘ã‘ï¼‰HPæ•°å€¤ã®å°è¡¨ç¤ºã¯ãã®ã¾ã¾ã§OK
  if (window.innerWidth <= 480) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${Math.ceil(state.player.hp)}/${state.player.maxHp}`,
      state.player.x, state.player.y - R0 - 6);
  }

  ctx.restore();
}
/* ===== è¿½è¨˜ã“ã“ã¾ã§ ===== */


// Ghosts render
if(state.weapons.ghost.lv>0){
  const w = state.weapons.ghost;
  const count = w.awaken ? 6 : w.lv;
  ctx.save();
  ctx.globalAlpha = 0.85;
  for(let k=0;k<count;k++){
    const a = w.ang + k * (Math.PI*2/count);
    const r = 60 + 10*(w.lv-1);
    const gx = state.player.x + Math.cos(a)*r;
    const gy = state.player.y + Math.sin(a)*r;

    // --- æœ¬ä½“ ---
    ctx.fillStyle = '#7ee4ff'; // æ°´è‰²ãƒœãƒ‡ã‚£
    ctx.beginPath();
    ctx.arc(gx, gy, 9, 0, Math.PI*2);
    ctx.fill();

    // --- é¡”ï¼ˆç›®ï¼‹å£ï¼‰ ---
    ctx.fillStyle = '#000';  // é»’ç›®
    ctx.beginPath(); ctx.arc(gx - 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(gx, gy + 2, 3, 0, Math.PI); // åŠå††ã®å£
    ctx.stroke();
  }
  ctx.restore();
}

  // orbitals
  if(state.weapons.orbit.lv>0){
    ctx.fillStyle='#9b59b6';
    const count = state.weapons.orbit.awaken ? 8 : (2 + state.weapons.orbit.lv);
    for(let k=0;k<count;k++){
      const ang = state.weapons.orbit.ang + k*(Math.PI*2/count);
      const rad = state.weapons.orbit.baseR + 14*(state.weapons.orbit.lv-1) + (state.weapons.orbit.awaken? 12:0);
      const ox = state.player.x + Math.cos(ang)*rad;
      const oy = state.player.y + Math.sin(ang)*rad;
      ctx.beginPath(); ctx.arc(ox,oy,(state.weapons.orbit.awaken ? 15 : 10)*state.mods.sizeMul,0,Math.PI*2); ctx.fill();
    }
  }

  // enemies with HP bars
  for(const e of state.enemies){
    const s=e.size;
    if(e.type==='minion'){ ctx.fillStyle='#e74c3c'; }
    else if(e.type==='shooter'){ ctx.fillStyle='#f39c12'; }
    else if(e.type==='mid'){ ctx.fillStyle='#00bcd4'; }
    else if(e.type==='final'){ ctx.fillStyle='#ffd700'; }
    else { ctx.fillStyle='#ff00aa'; }
    ctx.fillRect(e.x-s/2, e.y-s/2, s, s);
    if(e.hitFlash>0){
      ctx.save(); ctx.globalAlpha=e.hitFlash; ctx.fillStyle='#fff';
      ctx.fillRect(e.x-s/2,e.y-s/2,s,s); ctx.restore();
    }
    const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
    const bw = s, bh = 4; const bx = e.x - bw/2, by = e.y - s/2 - 6;
    ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
    ctx.fillRect(bx, by, bw*ratio, bh);
    ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
  }

 // effects
for (const ef of state.effects) {
  if (ef.type === 'nova') {
    ctx.save();
    const life0 = 0.25;                 // ef.life ã¯ 0.25 ä»˜è¿‘ã‚’æƒ³å®š
    const a = Math.max(0, ef.life / life0);

    // å¤–è¼ªï¼ˆå¼·ã‚ã®ç™ºå…‰ï¼‹å¤ªã‚ï¼‰
    ctx.globalAlpha = 0.85 * a;
    ctx.strokeStyle = '#6fbaff';
    ctx.lineWidth = 6;
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#9fd3ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.55), 0, Math.PI * 2);
    ctx.stroke();

    // ã†ã£ã™ã‚‰å¡—ã‚Š
    ctx.globalAlpha = 0.20 * a;
    ctx.fillStyle = '#6fbaff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.65), 0, Math.PI * 2);
    ctx.fill();

    // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆè¼ª
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.95 * a;
    ctx.strokeStyle = '#e7fbff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.70), 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

  } else if (ef.type === 'aura') {
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#85c1ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

  } else if (ef.type === 'aim') {
    // æ±ç”¨ã®èµ¤ç³»äºˆå‘Šç·šï¼ˆãƒœã‚¹dashãªã©ï¼‰
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ff66cc';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.beginPath();
    ctx.moveTo(ef.x1, ef.y1);
    ctx.lineTo(ef.x2, ef.y2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

  } else if (ef.type === 'line') {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ffcccc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(ef.x + ef.dx * 80, ef.y + ef.dy * 80);
    ctx.stroke();
    ctx.restore();

  } else if (ef.type === 'text') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText(ef.text, ef.x, ef.y - (1 - ef.life) * 20);
    ctx.restore();

} else if (ef.type === 'laserGhost') {
  // äºˆå‚™ç·šï¼šå¤ªã„åŠé€æ˜ã®å¸¯ã€‚çƒãŒå¤šãã¦ã‚‚è¦–èªã—ã‚„ã™ã„
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0â†’1 ã«æ­£è¦åŒ–

  // å¤–å´ã®ã‚„ã‚ã‚‰ã‹ã„â€œè‰²ã¤ããƒãƒ­â€
  ctx.globalAlpha = 0.35 * a;
  ctx.strokeStyle = '#7fd9ff';       // è–„ã„ã‚·ã‚¢ãƒ³ç³»
  ctx.lineWidth = (ef.w || 48) * 2;  // å¤–ãƒãƒ­ã¯å¤ªã‚
  ctx.shadowBlur = 28;
  ctx.shadowColor = '#90e4ff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // å†…å´ã®è»¸ï¼ˆã•ã‚‰ã«è–„ã„ï¼‰
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.22 * a;
  ctx.strokeStyle = '#dff6ff';
  ctx.lineWidth = (ef.w || 48);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  ctx.restore();

} else if (ef.type === 'laserBeam') {
  // ãƒ¬ãƒ¼ã‚¶ãƒ¼æœ¬ä½“ï¼šæ¥µå¤ªãƒ»é«˜è¼åº¦ã€‚Î±æ­£è¦åŒ–ï¼‹å¤ªã•å¢—ã—
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0â†’1 ã«æ­£è¦åŒ–

  // å¤–å´ã®å¼·ã„å…‰
  ctx.globalAlpha = 0.95 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = (ef.w || 48) * 3; // ã•ã‚‰ã«å¤ªã
  ctx.shadowBlur = 32;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1.0 * a;
  ctx.strokeStyle = '#f5fbff';
  ctx.lineWidth = Math.max(8, ((ef.w || 48) * 3) - 8);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();
  ctx.restore();

  } else if (ef.type === 'whiteCharge') {
    // çˆ†ç™ºäºˆå‚™å‹•ä½œï¼šç™½ãå¼·ãå…‰ã‚‹ç‰
    ctx.save();
    const a = Math.max(0, ef.life); // 1 â†’ 0
    const r = ef.r0 + (1 - a) * (ef.r1 - ef.r0);

    // å¡—ã‚Šï¼ˆç™½ï¼‰
    ctx.globalAlpha = 0.35 + 0.45 * a;
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 28;
    ctx.shadowColor = '#ffffff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r * 0.92, 0, Math.PI * 2);
    ctx.fill();

    // è¼ªéƒ­ï¼ˆç™½ï¼‰
    ctx.globalAlpha = 0.9;
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

  } else if (ef.type === 'megaNova') {
    // æœ¬çˆ†ç™ºï¼šã§ã‹ã„å…‰è¼ªï¼‹æ·¡ã„å¡—ã‚Šã€å°‘ã—é•·ã‚
    ctx.save();
    const a = Math.max(0, ef.life); // 0.9 â†’ 0
    const R = ef.r * (1 - a * 0.5);

    // å¤–è¼ªï¼ˆå¼·ç™ºå…‰ï¼‰
    ctx.globalAlpha = 0.95 * a;
    ctx.strokeStyle = '#fff4c1';
    ctx.lineWidth = 12;
    ctx.shadowBlur = 36;
    ctx.shadowColor = '#fffbe3';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, R, 0, Math.PI * 2);
    ctx.stroke();

    // å¡—ã‚Š
    ctx.globalAlpha = 0.28 * a;
    ctx.fillStyle = '#fff1b3';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, R * 0.95, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

} else if (ef.type === 'whitePulse') {
  // äºˆå‚™ãƒ‘ãƒ«ã‚¹ï¼šå°ã•ãç™½ãå…‰ã‚‹ç‰ï¼ˆcharge_boomã§ä½¿ç”¨ï¼‰
  ctx.save();
  const a = Math.max(0, ef.life / 0.06);           // 0â†’1
  const r = ef.r0 + (ef.r1 - ef.r0) * (1 - a);     // ã ã‚“ã ã‚“å°â†’å¤§ ã§ã‚‚ OKï¼ˆå¥½ã¿ï¼‰
  ctx.globalAlpha = 0.4 * a;
  ctx.fillStyle = '#ffffff';
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r * 0.9, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.9 * a;
  ctx.shadowBlur = 0;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r, 0, Math.PI*2); ctx.stroke();
  ctx.restore();

} else if (ef.type === 'boomWave') {
  // æœ¬ç•ªï¼šåŠé€æ˜ã®â€œæ‹¡å¤§ãƒªãƒ³ã‚°â€
  ctx.save();
  const a = Math.max(0, ef.life / (ef.life0 || 0.06)); // ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒ•ã‚§ãƒ¼ãƒ‰
  const w = ef.w || 24;

  // å¤–å´ãƒãƒ­ï¼ˆè–„ã„ã‚ªãƒ¬ãƒ³ã‚¸ç³»ï¼‰
  ctx.globalAlpha = 0.28 * a;
  ctx.strokeStyle = '#ffd27a';
  ctx.lineWidth = w * 1.6;
  ctx.shadowBlur = 24;
  ctx.shadowColor = '#ffe4ad';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // ä¸»ãƒªãƒ³ã‚°
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9 * a;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth = w;
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // å†…ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ctx.globalAlpha = 0.85 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = Math.max(4, w - 6);
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  ctx.restore();

  } else if (ef.type === 'bossExplode') {
    // ãƒœã‚¹æ’ƒç ´æ¼”å‡ºï¼šç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‹å¤šé‡ãƒªãƒ³ã‚°
    ctx.save();
    const a = Math.max(0, ef.life / (ef.life0 || 0.8));

    // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    ctx.globalAlpha = 0.4 * a;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);

    // è¤‡æ•°ãƒªãƒ³ã‚°
    const rings = [
      { color: '#fff2b3', w: 16, blur: 24, mul: 1.00 },
      { color: '#ffe680', w: 10, blur: 16, mul: 0.75 },
      { color: '#ffd24d', w: 6,  blur: 10, mul: 0.55 },
    ];
    for (const r of rings) {
      ctx.globalAlpha = 0.9 * a;
      ctx.strokeStyle = r.color;
      ctx.lineWidth = r.w;
      ctx.shadowBlur = r.blur;
      ctx.shadowColor = r.color;
      ctx.beginPath();
      ctx.arc(ef.x, ef.y, ef.R * (1 - a * 0.7) * r.mul, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();

  } else if (ef.type === 'flash') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life * 0.8);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);
    ctx.restore();

  } else if (ef.type === 'zig') {
    // ç¨²å¦»ï¼ˆãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ï¼‰
    const pts = ef.path;
    if (!pts || pts.length < 2) {
      continue; // å®‰å…¨ã‚¬ãƒ¼ãƒ‰
    }
    ctx.save();
    const a = Math.max(0, ef.life / 0.22);
    ctx.globalAlpha = 0.85 * a;

    // å¤–å´ã®å¤ªã„ç¨²å¦»
    ctx.strokeStyle = '#aee9ff';
    ctx.lineWidth = ef.thick;
    ctx.lineJoin = 'round';
    ctx.shadowBlur = 14;
    ctx.shadowColor = '#9adfff';
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.stroke();

    // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(2, ef.thick - 2);
    ctx.globalAlpha = 0.9 * a;
    ctx.strokeStyle = '#e7fbff';
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.stroke();

    ctx.restore();
   }
  } // â† for(const ef of state.effects) ã®é–‰ã˜ã‚«ãƒƒã‚³
  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    throw err; // loop å´ã§ã‚‚æ‹¾ãˆã‚‹ã‚ˆã†ã«
  }
} // â† function draw ã®é–‰ã˜ã‚«ãƒƒã‚³


// ===== ã“ã“ã‹ã‚‰ä¸‹ã¯ãƒ˜ãƒ«ãƒ‘ =====


function pointLineDist(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = Math.max(1e-6, vx * vx + vy * vy);
  const t = Math.max(0, Math.min(1, (vx * wx + vy * wy) / denom));
  const dx = x1 + vx * t - px, dy = y1 + vy * t - py;
  return Math.hypot(dx, dy);
}

function triggerFinalExplosion(x, y) {
  // ä»–ã®æ•µãƒ»å¼¾ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ã¯å³æ™‚æ¶ˆå»
  state.enemies.length = 0;
  state.enemyBullets.length = 0;
  state.items.length = 0;
  state.spawnTimer = 9999;

  // ç”»é¢å…¨ä½“ã«è¿‘ã„å¤§çˆ†ç™ºã‚’è¡¨ç¤º
  addEffect('flash', { life: .06 });
  addEffect('megaNova', {
    x, y,
    r: Math.hypot(W / DPR, H / DPR) * 0.85,
    life: 0.9
  });
  for (let k = 0; k < 22; k++) {
    spark(x + (Math.random() - 0.5) * 30, y + (Math.random() - 0.5) * 30, 18);
  }

  // ä¸€å®šæ™‚é–“â€œè¦‹ã›ã‚‹â€â†’ ã‚¯ãƒªã‚¢ç”»é¢
  state.winCountdown = 1.2; // 1.2ç§’å¾Œã«ã‚¯ãƒªã‚¢è¡¨ç¤º
}


function showGameClear(){
  const el = document.getElementById('gameclear'); // â† ã“ã“ã‚’ gameclear ã«
  if (el){
    el.style.display = 'flex';
    state.paused = true;
  }else{
    state.paused = true;
    alert('GAME CLEAR'); // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
  }
}


function gameOver(){
  state.paused = true;
  // â–¼ XPå›åã®æ®‹ã‚Šã‚’å¼·åˆ¶åœæ­¢
  state.gather.active = false;
  state.gather.time = 0;
  state.gather.totalXP = 0;
  gatherEl.style.display = 'none';
  // â–¼ ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼†ç„¡æ•µã‚‚åœæ­¢
  state.player.kbx = state.player.kby = 0;
  state.player.iTime = 0;
  goEl.style.display='flex';
}

  // Final Boss spawn
function spawnFinalBoss(){
  const margin = 120;
  const side = Math.floor(Math.random()*4);
  let x,y;
  if(side===0){ x=rnd(-margin,0); y=rnd(0,H/DPR); }
  else if(side===1){ x=rnd(W/DPR,W/DPR+margin); y=rnd(0,H/DPR); }
  else if(side===2){ x=rnd(0,W/DPR); y=rnd(-margin,0); }
  else { x=rnd(0,W/DPR); y=rnd(H/DPR,H/DPR+margin); }

  const base = 2600 + state.difficulty*300;
  const hp = base * 10;
  const e = {
    x,y, size:84*2, hp, maxHp:hp, speed:70, type:'final',
    phase:'shoot', cd:0, tele:0, dashCD:5.5, dashDir:{x:0,y:0},
    patternCD:4.5, blastCharge:0, blastR:220, laserAng:0,
    laserAimT:0, laserDur:0, hitFlash:0
  };
  state.enemies.push(e);
  flashBossMsg();
}



  requestAnimationFrame(loop);
})();
</script>


</body>
</html>
