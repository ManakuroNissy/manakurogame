<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- ã‚°ãƒ­ãƒ¼ãƒãƒ«Promiseæ‹’å¦ãƒãƒ³ãƒ‰ãƒ©ï¼ˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’æŠ‘åˆ¶ï¼‰ -->
<script>
window.addEventListener('unhandledrejection', function(event) {
  event.preventDefault();
});
</script>

<title>10min's Survivor</title>
<style>
  html,body { margin:0; height:100%; background:#0e0e0f; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; }
#wrap {
  position:relative;
  width:100%;
  height:100dvh;
  overflow:hidden;
  touch-action:none;
  padding-bottom: env(safe-area-inset-bottom);
}


@supports not (height: 100dvh) {
  #wrap { height:100svh; }
}

canvas {
  position:absolute;
  top:0; left:0; right:0; bottom:0;
  width:100%; height:100%;
  display:block;
}
#start { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:50; pointer-events:auto; }
.hud {
  position:absolute; left:0; right:0; top:0;
  display:flex; gap:.75rem; padding:.5rem .75rem;
  align-items:center; pointer-events:none;

  /* â† ã“ã“ã‹ã‚‰è¿½è¨˜/ç½®æ›ï¼šã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢è€ƒæ…®ã—ã¤ã¤å·¦ä¸ŠPauseã¶ã‚“ã ã‘ç©ºã‘ã‚‹ */
  padding-top:  calc(.5rem + env(safe-area-inset-top));
  padding-left: calc(44px  + env(safe-area-inset-left));   /* â† 44pxã§Pauseã‚’é¿ã‘ã‚‹ */
  padding-right:calc(.75rem + env(safe-area-inset-right));
}
  .badge { background:#1a1a1a; border:1px solid #333; border-radius:.5rem; padding:.2rem .5rem; font-weight:600; }
  .bar { flex:1; height:.6rem; background:#1a1a1a; border:1px solid #333; border-radius:.4rem; overflow:hidden; }
  .bar > i { display:block; height:100%; width:0%; background:linear-gradient(90deg,#2ecc71,#27ae60); }
  .xp > i { background:linear-gradient(90deg,#3498db,#2980b9); }
  #levelup, #chest { position:absolute; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:12;}
/* === Game Over / Clear overlay (centered & stacked) === */
#gameover, #gameclear{
  position: fixed;
  inset: 0;
  display: none;             /* JSã§ flex ã«åˆ‡æ›¿ */
  align-items: center;
  justify-content: center;
  flex-direction: column;    /* â† ç¸¦ã«ä¸¦ã¹ã‚‹ï¼ˆæ”¹è¡Œã¨åŒç¾©ï¼‰ */
  gap: 14px;                 /* è¡Œé–“ */
  text-align: center;        /* ä¸­å¤®å¯„ã› */
  z-index: 13040;
  background: rgba(0,0,0,.65);
  pointer-events: auto;
}
#gameover > *, #gameclear > *{
  pointer-events: auto;
}

  #cardRow, #chestRow { display:grid; grid-template-columns:1fr 1fr; gap:0.6rem; width:min(900px,96vw); }
  @media (min-width:600px){ #cardRow{ grid-template-columns:repeat(4,1fr);} }
  @media (min-width:600px){ #chestRow{ grid-template-columns:repeat(3,1fr);} }
  @media (min-width:900px){ #chestRow{ grid-template-columns:repeat(6,1fr);} }
  .card { background:#181818; border:1px solid #333; border-radius:.6rem; padding:0.6rem; box-shadow:0 4px 18px rgba(0,0,0,.45); cursor:pointer; text-align:left; color:#fff; min-height:auto; }
  .card h3 { margin:.15rem 0 .3rem; font-size:clamp(0.8rem, 2.5vw, 1rem); color:#fff; }
  .card p { margin:0; color:#e5e5e5; line-height:1.3; font-size:clamp(0.7rem, 2vw, 0.88rem); }
  .card:hover, .card.sel { outline:2px solid #4aa3ff; }
.chestHUD {
  position: fixed;                 /* å›ºå®šé…ç½®ã«ã—ã¦é‡ãªã‚Šé †ã‚’å®‰å®šã•ã›ã‚‹ */
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 13000;                  /* åŠé€æ˜ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤(#chest)ã‚ˆã‚Šå‰ã« */
  display: none;
  gap: .75rem;
  align-items: center;
  pointer-events: none;            /* è¦ªã¯é€éï¼ˆã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯ã‚’å¦¨ã’ãªã„ï¼‰ */
}

.chestHUD .badge,
.chestHUD .pickMode,
.chestHUD .passBtn {
  pointer-events: auto;            /* å¿…è¦ãªã‚‰å­ã¯ã‚¯ãƒªãƒƒã‚¯å¯ */
}

.chestHUD .pickMode{
  font-weight: 800;
  letter-spacing: .04em;
  font-size: clamp(20px, 3.6vw, 40px);
  line-height: 1.1;
  padding: .35rem .9rem;
  border-radius: 14px;
  background: linear-gradient(180deg, rgba(18,27,37,.92), rgba(6,11,18,.92));
  color: #E6FF7A;
  text-shadow: 0 1px 0 #000, 0 0 12px rgba(230,255,122,.35);
  outline: 2px solid rgba(230,255,122,.35);
  box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
  backdrop-filter: blur(6px);
}

/* é¸æŠæ¸ˆã¿ã‚«ãƒ¼ãƒ‰ã®è¦–è¦šå¼·èª¿ï¼ˆä»»æ„: ã¤ã„ã§ã«è¦‹ã‚„ã™ãï¼‰ */
#chest .card.selected {
  outline: 4px solid #ffd400;
  box-shadow: 0 0 0 3px rgba(0,0,0,.5), 0 8px 20px rgba(0,0,0,.35);
  transform: translateY(-2px);
}

  #start h1 { font-size: clamp(28px, 6vw, 64px); margin:0 0 .5rem; color:#fff; letter-spacing:.02em; }
  #start p { font-size: clamp(14px, 3vw, 22px); margin:0 0 1rem; opacity:.9;}
  .btn { background:#1f6feb; color:#fff; border:none; padding:.7rem 1.1rem; border-radius:.6rem; font-weight:700; cursor:pointer; box-shadow:0 6px 20px rgba(31,111,235,.35); }
  .btn:hover { filter:brightness(1.05); }
  
  .passBtn { 
    background:#64748b; 
    color:#fff; 
    border:none; 
    padding:.5rem 1rem; 
    border-radius:.5rem; 
    font-weight:700; 
    cursor:pointer; 
    font-size:.9rem;
    box-shadow:0 4px 12px rgba(100,116,139,.3);
  }
  .passBtn:hover { 
    background:#475569; 
    transform:translateY(-1px);
    box-shadow:0 6px 16px rgba(100,116,139,.4);
  }
  #gameover h2 { font-size: clamp(24px, 5vw, 44px); margin:.25rem 0 .75rem; }
  #gameover .sub { opacity:.85; margin-bottom:1rem; }
  
  /* SNSå…±æœ‰ãƒœã‚¿ãƒ³ */
  .share-buttons { display:flex; gap:.75rem; margin-top:1rem; flex-wrap:wrap; justify-content:center; }
  .share-btn { 
    background:#fff; color:#000; border:none; padding:.65rem 1.2rem; 
    border-radius:.5rem; font-weight:700; cursor:pointer; 
    box-shadow:0 4px 12px rgba(0,0,0,.25); 
    display:flex; align-items:center; gap:.5rem;
    transition: transform .2s, box-shadow .2s;
  }
  .share-btn:hover { transform:translateY(-2px); box-shadow:0 6px 16px rgba(0,0,0,.35); }
  .share-btn.twitter { background:#1DA1F2; color:#fff; }
  .share-btn.line { background:#06C755; color:#fff; }
  .share-btn.copy { background:#6c757d; color:#fff; }
  /* ç¸¦æŒã¡ã®ã¨ãã¯HUDã‚’å°‘ã—ç¸®å° */
@media (orientation:portrait){
  .hud { transform: scale(.9); transform-origin: top center; opacity:.9; }
}

/* ã‹ãªã‚Šç‹­ã„ç«¯æœ«ã§ã¯HUDã‚’éè¡¨ç¤ºï¼ˆå¾Œã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨ã‚Šãƒªãƒ³ã‚°ã§ä»£æ›¿ï¼‰ */
@media (max-width:480px){
  .hud { display:none; }

/* ã•ã‚‰ã«ç‹­ã„å¹…ãªã‚‰HUDã®ç¸®å°ã‚’å¼·ã‚ã‚‹ï¼ˆHUDã‚’ä½¿ã†æ§‹æˆã®ã¾ã¾ãªã‚‰ï¼‰ */
@media (max-width:380px){
  .hud { transform: scale(.8); }
}

.bar.hp.low > i {
  background: linear-gradient(90deg,#ff5a5a,#c0392b);
}

}

/* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å¹…ã¯ HUD å³ã«ã‚¿ã‚¤ãƒãƒ¼ã¶ã‚“ã®ä½™ç™½ã‚’ç©ºã‘ã‚‹ */
@media (min-width: 768px){
  .hud{
    padding-right: 140px; /* â† ã“ã“ã§å³å´ã®ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ï¼ˆå¿…è¦ãªã‚‰160ã€œ180ã«ï¼‰ */
  }
}


.hc-badges{
  position:absolute;
  right: calc(.5rem + env(safe-area-inset-right));
  top:   calc(4.2rem + env(safe-area-inset-top)); /* ã€ŒHARDCOREã€ã®å°‘ã—ä¸‹ */
  z-index: 16;
  display: none;                 /* é€šå¸¸ã¯éè¡¨ç¤º */
  gap: .35rem;
}

/* === Hardcore badgeï¼ˆå·¦å´é…ç½®ã§ã‚¿ã‚¤ãƒãƒ¼ã¨è¢«ã‚‰ãªã„ï¼‰ === */
body[data-hc]::after{
  content:"HARDCORE";
  position: fixed;
  left: var(--hc-left);
  right: auto;
  top:   var(--hc-top);
  background:#8b5cf6; color:#fff; font-weight:700;
  padding:.2rem .5rem; border-radius:.4rem; opacity:.95;
  box-shadow:0 4px 12px rgba(139,92,246,.35);
  font-size:.85rem;
  z-index: 12005; /* â† ãƒœã‚¿ãƒ³(12010)ã‚ˆã‚Šä¸‹ã€‚ã‚¯ãƒªãƒƒã‚¯ã‚’é‚ªé­”ã—ãªã„ */
}

/* è¿½åŠ ã®æ¡ä»¶ãƒãƒƒã‚¸ã‚’å‡ºã™å ´åˆã¯ã€ãã®ã€Œã•ã‚‰ã«ä¸‹ã€ã«å›ºå®š */
.hc-badges{
  position: fixed;
  left: var(--hc-left);
  right: auto;
  top:   calc(var(--hc-top) + 32px); /* ãƒ©ãƒ™ãƒ«ã®ä¸‹ã¸ */
  z-index: 12005;
  display: none;
  gap: .35rem;
}
body[data-hc] .hc-badges{ display: flex; }
.hc-badges .badge{
  background:#231a3a;
  border:1px solid #5b2a8a;
  color:#e9d5ff;
  padding:.15rem .35rem;
  border-radius:.35rem;
  font-weight:700;
  letter-spacing:.01em;
  font-size:.8rem;
}

/* === Floating Joystick === */
#joyBase, #joyKnob{
  position:fixed; left:0; top:0; transform:translate(-50%,-50%);
  pointer-events:none; display:none; z-index: 10001; /* âŒ›ã‚„Pauseã‚ˆã‚Šå‰é¢ */
}
#joyBase{
  width:120px; height:120px; border-radius:50%;
  background: radial-gradient(closest-side, rgba(99,102,241,.25), rgba(99,102,241,.08));
  border:1px solid rgba(99,102,241,.45);
  backdrop-filter: blur(2px);
}
#joyKnob{
  width:64px; height:64px; border-radius:50%;
  background: radial-gradient(circle at 35% 35%, #fff, #c7d2fe);
  border:1px solid rgba(99,102,241,.6);
  box-shadow:0 6px 18px rgba(99,102,241,.25);
}

/* === Dock area (æƒ…å ±è¡¨ç¤ºã‚¨ãƒªã‚¢) ====================== */
#dock{
  position:absolute;
  display:none;
  background:rgba(0,0,0,.6);
  color:#fff;
  padding:8px;
  box-sizing:border-box;
  border:1px solid rgba(255,255,255,.06);
  backdrop-filter: blur(2px);
  overflow:auto;
  pointer-events: none;   /* â† ã‚¿ãƒƒãƒã‚’é€éã—ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã¸æ¸¡ã™ */
}
#dock.landscape{ border-left:1px solid rgba(255,255,255,.08); }
#dock.portrait { border-top: 1px solid rgba(255,255,255,.08); }

/* === Top HUD band ===================================== */
#hudTop{
  position:absolute;
  left:0; top:0;
  height:56px;
  width:auto;
  display:none;           /* ç¸¦å‘ãæ™‚ã®ã¿JSã§ 'block' ã«ã™ã‚‹ */
  color:#fff;
  background:rgba(0,0,0,.45);
  border-bottom:1px solid rgba(255,255,255,.08);
  box-sizing:border-box;
  padding:8px;
  backdrop-filter: blur(2px);
  pointer-events: none;   /* â† ä¸Šå¸¯ã¯æ“ä½œä¸è¦ãªã®ã§é€é */
padding-left:  var(--hud-lpad);
  padding-right: var(--hud-rpad);
  margin-top:    var(--hud-tpad);
  box-sizing:    border-box; /* å¿µã®ãŸã‚ */
  /* HUDä¸Šæ®µãŒãƒãƒƒãƒã«ã‹ã¶ã‚‰ãªã„ã‚ˆã†å®‰å…¨é ˜åŸŸåˆ†ã ã‘ä¸‹ã’ã‚‹ */
#hudTop, .hud{
  padding-top: calc(8px + var(--safe-top));
}
}

:root{
  --hc-top:   calc(44px + 8px + env(safe-area-inset-top, 0px)); /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Pause ã®ä¸‹ã‚ãŸã‚Š */
  --hc-right: auto; /* å³å´é…ç½®ã‚’è§£é™¤ */
  --hc-left:  calc(12px + env(safe-area-inset-left, 0px)); /* å·¦å´ã«é…ç½® */

  --hud-lpad: calc(env(safe-area-inset-left, 0px) + 12px);  /* å·¦ä½™ç™½ï¼ˆåˆæœŸï¼‰ */
  --hud-rpad: calc(env(safe-area-inset-right,0px) + 12px);  /* å³ä½™ç™½ï¼ˆåˆæœŸï¼‰ */
  --hud-tpad: 0px;                                          /* ä¸Šãƒãƒ¼ã‚¸ãƒ³ï¼ˆåˆæœŸï¼‰ */
  
    /* iOSç­‰ã®ãƒãƒƒãƒå®‰å…¨é ˜åŸŸã‚’CSSå¤‰æ•°åŒ– */
  --safe-top: env(safe-area-inset-top, 0px);
  --safe-right: env(safe-area-inset-right, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-left: env(safe-area-inset-left, 0px);
}

/* === LevelUp layout === */
#levelup{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:8px; padding:10px;
}
#cardRow{
  display:grid; grid-template-columns:repeat(2, 1fr); gap:8px;
  max-width:min(96vw, 800px); margin:0 auto;
}
@media (min-width:600px){ #cardRow{ grid-template-columns:repeat(4, 1fr); gap:10px; } }
#rerollBtn{
  display:block; margin:8px auto 0;
}


/* === Timer (å…±é€šãƒ™ãƒ¼ã‚¹) === */
#pcTimer{
  position: fixed;
  z-index: 12000;
  pointer-events: none;
  user-select: none;
  font-weight: 900;
  font-variant-numeric: tabular-nums;
  line-height: 1;
  letter-spacing: .04em;
  color: #fff;
  text-shadow: 0 0 18px rgba(255,255,255,.25);
  opacity: .32;
  font-size: clamp(36px, 14vw, 120px);
  background: transparent; border: 0; padding: 0;
  display: none; /* JSã§è¡¨ç¤ºåˆ‡æ›¿ */
  transform-origin: top right;
}

/* æ¨ªç”»é¢ã§ã¯ã‚¿ã‚¤ãƒãƒ¼ã‚’ç´„1/3ã‚¹ã‚±ãƒ¼ãƒ«ã¸ */
@media (orientation: landscape){
  #pcTimer{ font-size: clamp(20px, 4.8vw, 56px); }
}

/* æ¨ªå‘ãï¼ˆPC/ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå«ã‚€ï¼‰ã¯å³ä¸Šã‚¢ãƒ³ã‚«ãƒ¼ */
@media (orientation: landscape){
  #pcTimer{
    top:  calc(env(safe-area-inset-top) + 92px);
    right: calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px));
    left: auto; bottom: auto; transform: none; text-align: right;
  }
}

/* ç¸¦å‘ãã¯ä¸‹éƒ¨ä¸­å¤®ï¼ˆJSã§PLAYå¹…ã«åˆã‚ã›ã¦å¾®èª¿æ•´ï¼‰ */
@media (orientation: portrait){
  #pcTimer{
    left: 50%; right: auto; top: auto;
    bottom: calc(env(safe-area-inset-bottom) + 12px);
    transform: translateX(-50%); text-align: center;
  }
}



/* === Top-right buttons (Pause / Sound) === */
#btnPause, #btnSound{
  position: fixed; z-index: 12010;
  pointer-events: auto;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(0,0,0,.45);
  color:#fff; border-radius: 999px;
}

/* Pause ã¯â€œä¸¸ãƒœã‚¿ãƒ³â€å›ºå®šã‚µã‚¤ã‚ºï¼ˆæ¨ªé•·åŒ–ã‚’é˜²æ­¢ï¼‰ */
#btnPause{
  width: 44px; height: 44px;
  display: inline-flex; align-items: center; justify-content: center;
  font-size: 18px; line-height: 1;
}

/* Sound ã¯ãƒ©ãƒ™ãƒ«ä»˜ãã®æ¨ªé•·ã§OKï¼ˆã‚µã‚¤ã‚ºã¯ä¸­èº«ä¾å­˜ï¼‰ */
#btnSound{
  display: inline-flex; align-items: center; gap: 8px; padding: 0 12px;
}

/* ä½ç½®æŒ‡å®šã¯ JS ãŒå…¥ã‚Œã‚‹ã®ã§ top/left/right ã¯ã“ã“ã§ã¯è§¦ã‚‰ãªã„ */


/* â€”â€” ä½ç½®: ç«¯æœ«ã®å‘ãã§åˆ‡ã‚Šæ›¿ãˆ â€”â€” */
@media (orientation: landscape){
  /* æ¨ªç”»é¢ï¼šå³ä¸Šã€‚Sound ã¯ Pause ã®å·¦ã«ãšã‚‰ã™ */
  #btnPause{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 12px); left:auto; }
  #btnSound{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 64px); left:auto; }
}
@media (orientation: portrait){
  /* ç¸¦ç”»é¢ï¼šHUBã®ä¸Šã§ã€Œã®ã£ã¡ã€å·¦å³ã«é…ç½® */
  #btnPause{ top:  calc(env(safe-area-inset-top)  + 8px); left:  calc(env(safe-area-inset-left) + 12px);  right:auto; }
  #btnSound{ top:  calc(env(safe-area-inset-top)  + 8px); right: calc(env(safe-area-inset-right) + 12px); left:auto; }
}


@media (orientation: portrait){
  #btnSound{
    right: calc(env(safe-area-inset-right) + 64px);
    top:   calc(env(safe-area-inset-top) + 8px);
  }
}

#btnSound[data-muted="false"]{ box-shadow: 0 6px 16px rgba(16,185,129,.22); }
#btnSound[data-muted="true"] { box-shadow: 0 6px 16px rgba(239,68,68,.22); }

#btnSound .icon{ font-size: 16px; line-height: 1; }
#btnSound .label{ font-size: 12px; line-height: 1; opacity: .95; }
#btnSound{ z-index: 9999; /* â† ã‚¿ã‚¤ãƒãƒ¼ã‚ˆã‚Šæ‰‹å‰ */ }


#btnSound[data-muted="false"]{ background: rgba(16,185,129,.20); }
#btnSound[data-muted="true"] { background: rgba(239,68,68,.20); }
#btnSound:active{ transform: translateY(1px); }

/* å³ä¸ŠUIã®é‡ãªã‚Šå›é¿ã‚’å¼·åˆ¶ï¼šãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å¹…ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒœã‚¿ãƒ³ã®å·¦ã¸ */
@media (min-width:768px){
  #btnSound{
   right: calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px));
  }
/* èƒŒæ™¯ã‚¿ã‚¤ãƒãƒ¼ï¼šå³å¯„ã›ãƒ»å‰é¢ãƒ»ã‚¯ãƒªãƒƒã‚¯é€é */
#pcTimer{
  position: fixed;
  z-index: 12000;                            /* æœ€å‰é¢ */
  pointer-events: none; user-select: none;   /* ã‚¯ãƒªãƒƒã‚¯ã¯èƒŒé¢ã«é€šã™ */

  /* å³ä¸Šã‚¢ãƒ³ã‚«ãƒ¼ï¼ˆå¿…è¦ãªã‚‰æ•°å€¤ã ã‘èª¿æ•´ï¼‰ */
  top:  calc(env(safe-area-inset-top) + 92px);
  right: calc(env(safe-area-inset-right) + 12px);

  /* â† ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°è§£é™¤ï¼ˆå¿…é ˆï¼‰ */
  left: auto; 
  transform: none;

  /* è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
  font-weight: 900;
  font-variant-numeric: tabular-nums;
  line-height: 1;
  letter-spacing: .04em;
  text-align: right;                         /* å¿µã®ãŸã‚å³æƒãˆ */
  font-size: clamp(40px, min(12vw, 14vh), 80px);
  color: #fff;
  opacity: .32;                              /* æ¿ƒã•ã¯ .16ã€œ.22 ã§èª¿æ•´ */
  text-shadow: 0 0 18px rgba(255,255,255,.25);

  background: transparent; border: 0; padding: 0;
  display: none; /* æ¨ªå‘ãæ™‚ã¯ JS ã§ block */
}
}

</style>

<!-- PWA manifestï¼ˆå¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªãã¦ã‚‚ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§å®šç¾©ï¼‰ -->
<script>
// ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§manifestã‚’ç”Ÿæˆ
const manifestData = {
  name: "10min's Survivor",
  short_name: "10min's",
  description: "10åˆ†é–“ç”Ÿãå»¶ã³ã‚ï¼ã‚µãƒã‚¤ãƒãƒ¼ãƒ©ã‚¤ã‚¯ã‚²ãƒ¼ãƒ ",
  start_url: "./",
  display: "fullscreen",
  orientation: "landscape",
  background_color: "#0f172a",
  theme_color: "#3b82f6",
  icons: [{
    src: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230f172a' width='100' height='100' rx='20'/><text x='50' y='65' font-size='50' text-anchor='middle' fill='%2360a5fa'>10</text></svg>",
    sizes: "any",
    type: "image/svg+xml"
  }]
};
const manifestBlob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
const manifestURL = URL.createObjectURL(manifestBlob);
const link = document.createElement('link');
link.rel = 'manifest';
link.href = manifestURL;
document.head.appendChild(link);
</script>

</head>
<body>

<!-- PWAã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒãƒŠãƒ¼ï¼ˆã‚¹ãƒãƒ›ãƒ–ãƒ©ã‚¦ã‚¶ã®ã¿è¡¨ç¤ºï¼‰ -->
<div id="pwaInstallBanner" style="display:none; position:fixed; bottom:0; left:0; right:0; background:linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color:white; padding:12px 16px; z-index:10002; box-shadow:0 -2px 10px rgba(0,0,0,0.3);">
  <div style="display:flex; align-items:center; justify-content:space-between; max-width:600px; margin:0 auto;">
    <div style="flex:1;">
      <div style="font-weight:bold; font-size:14px;">ğŸ“± ãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ </div>
      <div style="font-size:12px; opacity:0.9;">ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã§å¿«é©ãƒ—ãƒ¬ã‚¤ï¼</div>
    </div>
    <div style="display:flex; gap:8px;">
      <button id="pwaInstallBtn" style="background:#fff; color:#1e40af; border:none; padding:8px 16px; border-radius:6px; font-weight:bold; font-size:13px; cursor:pointer;">è¿½åŠ ã™ã‚‹</button>
      <button id="pwaCloseBtn" style="background:transparent; color:white; border:1px solid rgba(255,255,255,0.5); padding:8px 12px; border-radius:6px; font-size:13px; cursor:pointer;">âœ•</button>
    </div>
  </div>
</div>

<script>
(function() {
  // PWAã¨ã—ã¦èµ·å‹•æ¸ˆã¿ã‹åˆ¤å®š
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches 
    || window.navigator.standalone === true;
  
  // ã‚¹ãƒãƒ›åˆ¤å®š
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  
  // PCã¾ãŸã¯PWAèµ·å‹•æ¸ˆã¿ãªã‚‰è¡¨ç¤ºã—ãªã„
  if (!isMobile || isStandalone) return;
  
  // ä¸€åº¦é–‰ã˜ãŸã‚‰24æ™‚é–“ã¯è¡¨ç¤ºã—ãªã„
  const dismissed = localStorage.getItem('pwa_banner_dismissed');
  if (dismissed && Date.now() - parseInt(dismissed) < 24 * 60 * 60 * 1000) return;
  
  const banner = document.getElementById('pwaInstallBanner');
  const installBtn = document.getElementById('pwaInstallBtn');
  const closeBtn = document.getElementById('pwaCloseBtn');
  
  // å°‘ã—é…ã‚Œã¦è¡¨ç¤º
  setTimeout(() => {
    banner.style.display = 'block';
  }, 2000);
  
  // beforeinstallprompt ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆAndroid Chromeï¼‰
  let deferredPrompt = null;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
  });
  
  installBtn.onclick = async () => {
    if (deferredPrompt) {
      // Android: ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
      deferredPrompt.prompt();
      const result = await deferredPrompt.userChoice;
      if (result.outcome === 'accepted') {
        banner.style.display = 'none';
      }
      deferredPrompt = null;
    } else {
      // iOS: æ‰‹å‹•æ‰‹é †ã‚’è¡¨ç¤º
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (isIOS) {
        alert('â‘  ç”»é¢ä¸‹ã®å…±æœ‰ãƒœã‚¿ãƒ³ï¼ˆâ–¡â†‘ï¼‰ã‚’ã‚¿ãƒƒãƒ—\nâ‘¡ ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã‚’é¸æŠ\nâ‘¢ å³ä¸Šã®ã€Œè¿½åŠ ã€ã‚’ã‚¿ãƒƒãƒ—');
      } else {
        alert('ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ã‚’é¸æŠã—ã¦ãã ã•ã„');
      }
    }
  };
  
  closeBtn.onclick = () => {
    banner.style.display = 'none';
    localStorage.setItem('pwa_banner_dismissed', Date.now().toString());
  };
})();
</script>

<div id="wrap">
<div id="start" style="display:flex; flex-direction:column; align-items:center; text-align:center; gap:.5rem;">
  <h1>10min's Survivor</h1>
  <h2>10åˆ†é–“ç”Ÿãå»¶ã³ã‚ï¼</h2>
  <p>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§èƒ½åŠ›ã‚’é¸ã³ã€ãƒœã‚¹ã‚’å€’ã—ã¦ç”Ÿå­˜ã‚’ç›®æŒ‡ã›ã€‚</p>
  
  <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ± -->
  <div style="font-size:0.85rem; color:#94a3b8; margin-top:-0.3rem;">
    <span style="opacity:0.7;">Ver 1.8.7</span> - 
    <span style="opacity:0.6; font-size:0.8rem;">æ­¦å™¨ãƒãƒ©ãƒ³ã‚¹èª¿æ•´</span>
  </div>
  
  <button id="startBtn" class="btn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  <button id="startHardcoreBtn" class="btn" style="background:#8b5cf6;">ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã§æŒ‘æˆ¦</button>
  <div style="display:flex;gap:8px;margin-top:8px;">
    <button id="rankingBtn" class="btn" style="background:#fbbf24;">ğŸ† RANKING</button>
    <button id="achievementsBtn" class="btn" style="background:#8b5cf6;">ğŸ–ï¸ å®Ÿç¸¾</button>
    <button id="updateLogBtn" class="btn" style="background:#10b981;">ğŸ“ æ›´æ–°å±¥æ­´</button>
  </div>
  <div style="margin-top:8px;">
    <button id="settingsBtn" class="btn" style="background:#64748b;">âš™ï¸ è¨­å®š</button>
  </div>
</div>
</div>

<!-- è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="settingsModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000; padding:20px; box-sizing:border-box;">
  <div style="max-width:400px; margin:3rem auto; background:#1e293b; border-radius:16px; padding:1.5rem; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5rem;">
      <h2 style="margin:0; color:#fff; font-size:1.5rem;">âš™ï¸ è¨­å®š</h2>
      <button id="closeSettings" style="background:#ef4444; color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:700;">âœ• é–‰ã˜ã‚‹</button>
    </div>
    
    <div style="margin-bottom:1.5rem;">
      <h3 style="color:#f59e0b; font-size:1rem; margin:0 0 1rem 0;">ğŸ”Š éŸ³é‡è¨­å®š</h3>
      
      <!-- BGMéŸ³é‡ -->
      <div style="margin-bottom:1rem;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
          <span style="color:#94a3b8;">BGM</span>
          <span id="settingsBgmValue" style="color:#fff; font-weight:bold;">25%</span>
        </div>
        <input type="range" id="settingsBgmVolume" min="0" max="100" value="25" style="width:100%; cursor:pointer;">
      </div>
      
      <!-- åŠ¹æœéŸ³éŸ³é‡ -->
      <div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
          <span style="color:#94a3b8;">åŠ¹æœéŸ³</span>
          <span id="settingsSfxValue" style="color:#fff; font-weight:bold;">90%</span>
        </div>
        <input type="range" id="settingsSfxVolume" min="0" max="100" value="90" style="width:100%; cursor:pointer;">
      </div>
    </div>
    
    <p style="color:#64748b; font-size:0.85rem; margin:0; text-align:center;">â€» è¨­å®šã¯ãƒ–ãƒ©ã‚¦ã‚¶ã«ä¿å­˜ã•ã‚Œã¾ã™</p>
  </div>
</div>
  
  <div id="gameover" style="display:none;">
    <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h2>
    <div class="sub">ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã‚ˆã†!</div>
    
    <!-- è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
    <div id="gameoverAchievements" style="display:none; margin:1rem 0; padding:1rem; background:rgba(102,126,234,0.15); border-radius:8px; max-width:600px;">
      <h3 style="margin:0 0 0.5rem; font-size:1.1rem; color:#a78bfa;">ğŸ–ï¸ å®Ÿç¸¾è§£é™¤ï¼</h3>
      <div id="gameoverAchievementsList" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
    </div>
    
    <div class="share-buttons">
      <button class="share-btn twitter" onclick="shareToTwitter('gameover')">
        <span>ğ•</span> Xã§ã‚·ã‚§ã‚¢
      </button>
      <button class="share-btn line" onclick="shareToLine('gameover')">
        <span>ğŸ“±</span> LINEã§é€ã‚‹
      </button>
      <button class="share-btn copy" onclick="copyShareText('gameover')">
        <span>ğŸ“‹</span> ã‚³ãƒ”ãƒ¼
      </button>
    </div>
    <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center; margin-top:1rem;">
      <button id="retryBtn" class="btn">ã‚„ã‚Šç›´ã™</button>
      <button id="titleBtnGameover" class="btn" style="background:#64748b;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
    </div>
    </div> <!-- â† ã“ã“ã§é–‰ã˜ã‚‹ -->
<!-- ã‚¯ãƒªã‚¢ç”»é¢ -->
<div id="gameclear" style="display:none;">
  <h2 style="font-size:clamp(28px,6vw,64px); margin:0 0 .75rem;">ğŸ‰ GAME CLEAR ğŸ‰</h2>
  
  <!-- è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
  <div id="clearAchievements" style="display:none; margin:1rem 0; padding:1rem; background:rgba(102,126,234,0.15); border-radius:8px; max-width:600px;">
    <h3 style="margin:0 0 0.5rem; font-size:1.1rem; color:#a78bfa;">ğŸ–ï¸ å®Ÿç¸¾è§£é™¤ï¼</h3>
    <div id="clearAchievementsList" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
  </div>
  
  <div class="share-buttons">
    <button class="share-btn twitter" onclick="shareToTwitter('clear')">
      <span>ğ•</span> Xã§ã‚·ã‚§ã‚¢
    </button>
    <button class="share-btn line" onclick="shareToLine('clear')">
      <span>ğŸ“±</span> LINEã§é€ã‚‹
    </button>
    <button class="share-btn copy" onclick="copyShareText('clear')">
      <span>ğŸ“‹</span> ã‚³ãƒ”ãƒ¼
    </button>
  </div>
  <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center; margin-top:1rem;">
    <button id="replayBtn" class="btn">ã‚‚ã†ä¸€åº¦éŠã¶</button>
    <button id="titleBtn" class="btn" style="background:#64748b;">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
    <button id="hardcoreBtn" class="btn" style="display:none;background:#8b5cf6;">Hardcoreã§å†æŒ‘æˆ¦</button>
  </div>
</div>
  
  <canvas id="cv"></canvas>
  
  <!-- æ›´æ–°å±¥æ­´ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="updateLogModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:10000; padding:20px; box-sizing:border-box; overflow-y:auto;">
    <div style="max-width:700px; margin:2rem auto; background:#1e293b; border-radius:16px; padding:2rem; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5rem;">
        <h2 style="margin:0; color:#fff; font-size:1.8rem;">ğŸ“ æ›´æ–°å±¥æ­´</h2>
        <button onclick="document.getElementById('updateLogModal').style.display='none'" style="background:#ef4444; color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:700;">é–‰ã˜ã‚‹</button>
      </div>
      
      <div style="color:#e2e8f0; line-height:1.8; font-size:0.95rem;">
        
        <!-- Ver 1.8.7 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(59,130,246,0.15); border-left:4px solid #3b82f6; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#60a5fa; font-size:1.3rem;">Ver 1.8.7 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/25</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#93c5fd;">âš–ï¸ æ­¦å™¨ãƒãƒ©ãƒ³ã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼šåŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ 36â†’32ã€Lvä¸Šæ˜‡ +30â†’+25</li>
            <li>ãƒ–ãƒ¬ãƒ¼ãƒ‰ï¼šåŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸ 60â†’52</li>
          </ul>
          
          <h4 style="margin:0.5rem 0; color:#93c5fd;">ğŸ› ãƒã‚°ä¿®æ­£</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¹ãƒ†ãƒ¼ã‚¸1ãƒ©ã‚¹ãƒœã‚¹ã®çªé€²ãŒå¿…ä¸­ã ã£ãŸå•é¡Œã‚’ä¿®æ­£</li>
            <li>ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã£ãŸå¾Œã«ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠã§ããªããªã‚‹å•é¡Œã‚’ä¿®æ­£</li>
            <li>ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã£ãŸå¾Œã«ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒè¡¨ç¤ºã•ã‚Œã‚‹å•é¡Œã‚’ä¿®æ­£</li>
            <li>ã‚„ã‚Šç›´ã™/ã‚‚ã†ä¸€åº¦éŠã¶ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆæ¼ã‚Œã‚’ä¿®æ­£</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.6 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(239,68,68,0.15); border-left:4px solid #ef4444; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#f87171; font-size:1.3rem;">Ver 1.8.6 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/25</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#fca5a5;">ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰å¼·åŒ–</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼å‡ºç¾æ•°ï¼šé€šå¸¸3/5ä½“ â†’ ãƒãƒ¼ãƒ‰ã‚³ã‚¢5/7ä½“</li>
            <li>å¤§ãƒœã‚¹ãƒ»ãƒ©ã‚¹ãƒœã‚¹ã®HPå€ç‡ï¼š1.3å€ â†’ 1.5å€</li>
          </ul>
          
          <h4 style="margin:0.5rem 0; color:#fca5a5;">â–² ã‚¹ãƒ†ãƒ¼ã‚¸2èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>å¤§ãƒœã‚¹åå°„çƒã®ã‚¹ãƒ”ãƒ¼ãƒ‰1.2å€ï¼ˆ400â†’480ï¼‰</li>
            <li>å¤§ãƒœã‚¹çªé€²ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™æ–¹å¼ã«å¤‰æ›´</li>
            <li>ã‚¹ãƒ”ãƒŠãƒ¼é«˜é€Ÿå›è»¢ä¸­ï¼šãƒ–ãƒ¬ãƒ¼ãƒ‰ãƒ»ãƒãƒ´ã‚¡ãƒ»ã‚ªãƒ¼ãƒ“ãƒƒãƒˆãƒ»ãƒã‚¤ã‚ºãƒ³ã‚‚ç„¡åŠ¹ã«</li>
            <li>ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ï¼šç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ â†’ ä¸€æ’ƒ30ãƒ€ãƒ¡ãƒ¼ã‚¸ã«å¤‰æ›´</li>
            <li>miniTriangleï¼šHP2å€ï¼ˆ16ï¼‰ã€ãƒ€ãƒ¡ãƒ¼ã‚¸10ã€çµŒé¨“å€¤ãƒ‰ãƒ­ãƒƒãƒ—ãªã—</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.5 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(59,130,246,0.15); border-left:4px solid #3b82f6; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#60a5fa; font-size:1.3rem;">Ver 1.8.5 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/25</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#93c5fd;">âš”ï¸ ãƒ–ãƒ¬ãƒ¼ãƒ‰å®Œå…¨ãƒªãƒ‹ãƒ¥ãƒ¼ã‚¢ãƒ«</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>æ–°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼šä¸»äººå…¬ä¸­å¿ƒã‹ã‚‰åŠå¾„ãŒåºƒãŒã‚‹æ–¬æ’ƒ</li>
            <li>äº¤äº’ã«é€†å‘ãã®æµã‚Œï¼‹æ”¾å°„ç·šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ</li>
            <li>3ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæç”»ã§è»½é‡åŒ–</li>
            <li>é€£æ’ƒæ•°å¤‰æ›´ï¼šLv1=2é€£æ’ƒ â†’ Lv2=4é€£æ’ƒ â†’ Lv3=6é€£æ’ƒ â†’ è¦šé†’=12é€£æ’ƒ</li>
            <li>ãƒ¬ãƒ™ãƒ«ã”ã¨ã«åŠå¾„æ‹¡å¤§ï¼š60px â†’ 90px â†’ 120px â†’ 180pxï¼ˆè¦šé†’ï¼‰</li>
            <li>CT 1.1ç§’å›ºå®šï¼ˆé€£æ’ƒãŒé•·ããªã‚‹åˆ†ã€å®Ÿè³ªCTãŒçŸ­ç¸®ï¼‰</li>
            <li>åŸºç¤ãƒ€ãƒ¡ãƒ¼ã‚¸60ï¼ˆ2é€£æ’ƒã§åˆè¨ˆ120ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.4 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(147,51,234,0.15); border-left:4px solid #9333ea; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#a855f7; font-size:1.3rem;">Ver 1.8.4 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/24</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#d8b4fe;">ğŸ‘¹ ã‚¹ãƒ†ãƒ¼ã‚¸2 ãƒ©ã‚¹ãƒœã‚¹æ¼”å‡ºå¼·åŒ–</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒœã‚¹ã®è‰²ã‚’å¼·ã„ç´«è‰²ã«å¤‰æ›´ã€ã‚ªãƒ¼ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¿½åŠ </li>
            <li>ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒï¼šã‚¹ãƒ”ãƒ¼ãƒ‰130ã€å¯¿å‘½5.5ç§’ã«èª¿æ•´</li>
            <li>å›è»¢çªé€²ã®æ¼”å‡ºæ”¹å–„ï¼š
              <ul style="margin:0.3rem 0; padding-left:1rem;">
                <li>ç‚¹æ»…â†’é«˜é€Ÿå›è»¢ã—ãªãŒã‚‰ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼†ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—ã§æ¶ˆå¤±</li>
                <li>çªé€²ä¸­ã¯ãƒœã‚¹æœ¬ä½“ã¨ãƒãƒªã‚¢ä¸‰è§’ãŒç™½ãå…‰ã‚‹</li>
                <li>ãƒãƒªã‚¢ã‚‚é«˜é€Ÿå›è»¢ã—ã¦æ¥è§¦é¢ç©UP</li>
                <li>çªé€²ã‚¹ãƒ”ãƒ¼ãƒ‰700ã«èª¿æ•´</li>
              </ul>
            </li>
            <li>å›è»¢çªé€²ä¸­ã¯ä»–ã®æ”»æ’ƒï¼ˆå…‰çƒãƒ»çˆ†æ’ƒãƒ»æŸ±ãƒ»å›è»¢å¼¾å¹•ï¼‰ã‚’ç™ºå‹•ã—ãªã„</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.3 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(239,68,68,0.15); border-left:4px solid #ef4444; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#f87171; font-size:1.3rem;">Ver 1.8.3 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/24</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#fecaca;">ğŸ® UIæ”¹å–„</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã£ãŸæ™‚ã®ãƒªã‚»ãƒƒãƒˆå‡¦ç†ã‚’æ”¹å–„</li>
            <li>ä¸€æ™‚åœæ­¢ãƒœã‚¿ãƒ³ã¯ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã®ã¿è¡¨ç¤º</li>
            <li>ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºã®ç„¡é™ãƒ«ãƒ¼ãƒ—ãƒã‚°ã‚’ä¿®æ­£</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fecaca;">ğŸ‘¹ ã‚¹ãƒ†ãƒ¼ã‚¸2 å¤§ãƒœã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ä½“å½“ãŸã‚ŠãŒä¸»äººå…¬ã‚’æ­£ç¢ºã«è¿½å°¾ã™ã‚‹ã‚ˆã†ã«æ”¹å–„</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fecaca;">ğŸ‘¹ ã‚¹ãƒ†ãƒ¼ã‚¸2 ãƒ©ã‚¹ãƒœã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒï¼šã‚ªãƒ¼ãƒ“ãƒƒãƒˆã§æ¶ˆãˆãªã„ã€ã‚¹ãƒ”ãƒ¼ãƒ‰æ§ãˆã‚ã«èª¿æ•´</li>
            <li>çˆ†æ’ƒæ”»æ’ƒï¼šé‡ãªã‚‰ãªã„ã‚ˆã†åˆ†æ•£é…ç½®ã«æ”¹å–„</li>
            <li>å›è»¢çªé€²ï¼š2ç§’ã®ç‚¹æ»…äºˆå‘Šâ†’ç”»é¢å¤–ã‹ã‚‰çªé€²â†’ç”»é¢å†…ã§åœæ­¢</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fecaca;">âš”ï¸ æ•µèª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’2å€ã«å¢—åŠ ï¼ˆ20â†’40/ç§’ï¼‰</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.2 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(99,102,241,0.15); border-left:4px solid #6366f1; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#818cf8; font-size:1.3rem;">Ver 1.8.2 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/24</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#c7d2fe;">â¸ ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼è¿½åŠ </h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ä¸€æ™‚åœæ­¢ä¸­ã«æ‰€æŒæ­¦å™¨ãƒ»èƒ½åŠ›å¼·åŒ–ã®ä¸€è¦§ã‚’è¡¨ç¤º</li>
            <li>ã€Œã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã§å†é–‹</li>
            <li>ã€Œãƒªã‚¿ã‚¤ã‚¢ã€ãƒœã‚¿ãƒ³ã§ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ‰±ã„ï¼‰</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.1 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(16,185,129,0.15); border-left:4px solid #10b981; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#10b981; font-size:1.3rem;">Ver 1.8.1 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/24</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#a7f3d0;">ğŸ”Š éŸ³å£°ãƒã‚°ä¿®æ­£</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>èµ·å‹•æ™‚ã«å¸¸ã«éŸ³å£°ONã§é–‹å§‹ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£</li>
            <li>ä»¥å‰ã®ãƒŸãƒ¥ãƒ¼ãƒˆè¨­å®šãŒæ®‹ã£ã¦BGMãŒé³´ã‚‰ãªã„å•é¡Œã‚’è§£æ¶ˆ</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#a7f3d0;">ğŸ ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹æ”¹å–„</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>æ­¦å™¨ã®ã¿6ç¨®é¡ã‹ã‚‰é¸æŠã™ã‚‹ä»•æ§˜ã«å¤‰æ›´</li>
            <li>é¸æŠä¸­ã«ã‚²ãƒ¼ãƒ ãŒå‹•ã„ã¦ã—ã¾ã†ãƒã‚°ã‚’ä¿®æ­£</li>
          </ul>
        </div>
        
        <!-- Ver 1.8.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(251,191,36,0.15); border-left:4px solid #fbbf24; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#fbbf24; font-size:1.3rem;">Ver 1.8.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/24</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#fef3c7;">ğŸ ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>é€šå¸¸ãƒ¢ãƒ¼ãƒ‰é–‹å§‹æ™‚ã«6ç¨®é¡ã‹ã‚‰èƒ½åŠ›ã‚’1ã¤é¸æŠå¯èƒ½</li>
            <li>ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ã§ã¯ç„¡åŠ¹ï¼ˆãƒãƒ£ãƒ¬ãƒ³ã‚¸æ€§ç¶­æŒï¼‰</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fef3c7;">ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ”¹å–„</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¹ãƒ†ãƒ¼ã‚¸1ã¨ã‚¹ãƒ†ãƒ¼ã‚¸2ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’åˆ†é›¢</li>
            <li>ã‚¿ãƒ–ã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«</li>
            <li>CLOSEãƒœã‚¿ãƒ³ã‚’ä¸Šéƒ¨ã«é…ç½®ï¼ˆã‚¹ãƒãƒ›ã§æŠ¼ã—ã‚„ã™ãï¼‰</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fef3c7;">âš–ï¸ é›£æ˜“åº¦èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸHP: 110â†’120</li>
            <li>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸé€Ÿåº¦: 170â†’180</li>
            <li>ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼åˆæœŸæ”»æ’ƒåŠ›: 12â†’15</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fef3c7;">ğŸ“¡ ãƒ¬ãƒ¼ã‚¶ãƒ¼èª¬æ˜æ–‡è¿½åŠ </h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>å…¥æ‰‹æ™‚ãƒ»å¼·åŒ–æ™‚ãƒ»è¦šé†’æ™‚ã®èª¬æ˜ã‚’å®Œå‚™</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fef3c7;">ğŸ“± PWAå¯¾å¿œ</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¹ãƒãƒ›ãƒ–ãƒ©ã‚¦ã‚¶ã§ã€Œãƒ›ãƒ¼ãƒ ç”»é¢ã«è¿½åŠ ã€ãƒãƒŠãƒ¼è¡¨ç¤º</li>
            <li>PWAã¨ã—ã¦èµ·å‹•ã§ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ—ãƒ¬ã‚¤å¯èƒ½</li>
          </ul>
        </div>
        
        <!-- Ver 1.6 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(236,72,153,0.15); border-left:4px solid #ec4899; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#f472b6; font-size:1.3rem;">Ver 1.6 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/23</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#fbcfe8;">ğŸ‘¹ ã‚¹ãƒ†ãƒ¼ã‚¸2 ãƒ©ã‚¹ãƒœã‚¹å¤§æ”¹ä¿®</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚µã‚¤ã‚º2å€ã«å·¨å¤§åŒ–ã€HP40%å‰Šæ¸›ã§ã‚¹ãƒ”ãƒ¼ãƒ‰æ„ŸUP</li>
            <li>æ˜ã‚‹ã„ãƒã‚¼ãƒ³ã‚¿ã‚«ãƒ©ãƒ¼ã§è¦–èªæ€§å‘ä¸Š</li>
            <li>æ–°æ”»æ’ƒã€Œãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒã€ï¼šãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘ã«3ç™ºã€ã‚†ã£ãã‚Šè¿½å°¾</li>
            <li>æ–°æ”»æ’ƒã€Œå›è»¢å¼¾å¹•ã€ï¼šé«˜é€Ÿå›è»¢ã—ãªãŒã‚‰å¤§é‡ã®å¼¾ã‚’ã°ã‚‰æ’’ã</li>
            <li>æ–°æ”»æ’ƒã€ŒæŸ±é£›ã°ã—ã€ï¼šæŸ±ãŒå…‰ã‚Šã€çŸ¢å°ã§æ–¹å‘ã‚’äºˆå‘Šã—ã¦é£›ã‚“ã§ãã‚‹</li>
            <li>çˆ†æ’ƒ15ç®‡æ‰€ã«å¢—åŠ ã€ã‚·ãƒ¼ãƒ«ãƒ‰å›è»¢é«˜é€ŸåŒ–</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fbcfe8;">ğŸ“¡ ãƒ¬ãƒ¼ã‚¶ãƒ¼è¦šé†’å¼·åŒ–</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>è¦šé†’æ™‚ï¼š0.8ç§’é–“ç¶™ç¶šç…§å°„ã§æ•µã‚’ç„¼ãå°½ãã™</li>
            <li>ç…§å°„ä¸­ã¯æ•µã‚’è‡ªå‹•è¿½å°¾</li>
            <li>åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸2å€ã€ãƒ¬ãƒ™ãƒ«ãƒœãƒ¼ãƒŠã‚¹å¤§å¹…å¢—åŠ </li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fbcfe8;">ğŸ® UIæ”¹å–„</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—é¸æŠè‚¢ï¼š3æŠâ†’4æŠã«å¢—åŠ </li>
            <li>å®ç®±é¸æŠè‚¢ï¼š5æŠâ†’6æŠã«å¢—åŠ </li>
            <li>ã‚¹ãƒãƒ›ã§ã‚‚ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã‚„ã™ã„ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«æœ€é©åŒ–</li>
            <li>ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠã¸ã®å°ç·šæ”¹å–„</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#fbcfe8;">âš”ï¸ ãã®ä»–ãƒãƒ©ãƒ³ã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒãƒ´ã‚¡è¦šé†’ã‚ªãƒ¼ãƒ©ãƒ€ãƒ¡ãƒ¼ã‚¸1.5å€</li>
            <li>ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã®è‰²ã‚’è–„ã„é»„è‰²ã«å¤‰æ›´</li>
            <li>ã‚¹ãƒ”ãƒŠãƒ¼ãŒä½é »åº¦ã§å¼¾ã‚’ç™ºå°„ã™ã‚‹ã‚ˆã†ã«</li>
            <li>ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ã®è­¦å‘Šé‡è¤‡ãƒã‚°ä¿®æ­£</li>
          </ul>
        </div>
        
        <!-- Ver 1.5.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(168,85,247,0.1); border-left:4px solid #a855f7; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#c084fc; font-size:1.3rem;">Ver 1.5.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/22</span></h3>
          
          <h4 style="margin:0.5rem 0; color:#e9d5ff;">âš”ï¸ æ­¦å™¨ãƒãƒ©ãƒ³ã‚¹å¤§å¹…èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ï¼šå¨åŠ›1.4å€ã€å¼¾é€Ÿ1.2å€ã«å¼·åŒ–</li>
            <li>ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ï¼šå¨åŠ›1.8å€ã«å¼·åŒ–ï¼ˆè¿‘è·é›¢æœ€å¼·ã«ï¼‰</li>
            <li>ãƒ–ãƒ¬ãƒ¼ãƒ‰ï¼šå¨åŠ›1.5å€ã€ã‚¹ã‚¿ãƒ³æ™‚é–“1.5å€ã«å¼·åŒ–</li>
            <li>ãƒã‚¤ã‚ºãƒ³ï¼šéˆè¶³åŠ¹æœå¼·åŒ–ï¼ˆ45%â†’60%æ¸›é€Ÿï¼‰</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#e9d5ff;">ğŸ›¡ï¸ æ–°èƒ½åŠ›è¿½åŠ </h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>è€ä¹…åŠ›ã‚¢ãƒƒãƒ—ï¼ˆå…¨5æ®µéšï¼‰ï¼šå—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æœ€å¤§30%è»½æ¸›</li>
            <li>é˜²å¾¡ç‰¹åŒ–ãƒ“ãƒ«ãƒ‰ãŒå¯èƒ½ã«</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#e9d5ff;">ğŸ å®ç®±ãƒ‘ã‚¹æ©Ÿèƒ½</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>å®ç®±ã§ã‚‚ã€Œãƒ‘ã‚¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ï¼ˆç¸›ã‚Šãƒ—ãƒ¬ã‚¤å®Œå…¨å¯¾å¿œï¼‰</li>
            <li>ãƒ‘ã‚¹ãƒœãƒ¼ãƒŠã‚¹ï¼š+3,000ç‚¹</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#e9d5ff;">ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢é›£æ˜“åº¦èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>æ•µã®æ”»æ’ƒåŠ›ï¼š1.3å€â†’1.5å€ã«æˆ»ã™</li>
            <li>è€ä¹…åŠ›è»½æ¸›ï¼šæœ€å¤§40%â†’30%ã«èª¿æ•´</li>
            <li>é©æ­£ãªé›£æ˜“åº¦ãƒãƒ©ãƒ³ã‚¹ã«</li>
          </ul>
        </div>
        
        <!-- Ver 1.4.1 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(14,165,233,0.1); border-left:4px solid #0ea5e9; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#38bdf8; font-size:1.3rem;">Ver 1.4.1 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/22</span></h3>
          <h4 style="margin:0.5rem 0; color:#7dd3fc;">âš–ï¸ ãƒãƒ¼ãƒ‰ã‚³ã‚¢é›£æ˜“åº¦èª¿æ•´ï¼‹BGMä¿®æ­£</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>çµŒé¨“å€¤æ¸›å°‘ãƒšãƒŠãƒ«ãƒ†ã‚£ã‚’å‰Šé™¤ï¼ˆ0.75å€â†’1.0å€ï¼‰</li>
            <li>æ•µã®æ”»æ’ƒåŠ›ã‚’å‰Šæ¸›ï¼ˆ1.5å€â†’1.3å€ï¼‰</li>
            <li>ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ã§BGMãŒå†ç”Ÿã•ã‚Œãªã„ãƒã‚°ä¿®æ­£</li>
            <li>ã‚ˆã‚Šé©æ­£ãªé›£æ˜“åº¦ã«èª¿æ•´</li>
          </ul>
        </div>
        
        <!-- Ver 1.4.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(16,185,129,0.1); border-left:4px solid #10b981; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#10b981; font-size:1.3rem;">Ver 1.4.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/22</span></h3>
          <h4 style="margin:0.5rem 0; color:#a7f3d0;">ğŸ¯ å‡ºç¾äºˆå‘Šã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒœãƒ æ•µãƒ»ãƒ¯ãƒ¼ãƒ—æ•µã®å‡ºç¾å‰ã«äºˆå‘Šãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º</li>
            <li>çªç„¶å‡ºç¾ã«ã‚ˆã‚‹ç†ä¸å°½ãªæ­»ã‚’è§£æ¶ˆ</li>
            <li>äºˆå‘Šæ™‚é–“ï¼šãƒœãƒ 0.8ç§’ã€ãƒ¯ãƒ¼ãƒ—0.6ç§’</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#a7f3d0;">âš–ï¸ é›£æ˜“åº¦ãƒãƒ©ãƒ³ã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ¬ãƒ¼ã‚¶ãƒ¼äºˆå‘Šæ™‚é–“å»¶é•·ï¼ˆ0.6ç§’â†’1.0ç§’ï¼‰</li>
            <li>ãƒãƒ¼ãƒ‰ã‚³ã‚¢æ•µã®è‡ªå‹•å›å¾©ã‚’å‰Šé™¤</li>
            <li>ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒœã‚¹HPå€ç‡å‰Šæ¸›ï¼ˆ1.5å€â†’1.3å€ï¼‰</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#a7f3d0;">ğŸ–ï¸ UIæ”¹å–„</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ã‚¯ãƒªã‚¢ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã«è§£é™¤ã—ãŸå®Ÿç¸¾ã‚’è¡¨ç¤º</li>
            <li>å®Ÿç¸¾ã®ãƒ†ã‚£ã‚¢ã‚«ãƒ©ãƒ¼è¡¨ç¤º</li>
          </ul>
        </div>
        
        <!-- Ver 1.3.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(139,92,246,0.1); border-left:4px solid #8b5cf6; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#a78bfa; font-size:1.3rem;">Ver 1.3.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/21</span></h3>
          <h4 style="margin:0.5rem 0; color:#c4b5fd;">ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰å¼·åŒ–</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>æ•µHPï¼š2å€</li>
            <li>æ•µã®æ•°ï¼š1.5å€</li>
            <li>æ•µã®æ”»æ’ƒåŠ›ï¼š1.5å€</li>
            <li>æ•µã®æ”»æ’ƒé »åº¦ï¼š2å€</li>
            <li>ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‹ã‚‰é¸æŠå¯èƒ½ã«</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#c4b5fd;">âš”ï¸ æ­¦å™¨ãƒãƒ©ãƒ³ã‚¹èª¿æ•´</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆï¼šãƒ€ãƒ¡ãƒ¼ã‚¸æ¸›å°‘ã€çƒæ•°èª¿æ•´</li>
            <li>ãƒ­ãƒƒã‚¯ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸0.55å€ã«æ¸›å°‘</li>
          </ul>
          
          <h4 style="margin:0.8rem 0 0.3rem; color:#c4b5fd;">ğŸ® æ–°æ©Ÿèƒ½</h4>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã«èƒ½åŠ›ã‚’ã¨ã‚‰ãªã„é¸æŠè‚¢ï¼ˆç¸›ã‚Šãƒ—ãƒ¬ã‚¤ç”¨ï¼‰</li>
            <li>ã‚¹ã‚­ãƒƒãƒ—ãƒœãƒ¼ãƒŠã‚¹ï¼š+5,000ç‚¹</li>
          </ul>
        </div>
        
        <!-- Ver 1.2.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(251,191,36,0.1); border-left:4px solid #fbbf24; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#fbbf24; font-size:1.3rem;">Ver 1.2.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/20</span></h3>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>æ­¦å™¨èª¬æ˜æ–‡ã‚’è¿½åŠ ï¼ˆå…¨11æ­¦å™¨ï¼‰</li>
            <li>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã®èª¬æ˜ã‚’å¼·åŒ–</li>
            <li>è¦šé†’æ™‚ã®ç‰¹åˆ¥åŠ¹æœèª¬æ˜</li>
          </ul>
        </div>
        
        <!-- Ver 1.1.0 -->
        <div style="margin-bottom:2rem; padding:1rem; background:rgba(59,130,246,0.1); border-left:4px solid #3b82f6; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#60a5fa; font-size:1.3rem;">Ver 1.1.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/19</span></h3>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>SNSå…±æœ‰æ©Ÿèƒ½å®Ÿè£…ï¼ˆX/LINE/ã‚³ãƒ”ãƒ¼ï¼‰</li>
            <li>ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ </li>
            <li>å®Ÿç¸¾ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ50ç¨®é¡ä»¥ä¸Šï¼‰</li>
          </ul>
        </div>
        
        <!-- Ver 1.0.0 -->
        <div style="padding:1rem; background:rgba(100,116,139,0.1); border-left:4px solid #64748b; border-radius:8px;">
          <h3 style="margin:0 0 0.5rem; color:#94a3b8; font-size:1.3rem;">Ver 1.0.0 <span style="font-size:0.8rem; opacity:0.7;">- 2024/12/18</span></h3>
          <ul style="margin:0.5rem 0; padding-left:1.5rem;">
            <li>åˆå›ãƒªãƒªãƒ¼ã‚¹</li>
            <li>11ç¨®é¡ã®æ­¦å™¨ã‚·ã‚¹ãƒ†ãƒ </li>
            <li>ãƒœã‚¹æˆ¦ã‚·ã‚¹ãƒ†ãƒ </li>
            <li>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ </li>
          </ul>
        </div>
        
      </div>
    </div>
  </div>
  
  <!-- ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="stageSelectModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10000; padding:20px; box-sizing:border-box; overflow-y:auto;">
    <div style="max-width:800px; margin:2rem auto; background:#1e293b; border-radius:16px; padding:2rem; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1.5rem;">
        <h2 style="margin:0; color:#fff; font-size:1.8rem;">â–² ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠ</h2>
        <button id="closeStageSelect" style="background:#ef4444; color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:700;">é–‰ã˜ã‚‹</button>
      </div>
      
      <div id="stageCards" style="display:flex; flex-direction:column; gap:1rem;">
        <!-- ã‚¹ãƒ†ãƒ¼ã‚¸ã‚«ãƒ¼ãƒ‰ãŒJSã§ç”Ÿæˆã•ã‚Œã‚‹ -->
      </div>
    </div>
  </div>
  
  <!-- ä¸Šéƒ¨HUDï¼ˆãƒ—ãƒ¬ã‚¤é ˜åŸŸã«è¢«ã›ãšä¸Šã«å›ºå®šï¼‰ -->
<div id="hudTop" aria-label="top hud"></div>
  <!-- æƒ…å ±ãƒ‰ãƒƒã‚¯ï¼ˆæ¨ªé•·: å³ / ç¸¦é•·: ä¸‹ï¼‰-->
<div id="dock" aria-label="info dock"></div>

  
  <div class="hud">
    <!-- â–¼ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’è¿½åŠ  -->
  <div id="scoreHud" style="font-weight:700; margin:4px 0;">
    SCORE: <span id="scoreVal">0</span>
  </div>
    <span class="badge">Lv <b id="lv">1</b></span>
    <div class="bar hp"><i id="hpw"></i></div>
    <span id="hpval" class="hpval"></span>   <!-- â˜… è¿½åŠ  -->
    <div class="bar xp"><i id="xpw"></i></div>
    <span class="badge">æ­¦å™¨: <b id="wep">-</b></span>
  </div>
  <!-- â¸/â–¶ ãƒœã‚¿ãƒ³ï¼ˆ.hud ã®å¤–ï¼ï¼‰ -->
  <button id="btnPause" class="hud-btn" aria-label="Pause">â¸</button>
  <div id="levelup"><div id="cardRow"></div></div>
  <div id="chest"><div id="chestRow"></div></div>
  <div class="chestHUD" id="chestHUD">
    <span class="badge">å®ç®±ï¼š<b id="pickLeft">2</b>ã¤é¸æŠ</span>
    <button id="chestPassBtn" class="passBtn" style="margin-left:auto;">âœ–ï¸ ãƒ‘ã‚¹</button>
  </div>
  </div>

<!-- removed: duplicate boss approaching -->
<!-- <div id="bossmsg">!! BOSS APPROACHING !!</div> -->
<!-- removed: legacy gather HUD -->
<!-- <div id="gather"><div class="box"><h3>çµŒé¨“å€¤ã‚’é›†ã‚ã¦ã„ã¾ã™</h3><div class="bar xp" style="width:260px;margin:auto;"><i id="gbar"></i></div></div></div> -->


</div>

<script>
// ===== ç”»é¢ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
function showErrorBanner(msg){
  let el = document.getElementById('errBanner');
  if(!el){
    el = document.createElement('div');
    el.id = 'errBanner';
    el.style.cssText = 'position:fixed;left:0;right:0;top:0;z-index:99999;background:#b00020;color:#fff;padding:.5rem 1rem;font:14px/1.4 system-ui;white-space:pre-wrap';
    document.body.appendChild(el);
  }
  el.textContent = 'âš  ' + msg;
}
// window.onerror ã§æœªæ•æ‰ã‚¨ãƒ©ãƒ¼ã‚’ãƒãƒŠãƒ¼è¡¨ç¤º
window.onerror = function(message, source, lineno, colno, error){
  showErrorBanner(`${message} @ ${source}:${lineno}:${colno}`);
};
// unhandledrejection ã‚‚æ•ã¾ãˆã‚‹
window.addEventListener('unhandledrejection', e=>{
  showErrorBanner('UnhandledPromiseRejection: ' + (e.reason && (e.reason.stack || e.reason.message || e.reason)));
});

// ===== JavaScript å…¨æ–‡ï¼ˆä¿®æ­£ç‰ˆé©ç”¨æ¸ˆã¿ï¼‰ =====
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  let W=0,H=0,DPR=1;

// === Sound toggle persistence ===
const SND_KEY = 'sndMuted';

function loadSavedMute(){
  try { return localStorage.getItem(SND_KEY) === '1'; }
  catch(_){ return false; }
}

function saveMute(m){
  try { localStorage.setItem(SND_KEY, m ? '1' : '0'); }
  catch(_){}
}

// === Global audio mute flag (BGM/SFX å…±é€šã§ä½¿ãˆã‚‹) ===
window.AUDIO_MUTED = !!window.AUDIO_MUTED; // æœªå®šç¾©ãªã‚‰ false ã§åˆæœŸåŒ–

// === Audio Core =========================================================

// === Audio Unlock (desktop autoplayå¯¾ç­–ãƒ»ä¸€åº¦ã ã‘) =======================
(function(){
  let done = false;
  function unlock(){
    if (done) return; done = true;
    try{
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();
      // ã™ã§ã«BGMãŒèª­ã‚ã¦ã„ã¦ãƒŸãƒ¥ãƒ¼ãƒˆã§ãªã‘ã‚Œã°å†ç”Ÿ
      if (window.bgm && bgm.isReady && bgm.isReady() && !window.AUDIO_MUTED){
        const p = bgm.play(); if (p && p.catch) p.catch(()=>{});
      }
    }catch(_){}
    ['pointerdown','keydown','touchstart','visibilitychange']
      .forEach(ev=>window.removeEventListener(ev, unlock, true));
  }
  ['pointerdown','keydown','touchstart','visibilitychange']
    .forEach(ev=>window.addEventListener(ev, unlock, true));
})();


// === BGM (file-based, loop, SOUNDã«é€£å‹•) ================================
(function(){
  function AC_(){
    if (!window.AC && typeof initAudioOnce === 'function') initAudioOnce();
    return window.AC;
  }
  const BG = { el:null, node:null, gain:null, vol:0.09, ready:false };

  window.bgm = {
    load(url){
      const AC = AC_(); if (!AC) return;
      if (!BG.el){
        BG.el = new Audio();
        BG.el.loop = true;
        BG.el.preload = 'auto';
        // file:/// ç›´é–‹ãã§ã‚‚OKã€‚ã‚µãƒ¼ãƒé…ä¿¡æ™‚ã¯ crossOrigin ã¤ã‘ã¦ã‚‚ã‚ˆã„
        BG.node = AC.createMediaElementSource(BG.el);
        BG.gain = AC.createGain();
        BG.gain.gain.value = (window.AUDIO_MUTED ? 0 : BG.vol);
        const dest = (window.bus && (bus.music || bus.master)) ? (bus.music || bus.master) : AC.destination;
        BG.node.connect(BG.gain).connect(dest);
        BG.el.addEventListener('canplay', ()=> BG.ready = true);
      }
      BG.el.src = url;
    },
    play(){ try{ BG.el && BG.el.play(); }catch(_){ /* autoplayè¦åˆ¶ã¯StartæŠ¼ä¸‹ã§å›é¿ */ } },
    pause(){ BG.el && BG.el.pause(); },
    setVolume(v){ BG.vol = v; if (BG.gain) BG.gain.gain.value = (window.AUDIO_MUTED ? 0 : v); },
    isReady(){ return !!BG.ready; }
  };
})();


(function(){
  // æ—¢ã«ã‚ã‚Œã°ä½¿ã†ï¼ˆå†å®£è¨€ã—ãªã„ï¼‰
  if (!window.AC) {
    window.AC = null; // AudioContext
  }
  if (!window.bus) {
    window.bus = { master:null, bgm:null, sfx:null, ui:null };
  }
  if (typeof window.AUDIO_MUTED === 'undefined') {
    window.AUDIO_MUTED = false; // æ—¢å­˜ãŒã‚ã‚Œã°ãã®ã¾ã¾
  }

  function initAudioOnce(){
    try{
      if (!window.AC) window.AC = new (window.AudioContext || window.webkitAudioContext)();
      const AC = window.AC;
      if (!bus.master){
        bus.master = AC.createGain();
        bus.master.gain.value = window.AUDIO_MUTED ? 0.0001 : 1.0;
        bus.master.connect(AC.destination);

        // ä¿å­˜ã•ã‚ŒãŸéŸ³é‡ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: BGM 25%, SFX 90%ï¼‰
        let bgmVol = 0.25, sfxVol = 0.9;
        try {
          const savedBgm = localStorage.getItem('bgmVolume');
          const savedSfx = localStorage.getItem('sfxVolume');
          if (savedBgm !== null) bgmVol = savedBgm / 100;
          if (savedSfx !== null) sfxVol = savedSfx / 100;
        } catch(e){}

        bus.bgm = AC.createGain();  bus.bgm.gain.value = bgmVol; bus.bgm.connect(bus.master);
        bus.sfx = AC.createGain();  bus.sfx.gain.value = sfxVol;  bus.sfx.connect(bus.master);
        bus.ui  = AC.createGain();  bus.ui.gain.value  = sfxVol * 0.9;  bus.ui.connect(bus.master);
      }
    }catch(e){ console.warn('Audio init failed', e); }
  }
  window.initAudioOnce = initAudioOnce;

  // æ—¢å­˜ã®ãƒŸãƒ¥ãƒ¼ãƒˆé–¢æ•°ãŒã‚ã‚Œã°ãã“ã«ãƒ•ãƒƒã‚¯ã€ç„¡ã‘ã‚Œã°å®šç¾©
  const _origSetAudioMuted = window.setAudioMuted;
  window.setAudioMuted = function(m){
    window.AUDIO_MUTED = !!m;
    if (typeof _origSetAudioMuted === 'function') {
      try{ _origSetAudioMuted(m); }catch(e){}
    }
    if (!window.AC) return;
    const now = AC.currentTime;
    if (bus.master) bus.master.gain.setTargetAtTime(m ? 0.0001 : 1.0, now, 0.03);
  };

  // åˆå›ã‚¿ãƒƒãƒ—/ã‚­ãƒ¼ã§Audioã‚’è§£éŒ 
  function unlock(){
    initAudioOnce();
    if (window.AC && AC.state === 'suspended') AC.resume();
    document.removeEventListener('pointerdown', unlock, {passive:true});
    document.removeEventListener('keydown', unlock, {passive:true});
  }
  document.addEventListener('pointerdown', unlock, {passive:true});
  document.addEventListener('keydown', unlock, {passive:true});
})();

// èµ·å‹•æ™‚ã¯å¸¸ã«éŸ³å£°ONã§é–‹å§‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«ãƒŸãƒ¥ãƒ¼ãƒˆã«ã—ãŸå ´åˆã®ã¿æ¶ˆéŸ³ï¼‰
(()=>{
  // localStorageã®ä¿å­˜å€¤ã¯ç„¡è¦–ã—ã€å¸¸ã«ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤ã§é–‹å§‹
  if (typeof window.setAudioMuted === 'function') setAudioMuted(false);
  else window.AUDIO_MUTED = false;
})();


// ==== SFX: Slash Whoosh ===================================
(function(){
  // æ—¢å­˜ã® AC / bus ã‚’ä½¿ã†ï¼ˆç„¡ã‘ã‚Œã°ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  const AC_ = ()=> window.AC || (window.initAudioOnce && initAudioOnce(), window.AC);
  function getBus(){
    const AC = AC_();
    if (!AC) return null;
    // sfx ãƒã‚¹ï¼ˆç„¡ã‘ã‚Œã° master ã«ï¼‰
    const bus = (window.bus && (bus.sfx || bus.master)) ? window.bus : null;
    return bus ? (bus.sfx || bus.master) : AC.destination;
  }

  // å…±æœ‰ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡
  let _noiseBuf = null;
  function noiseBuf(){
    const AC = AC_(); if (!AC) return null;
    if (_noiseBuf) return _noiseBuf;
    const len = Math.floor(AC.sampleRate * 1.0);
    const buf = AC.createBuffer(1, len, AC.sampleRate);
    const ch  = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = Math.random()*2 - 1;
    _noiseBuf = buf; return buf;
  }

  // é¢¨åˆ‡ã‚ŠéŸ³ï¼šé€£æ’ƒç•ªå· idx ã«å¿œã˜ã¦å°‘ã—å¼·ã/é•·ã
  function playSlashWhoosh(idx=0){
    if (window.AUDIO_MUTED) return;
    const AC = AC_(); const dest = getBus(); const buf = noiseBuf();
    if (!AC || !dest || !buf) return;

    const t0   = AC.currentTime;
    const dur  = 0.10 + 0.02*idx;          // 2ç™ºç›®ä»¥é™ã¯ã»ã‚“ã®å°‘ã—é•·ã„
    const peak = 0.20 + 0.06*idx;          // 2ç™ºç›®ä»¥é™ã¯æ°—æŒã¡å¤§ãã„

    const src = new AudioBufferSourceNode(AC, {buffer: buf, loop:false});
    const hp  = new BiquadFilterNode(AC, {type:'highpass', frequency:500});
    const bp  = new BiquadFilterNode(AC, {type:'bandpass', Q:0.7, frequency:1400+200*idx});
    const gn  = new GainNode(AC, {gain:0});

    src.connect(hp).connect(bp).connect(gn).connect(dest);

    // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆæ°—æŒã¡ç«‹ã¡ä¸ŠãŒã£ã¦ã‚¹ãƒƒã¨æ¶ˆãˆã‚‹ï¼‰
    gn.gain.setValueAtTime(0.0001, t0);
    gn.gain.linearRampToValueAtTime(peak, t0 + 0.02);
    gn.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    // ãƒ•ã‚£ãƒ«ã‚¿å‘¨æ³¢æ•°ã‚’è»½ãã‚¹ã‚¤ãƒ¼ãƒ—ï¼ˆã‚¹ãƒ‘ãƒƒã¨åˆ‡ã‚‹è³ªæ„Ÿï¼‰
    bp.frequency.setValueAtTime(1400+200*idx, t0);
    bp.frequency.exponentialRampToValueAtTime(7000, t0 + Math.min(0.08+0.01*idx, dur));

    try{ src.start(t0); src.stop(t0 + dur + 0.02); }catch(_){}
  }

  // sfx åå‰ç©ºé–“ã«å…¬é–‹
  window.sfx = window.sfx || {};
  window.sfx.slash = playSlashWhoosh;
})();


// HUD ã‚’é¿ã‘ã¦ Pause/SOUND ã®ä½ç½®ã‚’æ±ºã‚ã‚‹ï¼ˆç¸¦=HUBã®ä¸Š, æ¨ª=å³ä¸Šã§ç¸¦ç©ã¿ï¼‰
function layoutTopRightUI(){
  const pause = document.getElementById('btnPause');
  const sound = document.getElementById('btnSound');
  if (!pause || !sound) return;

  // ä»£è¡¨çš„ãªHUDï¼ˆãªã‘ã‚Œã° null ã§ã‚‚OKï¼‰
  const hud = document.querySelector('#hudTop, #hud, #hub, .hud, .hub');

  const isVisible = el => !!el && el.offsetParent !== null && getComputedStyle(el).display !== 'none';
  const isPortrait = window.matchMedia && window.matchMedia('(orientation: portrait)').matches;

  const BTN  = 44;      // Pauseã®ç›´å¾„
  const GAP  = 8;       // ä½™ç™½
  const SAFE = 8;       // ç”»é¢ç«¯ã®ãƒ™ãƒ¼ã‚¹ä½™ç™½

  // â€”â€” ä¸Šç«¯ä½ç½®ã®æ±ºå®š â€”â€”
  let topPx = SAFE;     // æ—¢å®šï¼ˆHUBãŒç„¡ã„ãªã©ï¼‰
  if (isVisible(hud)) {
    const r = hud.getBoundingClientRect();
    if (isPortrait) {
      // â˜… ç¸¦ï¼šHUBã®â€œä¸Šâ€ã«ç½®ãï¼ˆã®ã£ã¡ã‚’è€ƒæ…®ã—ã¦å°‘ã—ä¸Šå¯„ã›ï¼‰
      topPx = Math.max(SAFE, Math.round(r.top) - (BTN + GAP));
    } else {
      // â˜… æ¨ªï¼šå¸¸ã«ä¸Šç«¯ã«å¯„ã›ã‚‹ï¼ˆHUBã¨ã¯ç¸¦ã«åˆ†ã‘ã‚‹ï¼‰
      topPx = SAFE;
    }
  }

  // â€”â€” ä½ç½®åæ˜ ï¼ˆsafe area ã®åˆ†ã¯ CSS å´ã§è¶³ã™ï¼‰ â€”â€”
  if (isPortrait){
    // ã®ã£ã¡å·¦=Pause, å³=SOUND
    pause.style.top   = `calc(${topPx}px + env(safe-area-inset-top, 0px))`;
    pause.style.left  = `calc(env(safe-area-inset-left, 0px) + 12px)`;
    pause.style.right = 'auto';

    sound.style.top   = pause.style.top;
    sound.style.right = `calc(env(safe-area-inset-right, 0px) + 12px)`;
    sound.style.left  = 'auto';
  }else{
    // æ¨ªï¼šå³ä¸Šã«Pauseã€ãã®â€œçœŸä¸‹â€ã«Soundï¼ˆè¢«ã‚‰ãªã„ï¼‰
    const rightPx = 12;
    pause.style.top   = `calc(${topPx}px + env(safe-area-inset-top, 0px))`;
    pause.style.right = `calc(${rightPx}px + env(safe-area-inset-right, 0px))`;
    pause.style.left  = 'auto';

    const soundTop = topPx + BTN + GAP;
    sound.style.top   = `calc(${soundTop}px + env(safe-area-inset-top, 0px))`;
    sound.style.right = pause.style.right;
    sound.style.left  = 'auto';
  }
  

  // ã‚¿ã‚¤ãƒãƒ¼ãŒå³ä¸Šã«ã‚ã‚‹å ´åˆã®é¿ã‘å¹…ï¼ˆä»»æ„ï¼‰ï¼šSOUNDã®å¹…ã‚’CSSå¤‰æ•°ã¸
  const sndWidth = Math.ceil(sound.getBoundingClientRect().width || 56) + 12;
  document.documentElement.style.setProperty('--snd-offset', sndWidth + 'px');
  
    // â˜… HUDã®å·¦å³ä½™ç™½ã‚’â€œãƒœã‚¿ãƒ³ã®å®Ÿæ¸¬å¹…â€ã‹ã‚‰ç®—å‡ºï¼ˆç¸¦ç”»é¢ã®ã¿å¼·ãåŠ¹ã‹ã›ã‚‹ï¼‰
  const pauseW = Math.ceil(pause.getBoundingClientRect().width || 44);
  const soundW = Math.ceil(sound.getBoundingClientRect().width || 56);

  if (isPortrait){
    // ã®ã£ã¡ + ãƒœã‚¿ãƒ³å¹… + å°‘ã—ãƒãƒ¼ã‚¸ãƒ³
    document.documentElement.style.setProperty('--hud-lpad', `calc(env(safe-area-inset-left,0px)  + ${pauseW + 10}px)`);
    document.documentElement.style.setProperty('--hud-rpad', `calc(env(safe-area-inset-right,0px) + ${soundW + 10}px)`);
    // å¿…è¦ã«å¿œã˜ã¦ä¸Šæ–¹å‘ã«ã‚‚æ•°pxã®ä½™è£•ï¼ˆé‡ãªã‚ŠãŒå®Œå…¨ã«æ¶ˆãˆã‚‹ã¾ã§å¾®èª¿æ•´ï¼‰
    document.documentElement.style.setProperty('--hud-tpad', '6px');
  }else{
    // æ¨ªç”»é¢ã¯æ§ãˆã‚ï¼ˆã»ã¼ç«¯ã„ã£ã±ã„ä½¿ã„ãŸã„ï¼‰
    document.documentElement.style.setProperty('--hud-lpad', `calc(env(safe-area-inset-left,0px)  + 12px)`);
    document.documentElement.style.setProperty('--hud-rpad', `calc(env(safe-area-inset-right,0px) + 12px)`);
    document.documentElement.style.setProperty('--hud-tpad', '0px');
  }
  
    // === Hardcoreãƒãƒƒã‚¸ä½ç½®ã‚’ Pause / SOUND ã«è¿½å¾“ã•ã›ã‚‹ ===
  // Pauseã®ã€Œä¸‹ã€ã«é…ç½®ï¼ˆç¸¦å‘ãï¼‰ï¼SOUNDã®ã€Œã•ã‚‰ã«ä¸‹ã€ã«é…ç½®ï¼ˆæ¨ªå‘ãï¼‰
  let hcTopPx = topPx + BTN + GAP;       // Pauseã®ä¸‹
  if (!isPortrait) hcTopPx += BTN + GAP; // æ¨ªå‘ãã¯Soundã®ä¸‹ã¾ã§ä¸‹ã’ã‚‹

  document.documentElement.style.setProperty('--hc-top',
    `calc(${hcTopPx}px + env(safe-area-inset-top, 0px))`);
  document.documentElement.style.setProperty('--hc-right',
    `calc(12px + env(safe-area-inset-right, 0px))`);

  
}



// å³ä¸ŠUIã¨ã‚¿ã‚¤ãƒãƒ¼ã®å†ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆå®‰å…¨ç‰ˆï¼šå­˜åœ¨ãƒã‚§ãƒƒã‚¯ã¤ãï¼‰
function recalcUi(){
  if (typeof layoutTopRightUI === 'function') layoutTopRightUI();
  if (typeof positionPcTimer === 'function') positionPcTimer();
}
window.addEventListener('load', recalcUi);
window.addEventListener('resize', recalcUi);
window.addEventListener('orientationchange', recalcUi);
setTimeout(recalcUi, 0);
setTimeout(recalcUi, 300);



// ãƒœã‚¿ãƒ³å¹…ãŒå¤‰ã‚ã£ãŸã‚‰ï¼ˆSOUND â‡„ MUTEï¼‰è‡ªå‹•ã§å†è¨ˆç®—
const _btn = document.getElementById('btnSound');
if (_btn) new ResizeObserver(()=>layoutTopRightUI()).observe(_btn);


// === SFX Synth ==========================================================
(function(){
function now(){ return (window.AC ? window.AC.currentTime : 0); }

  // 1ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆADSRï¼‰ï¼‹å‘¨æ³¢æ•°ã‚°ãƒ©ã‚¤ãƒ‰ï¼ˆä»»æ„ï¼‰ï¼‹ãƒ‘ãƒ³
  function tone({
    type='square', freq=440, freq2=null,
    t0=now(), a=0.005, d=0.05, s=0.0, r=0.08,
    gain=0.4, pan=0
  }={}){
    if (!AC) return;
    const o = AC.createOscillator(); o.type = type; o.frequency.setValueAtTime(freq, t0);
    if (freq2 && freq2>0){
      // ã‚°ãƒ©ã‚¤ãƒ‰ï¼ˆæŒ‡æ•° or ç·šå½¢ã¯è€³ã§åˆã†æ–¹ã‚’é¸æŠï¼‰
      o.frequency.exponentialRampToValueAtTime(freq2, t0 + a + d + r*0.8);
    }
    const g = AC.createGain();
    const p = (AC.createStereoPanner ? AC.createStereoPanner() : null);

    // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain), t0 + a);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0002, gain*s), t0 + a + d);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + a + d + r);

    o.connect(g);
    if (p){ g.connect(p); p.pan.value = pan; p.connect(bus.sfx); }
    else   { g.connect(bus.sfx); }

    o.start(t0);
    o.stop (t0 + a + d + r + 0.02);
  }

  // ãƒã‚¤ã‚ºï¼ˆHP/LPå¯ãƒ»ã‚¹ãƒ†ãƒ¬ã‚ªä»»æ„ï¼‰
  let NOISE_BUF = null;
  function ensureNoise(){
    if (!AC || NOISE_BUF) return;
    const len = AC.sampleRate * 1.0;
    const buf = AC.createBuffer(1, len, AC.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = Math.random()*2-1;
    NOISE_BUF = buf;
  }
  
function noise({
  t0 = (AC ? AC.currentTime : 0),
  dur = 0.06,
  gain = 0.35,
  hp = null,     // ä¾‹: 600
  lp = null,     // ä¾‹: 2400
  bp = null,     // ä¾‹: 1400ï¼ˆã‚»ãƒ³ã‚¿ãƒ¼å‘¨æ³¢æ•°ï¼‰
  q  = 6,        // bp ç”¨ Qï¼ˆç´°ã•ï¼‰
  pan = 0
} = {}){
  if (!AC) return;
  ensureNoise();

  const s = AC.createBufferSource(); s.buffer = NOISE_BUF;
  let node = s;

  if (bp){
    const f = AC.createBiquadFilter(); f.type = 'bandpass';
    f.frequency.setValueAtTime(bp, t0);
    f.Q.value = q;
    node.connect(f); node = f;
  }
  if (hp){
    const f = AC.createBiquadFilter(); f.type = 'highpass';
    f.frequency.setValueAtTime(hp, t0);
    node.connect(f); node = f;
  }
  if (lp){
    const f = AC.createBiquadFilter(); f.type = 'lowpass';
    f.frequency.setValueAtTime(lp, t0);
    node.connect(f); node = f;
  }

  const g = AC.createGain();
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  const p = (AC.createStereoPanner ? AC.createStereoPanner() : null);
  if (p){ node.connect(p); p.pan.value = pan; p.connect(g); }
  else  { node.connect(g); }
  g.connect(bus.sfx);

  s.start(t0);
  s.stop(t0 + dur + 0.02);
}


  // ã‚«ã‚¿ãƒ­ã‚°ï¼ˆæŒç¶šç³»ã®ä¸€æ™‚ãƒãƒ¼ãƒ‰ç½®ãå ´ï¼‰
  const live = { laser: null };

  const sfx = {
    // æ—¢å­˜ï¼ˆå¿…è¦ãªã‚‰å¾®èª¿æ•´ã—ã¦OKï¼‰
    shot(opts={}){
      const t = now();
      const base = opts.freq || 1100;
      tone({type:'square',   freq:base,    freq2:base*0.86, t0:t, a:0.003, d:0.05, r:0.06, gain:0.23, pan:opts.pan||0});
      tone({type:'triangle', freq:base*0.5, freq2:base*0.43, t0:t, a:0.002, d:0.045, r:0.06, gain:0.12, pan:opts.pan||0});
    },
    enemyDown(opts={}){
      const t = now();
      noise({t0:t, dur:0.05, gain:0.24, hp:500, pan:opts.pan||0});
      tone({type:'triangle', freq:220, freq2:180, t0:t, a:0.001, d:0.09, r:0.10, gain:0.22, pan:opts.pan||0});
    },
    pickup(){
      const t = now();
      tone({type:'sine', freq:1200, t0:t,       a:0.002, d:0.05, r:0.07, gain:0.22});
      tone({type:'sine', freq:1600, t0:t+0.03,  a:0.002, d:0.05, r:0.07, gain:0.18});
    },
    levelUp(){
      // å°‘ã—é•·ãæ˜ã‚‹ã
      const t = now();
      tone({type:'square',   freq:880,  t0:t,        a:0.005, d:0.10, r:0.14, gain:0.30});
      tone({type:'square',   freq:1175, t0:t+0.09,   a:0.005, d:0.12, r:0.16, gain:0.28});
      tone({type:'square',   freq:1568, t0:t+0.18,   a:0.006, d:0.14, r:0.18, gain:0.26});
      tone({type:'triangle', freq:2093, t0:t+0.26,   a:0.006, d:0.16, r:0.20, gain:0.20});
    },

    // â”€â”€ æ–°è¦ï¼šé›»æ’ƒãƒ»å²©ãƒ»ãƒãƒ´ã‚¡ãƒ»æ¯’ï¼ˆæ—¢ã«å…¥ã‚Œã¦ã„ã‚Œã°ãã®ã¾ã¾ã§OKï¼‰ â”€â”€
    lightning(){
  const AC = window.AC; if (!AC || window.AUDIO_MUTED) return;
  ensureNoise();
  const t0 = AC.currentTime;
  const total = 0.28;

  // 1) å¸¯é›»ã®ä½ã„å”¸ã‚Šï¼ˆæ§ãˆã‚ã€è€³ã«ç—›ããªã„ï¼‰
  {
    const o  = AC.createOscillator(); o.type = 'square'; o.frequency.setValueAtTime(120, t0);
    const lfo = AC.createOscillator(); lfo.type='sine'; lfo.frequency.setValueAtTime(16, t0);
    const lfg = AC.createGain(); lfg.gain.value = 8; // Â±8Hz
    lfo.connect(lfg); lfg.connect(o.frequency); lfo.start(t0); lfo.stop(t0 + total);

    const g  = AC.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + total);

    o.connect(g); g.connect(bus.sfx);
    o.start(t0); o.stop(t0 + total);
  }

  // 2) ã‚¹ãƒ‘ãƒ¼ã‚¯ï¼ˆé«˜åŸŸãƒã‚¤ã‚ºã®ç ´è£‚ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ•°å›ï¼‰
  const bursts = 5 + (Math.random()*2|0); // 5ã€œ6ç™º
  for(let i=0;i<bursts;i++){
    const st  = t0 + Math.random()*0.18;
    const dur = 0.05 + Math.random()*0.04; // 50ã€œ90ms
    const n   = AC.createBufferSource(); n.buffer = NOISE_BUF;
    const bp  = AC.createBiquadFilter(); bp.type='bandpass';
    bp.frequency.value = 2500 + Math.random()*1500; bp.Q.value = 6 + Math.random()*4;

    const hp  = AC.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 900;
    const g   = AC.createGain();
    g.gain.setValueAtTime(0.0001, st);
    g.gain.exponentialRampToValueAtTime(0.32, st + 0.012);
    g.gain.exponentialRampToValueAtTime(0.0001, st + dur);

    n.connect(bp); bp.connect(hp); hp.connect(g); g.connect(bus.sfx);
    n.start(st); n.stop(st + dur + 0.02);
  }
},

 rockRoll(){
  const AC = window.AC; if (!AC || window.AUDIO_MUTED) return;
  ensureNoise();
  const t0  = AC.currentTime;
  const dur = 1.60 + Math.random()*0.25;

  // åœ°é³´ã‚Šï¼ˆä½åŸŸãƒã‚¤ã‚ºã‚’åšã‚ã«2æ®µLPï¼‰
  const n   = AC.createBufferSource(); n.buffer = NOISE_BUF;
  const lp1 = AC.createBiquadFilter(); lp1.type='lowpass'; lp1.frequency.value = 240; lp1.Q.value = 0.7;
  const lp2 = AC.createBiquadFilter(); lp2.type='lowpass'; lp2.frequency.value = 180; lp2.Q.value = 0.7;
  const g   = AC.createGain();
  g.gain.setValueAtTime(0.0001, t0);
  g.gain.exponentialRampToValueAtTime(0.32, t0 + 0.10);   // ãµã‚ã£ã¨ç«‹ã¡ä¸Šã’
  g.gain.exponentialRampToValueAtTime(0.12, t0 + dur*0.6);// ã‚†ã‚‹ãæ¸›è¡°
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);  // ãƒ•ã‚§ãƒ¼ãƒ‰

  // è»¢ãŒã‚Šæ„Ÿï¼ˆéŸ³é‡ãƒˆãƒ¬ãƒ¢ãƒ­ 3.5Hzï¼‰
  const lfo = AC.createOscillator(); lfo.type='sine'; lfo.frequency.value = 3.5;
  const lfg = AC.createGain(); lfg.gain.value = 0.10;
  lfo.connect(lfg); lfg.connect(g.gain);

  n.connect(lp1); lp1.connect(lp2); lp2.connect(g); g.connect(bus.sfx);
  n.start(t0); n.stop(t0 + dur + 0.1);
  lfo.start(t0); lfo.stop(t0 + dur);

  // ã‚³ãƒ„ã‚³ãƒ„å½“ãŸã‚‹å°çŸ³ï¼ˆ80ã€œ140Hzã®çŸ­ã„ãƒˆãƒ³ã‚’2ã€œ4å›ï¼‰
  const knocks = 2 + (Math.random()*3|0);
  for(let i=0;i<knocks;i++){
    const st = t0 + 0.15 + Math.random()*(dur-0.35);
    const o  = AC.createOscillator(); o.type='sine';
    o.frequency.setValueAtTime(80 + Math.random()*60, st);
    const og = AC.createGain();
    og.gain.setValueAtTime(0.0001, st);
    og.gain.exponentialRampToValueAtTime(0.18, st + 0.012);
    og.gain.exponentialRampToValueAtTime(0.0001, st + 0.16 + Math.random()*0.06);
    o.connect(og); og.connect(bus.sfx);
    o.start(st); o.stop(st + 0.24);
  }
},

    nova(){
      const t = now();
      tone({type:'sine', freq:220, freq2:420, t0:t, a:0.008, d:0.25, r:0.45, gain:0.32});
      noise({t0:t+0.02, dur:0.35, gain:0.16, lp:800});
    },
    poison(){
      const t = now();
      noise({t0:t, dur:0.25, gain:0.10, lp:1200});
      const n = 5 + (Math.random()*3|0);
      for (let i=0;i<n;i++){
        const dt = t + i*(0.035+Math.random()*0.02);
        const f  = 520 + Math.random()*280;
        tone({type:'sine', freq:f, t0:dt, a:0.001, d:0.04, r:0.06, gain:0.16});
      }
    },

    // â”€â”€ é‡åšãªçˆ†ç™ºï¼ˆãƒœã‚¹æ’ƒç ´ï¼‰ â”€â”€
bossExplode(){
  const t = now();

  // åˆæœŸã‚¯ãƒ©ãƒƒã‚¯ï¼ˆé«˜åŸŸã¯æ§ãˆã‚ï¼‰
  noise({t0:t, dur:0.11, gain:0.34, hp:800, lp:2400});

  // ä¸»ãƒ–ãƒ¼ãƒ ï¼ˆè¶…ä½åŸŸãƒ»é•·å°¾ï¼‰
  const o1 = AC.createOscillator(); o1.type='sine';
  o1.frequency.setValueAtTime(52, t);
  o1.frequency.exponentialRampToValueAtTime(45, t+1.6);
  const g1 = AC.createGain();
  g1.gain.setValueAtTime(0.0001, t);
  g1.gain.exponentialRampToValueAtTime(0.9, t+0.03);
  g1.gain.exponentialRampToValueAtTime(0.0001, t+1.7);
  o1.connect(g1); g1.connect(bus.sfx);
  o1.start(t); o1.stop(t+1.8);

  // ä¸­ä½åŸŸã®è¡æ’ƒå±¤ï¼ˆçŸ­ã‚ã«2å±¤ï¼‰
  for (let i=0;i<2;i++){
    const tt = t + 0.06 + i*0.05;
    const o = AC.createOscillator(); o.type='triangle';
    o.frequency.setValueAtTime(130, tt);
    o.frequency.exponentialRampToValueAtTime(90, tt+0.35);
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.45, tt+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, tt+0.5);
    o.connect(g); g.connect(bus.sfx);
    o.start(tt); o.stop(tt+0.55);
  }

  // ãƒ‡ãƒ–ãƒªã¯â€œã‚³ãƒ­ã‚³ãƒ­æˆåˆ†â€ã‚’å‰Šé™¤ï¼šãƒã‚¤ã‚ºã®ã¿ã§æ•£ã‚‰ã™ï¼ˆé«˜åŸŸæ§ãˆã‚ï¼‰
  for (let i=0;i<4;i++){
    const dt = t + 0.10 + i*0.06;
    noise({t0:dt, dur:0.06, gain:0.20, hp:700, lp:2200});
  }

  // ä½™éŸ»ã®åœŸåŸƒï¼ˆä½åŸŸãƒã‚¤ã‚ºã‚’é•·ã‚ã«ï¼‰
  noise({t0:t+0.18, dur:1.2, gain:0.20, lp:450});
},


    // â”€â”€ ãƒœã‚¹ï¼šãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ“ãƒ¼ãƒ ï¼ˆé–‹å§‹ï¼åœæ­¢ï¼‰ â”€â”€
bossLaserStart(){
  if (!AC || live.laser) return;
  const t = now();

  // é€£ç¶šéŸ³ï¼šã‚„ã‚„ä½ã‚ï¼†ãƒ‡ãƒãƒ¥ãƒ¼ãƒ³å°‘ãªã‚
  const o1 = AC.createOscillator(); o1.type = 'sawtooth'; o1.frequency.setValueAtTime(760, t);
  const o2 = AC.createOscillator(); o2.type = 'sawtooth'; o2.frequency.setValueAtTime(772, t);
  const n  = AC.createBufferSource(); ensureNoise(); n.buffer = NOISE_BUF;

  // å¸¯åŸŸæ•´å½¢ï¼ˆåˆºã•ã‚Šå¸¯åŸŸã‚’æ¸›ã‚‰ã™ï¼‰
  const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1400; bp.Q.value = 3.2;
  const lp = AC.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value = 2100; // â†ä¸‹ã’ãŸ

  const g  = AC.createGain(); g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.26, t+0.04); // â†å…¨ä½“ã‚²ã‚¤ãƒ³å°ã•ã‚
  const p  = (AC.createStereoPanner? AC.createStereoPanner():null);

  // é…ç·š
  o1.connect(g); o2.connect(g);
  n.connect(bp); bp.connect(lp); lp.connect(g);
  if (p){ g.connect(p); p.pan.value = 0; p.connect(bus.sfx); } else { g.connect(bus.sfx); }

  // ãƒã‚¤ã‚ºã¯ã•ã‚‰ã«æ§ãˆã‚
  const ng = AC.createGain(); ng.gain.value = 0.10; // â†ä¸‹ã’ãŸ
  lp.disconnect(); lp.connect(ng); ng.connect(g);
  n.loop = true;

  o1.start(t); o2.start(t); n.start(t);

  live.laser = { o1, o2, n, g, ng, p, stopAt:null };
},



bossWave(){
  if (!AC) return;
  const t = now();

  // å‡ºåŠ›ãƒŸã‚­ã‚µï¼šç›´éŸ³ + ãƒ‡ã‚£ãƒ¬ã‚¤ã‚’æŸã­ã‚‹
  const mix = AC.createGain(); mix.connect(bus.sfx);

  // ãƒ‡ã‚£ãƒ¬ã‚¤ç¶²ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
  const d   = AC.createDelay();      d.delayTime.value = 0.14; // 140ms
  const fb  = AC.createGain();       fb.gain.value     = 0.30; // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é‡
  const dlpf= AC.createBiquadFilter(); dlpf.type='lowpass'; dlpf.frequency.value = 1600;

  // ç›´åˆ—ï¼šd â†’ lp â†’ fb â†’ dï¼ˆãƒ«ãƒ¼ãƒ—ï¼‰ã€ã‹ã¤ lp ã‹ã‚‰ mix ã¸
  d.connect(dlpf); dlpf.connect(fb); fb.connect(d);
  dlpf.connect(mix);

  // ãƒ¡ã‚¤ãƒ³ä½åŸŸãƒˆãƒ¼ãƒ³ï¼ˆãƒ–ãƒ¯ã‚¡ãƒ³ï¼‰
  const o  = AC.createOscillator(); o.type='sine';
  o.frequency.setValueAtTime(140, t);
  o.frequency.exponentialRampToValueAtTime(70,  t+0.55);

  const og = AC.createGain();
  og.gain.setValueAtTime(0.0001, t);
  og.gain.exponentialRampToValueAtTime(0.8, t+0.02);
  og.gain.exponentialRampToValueAtTime(0.0001, t+0.65);

  o.connect(og); og.connect(mix); og.connect(d); // ç›´éŸ³+ãƒ‡ã‚£ãƒ¬ã‚¤ã¸é€ã‚‹
  o.start(t); o.stop(t+0.7);

  // å¸¯åŸŸãƒã‚¤ã‚ºã§åšã¿
  const ns = AC.createBufferSource(); ensureNoise(); ns.buffer = NOISE_BUF;
  const bp = AC.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=520; bp.Q.value=1.4;
  const ng = AC.createGain(); ng.gain.setValueAtTime(0.18, t);
  ng.gain.exponentialRampToValueAtTime(0.0001, t+0.45);

  ns.connect(bp); bp.connect(ng); ng.connect(mix); ng.connect(d);
  ns.start(t); ns.stop(t+0.5);
},


warnLevelUp(){
  const t = now();
  // é™ä¸‹ã™ã‚‹ãƒã‚¤ãƒŠãƒ¼2éŸ³ï¼ˆçŸ­ã„ãƒ–ã‚¶ãƒ¼é¢¨ï¼‰
  const f1 = 740;  // F#5
  const f2 = 622;  // D#5ï¼ˆçŸ­ä¸‰åº¦ä¸‹ï¼‰
  for (let i=0;i<2;i++){
    const tt = t + i*0.18;
    const o = AC.createOscillator(); o.type='square';
    o.frequency.setValueAtTime(f1, tt);
    o.frequency.exponentialRampToValueAtTime(f2, tt+0.12);
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.35, tt+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, tt+0.14);
    o.connect(g); g.connect(bus.sfx);
    o.start(tt); o.stop(tt+0.18);
  }
},

warnBoss(){
  const t = now();
  const reps = 3;           // 3é€£ç™º
  const dur  = 0.42;        // 1ç™ºã®é•·ã•ï¼ˆãƒ–ã‚£ãƒ¼ãƒ¼ãƒ¼ã®å°ºï¼‰
  const gap  = 0.09;        // ç™ºã¨ç™ºã®é–“
  const f0   = 520;         // ä½ã„å‡ºç™ºå‘¨æ³¢æ•°
  const f1   = 1100;        // é«˜ã„åˆ°é”å‘¨æ³¢æ•°ï¼ˆä¸Šæ˜‡çµ‚ç‚¹ï¼‰

  for (let i = 0; i < reps; i++){
    const tt = t + i * (dur + gap);

    // ã–ã‚‰ã¤ãã®æ ¸ï¼šãƒ‡ãƒãƒ¥ãƒ¼ãƒ³ã—ãŸé‹¸æ³¢2æœ¬ã‚’ä¸Šæ˜‡ã•ã›ã‚‹
    const o1 = AC.createOscillator(); o1.type = 'sawtooth';
    const o2 = AC.createOscillator(); o2.type = 'sawtooth';
    o1.frequency.setValueAtTime(f0, tt);
    o2.frequency.setValueAtTime(f0 * 1.015, tt); // ã»ã‚“ã®å°‘ã—ä¸Šã«ãƒ‡ãƒãƒ¥ãƒ¼ãƒ³
    // ä½â†’é«˜ã¸ä¸Šæ˜‡ï¼ˆæŒ‡æ•°ãƒ©ãƒ³ãƒ—ã§â€œã†ã­ã‚Šæ„Ÿâ€ï¼‰
    o1.frequency.exponentialRampToValueAtTime(f1, tt + dur * 0.9);
    o2.frequency.exponentialRampToValueAtTime(f1 * 1.015, tt + dur * 0.9);

    // ã€Œã‚¶ãƒ©ã¤ãã€æˆåˆ†ï¼šå¸¯åŸŸãƒã‚¤ã‚ºã‚’ä¸­å¤®å‘¨æ³¢æ•°ã”ã¨ä¸Šæ˜‡ã•ã›ã¦æ··ãœã‚‹
    const ns = AC.createBufferSource(); ensureNoise(); ns.buffer = NOISE_BUF;
    const bp = AC.createBiquadFilter(); bp.type = 'bandpass';
    bp.frequency.setValueAtTime(900, tt);
    bp.frequency.exponentialRampToValueAtTime(1700, tt + dur * 0.9);
    bp.Q.value = 6;

    const ng = AC.createGain();  // ãƒã‚¤ã‚ºé‡
    ng.gain.setValueAtTime(0.12, tt);
    ng.gain.exponentialRampToValueAtTime(0.10, tt + dur);

    ns.connect(bp); bp.connect(ng);

    // ä¸Šã®åˆºã•ã‚Šã‚’å°‘ã—ã ã‘è½ã¨ã™LPFï¼ˆãƒ–ã‚£ãƒ¼ãƒ¼ãƒ¼ã®è€³å½“ãŸã‚Šèª¿æ•´ï¼‰
    const lp = AC.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 2400;

    // ã‚²ãƒ¼ãƒˆåŒ…çµ¡ï¼ˆç´ æ—©ã„ç«‹ä¸Šã’â†’ä¿æŒâ†’ãƒªãƒªãƒ¼ã‚¹ï¼‰
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, tt);
    g.gain.exponentialRampToValueAtTime(0.42, tt + 0.016);    // Attack
    g.gain.setValueAtTime(0.42, tt + dur - 0.08);             // Hold
    g.gain.exponentialRampToValueAtTime(0.0001, tt + dur);    // Release

    // ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
    o1.connect(lp); o2.connect(lp); lp.connect(g);
    ng.connect(g);
    g.connect(bus.sfx);

    // ç™ºéŸ³
    o1.start(tt); o2.start(tt); ns.start(tt);
    o1.stop(tt + dur + 0.03); o2.stop(tt + dur + 0.03); ns.stop(tt + dur + 0.03);
  }
}
  };

  window.sfx = sfx; // å…¬é–‹

})();


// === å›ºå®šã‚¢ã‚¹ãƒšã‚¯ãƒˆã®ãƒ—ãƒ¬ã‚¤é ˜åŸŸï¼ˆ4:3 / 3:4ï¼‰ ===
const ASPECT_L = 4/3;
const ASPECT_P = 3/4;
const UI_TOP_BAR_CSS = 84; // ä¸Šå¸¯ã®å®Ÿå¯¸(px)

// HUDã‚’ãƒãƒƒãƒã‹ã‚‰å°‘ã—ä¸‹ã’ã‚‹ï¼ˆpxï¼‰
const HUD_TOP_OFFSET_CSS = 10;

// === World sizeï¼ˆå®Ÿå¯¸ï¼‰===
const WORLD_L = { w: 1200, h: 900 }; // æ¨ªé•·ï¼ˆPCãƒ»iPadï¼‰
const WORLD_P = { w: 720, h: 960 };  // ç¸¦é•·ï¼ˆã‚¹ãƒãƒ›ï¼‰
const WORLD   = { w: WORLD_L.w, h: WORLD_L.h };

const PLAY = { x:0, y:0, w:0, h:0, aspect:ASPECT_L, isPortrait:false };

function computePlayRect(){
  const vw = W / DPR, vh = H / DPR;

  // å‘ãã¨ã‚¢ã‚¹ãƒšã‚¯ãƒˆ
  const isPortrait = vw <= vh;
  const target = isPortrait ? ASPECT_P : ASPECT_L;

  // CSSã® --safe-top ã‚’å–å¾—
  const safeTopPx = parseFloat(
    getComputedStyle(document.documentElement).getPropertyValue('--safe-top')
  ) || 0;

  // ç¸¦å‘ãã®ã¨ãã ã‘ã€ä¸Šã«ã€Œãƒãƒƒãƒï¼‹ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‹HUDé«˜ã€ã‚’ç¢ºä¿
  const topBar = isPortrait ? (safeTopPx + HUD_TOP_OFFSET_CSS + UI_TOP_BAR_CSS) : 0;
  const availH = Math.max(0, vh - topBar);

  // 3:4 / 4:3 ã‚’æ®‹ã‚Šé ˜åŸŸã«ãƒ•ã‚£ãƒƒãƒˆ
  let w, h;
  if (vw / availH > target){ h = availH; w = h * target; }
  else { w = vw; h = w / target; if (h > availH){ h = availH; w = h * target; } }

  const x = Math.floor((vw - w)/2);
  // â˜…ç¸¦ã¯â€œHUDã®ç›´ä¸‹ã«ã´ã£ãŸã‚Šâ€é…ç½®ï¼æ¨ªã¯ä¸­å¤®å¯„ã›
  const y = isPortrait ? Math.floor(topBar) : Math.floor((vh - h)/2);

  PLAY.x = x; PLAY.y = y; PLAY.w = w; PLAY.h = h;
  PLAY.aspect = target; PLAY.isPortrait = isPortrait;

  // WORLD åˆ‡æ›¿ï¼ˆã‚¹ãƒãƒ›æ¨ªãƒ»ç¸¦ãƒ»PCæ¨ªã®3ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
  const isSmallScreen = Math.max(vw, vh) < 768;
  
  if (isPortrait) {
    WORLD.w = WORLD_P.w; 
    WORLD.h = WORLD_P.h;
  } else if (isSmallScreen) {
    // ã‚¹ãƒãƒ›æ¨ª: 960x720
    WORLD.w = 960; 
    WORLD.h = 720;
  } else {
    // PCæ¨ªãƒ»iPad: 1200x900
    WORLD.w = WORLD_L.w; 
    WORLD.h = WORLD_L.h;
  }
}

function updateDock(){
  const dock = document.getElementById('dock');
  if(!dock) return;
  const vw = W / DPR, vh = H / DPR;

  if(PLAY.isPortrait){
    // ç¸¦é•·ï¼šä¸‹ã®é»’å¸¯ã«
    dock.style.left   = PLAY.x + 'px';
    dock.style.top    = (PLAY.y + PLAY.h) + 'px';
    dock.style.width  = PLAY.w + 'px';
    dock.style.height = Math.max(0, vh - (PLAY.y + PLAY.h)) + 'px';
    dock.className = 'portrait';
  }else{
    // æ¨ªé•·ï¼šå³ã®é»’å¸¯ã«
    dock.style.left   = (PLAY.x + PLAY.w) + 'px';
    dock.style.top    = PLAY.y + 'px';
    dock.style.width  = Math.max(0, vw - (PLAY.x + PLAY.w)) + 'px';
    dock.style.height = PLAY.h + 'px';
    dock.className = 'landscape';
  }

  // é¢ç©ãŒå–ã‚Œãªã„æ™‚ã¯éè¡¨ç¤º
  const ww = parseFloat(dock.style.width)||0, hh = parseFloat(dock.style.height)||0;
  dock.style.display = (ww > 1 && hh > 1) ? 'block' : 'none';
}

function updateHudTop(){
  const el = document.getElementById('hudTop');
  if (!el) return;

  // ç¸¦å‘ãã ã‘è¡¨ç¤ºï¼ˆæ¨ªã§ã¯éš ã™ï¼‰
  if (!PLAY.isPortrait){
    el.style.display = 'none';
    return;
  }

  // å¹…ã¯ãƒ—ãƒ¬ã‚¤é¢ã«åˆã‚ã›ã€ä¸Šç«¯ã¯ã€Œãƒãƒƒãƒåˆ†ï¼‹ã‚ªãƒ•ã‚»ãƒƒãƒˆã€ã ã‘ä¸‹ã’ã‚‹
  el.style.left   = PLAY.x + 'px';
  el.style.top    = `calc(var(--safe-top) + ${HUD_TOP_OFFSET_CSS}px)`;
  el.style.width  = PLAY.w + 'px';
  el.style.height = UI_TOP_BAR_CSS + 'px';
  el.style.display = 'block';
}

function ensurePcTimer(){
  let el = document.getElementById('pcTimer');
  if (!el) {
    el = document.createElement('div');
    el.id = 'pcTimer';
    el.textContent = '0:00';
    document.body.appendChild(el);        // â† dock ã§ã¯ãªã body ã¸
  }
  // è¡¨ç¤ºã¯JSå´ã§åˆ¶å¾¡ã—ãŸã„ãªã‚‰ã“ã“ã§ block ã«
  el.style.display = 'block';
}

function positionPcTimer(){
  const el = document.getElementById('pcTimer');
  if (!el || !window.PLAY) return;
  
  // æ¨ªç”»é¢ï¼†å°ã•ã‚ç”»é¢(=ã‚¿ãƒƒãƒç«¯æœ«æƒ³å®š)ãªã‚‰ã‚¿ã‚¤ãƒãƒ¼ã‚’ 1/3 ã«
const isLandscape = window.matchMedia && window.matchMedia('(orientation: landscape)').matches;
const isSmallTouch = (Math.min(window.innerWidth, window.innerHeight) <= 900) && ((navigator.maxTouchPoints || 0) > 0);
pcTimer.classList.toggle('pc-mini', isLandscape && isSmallTouch);


  const isPortrait = !!PLAY.isPortrait;
  if (isPortrait){
    // ç¸¦ï¼šãƒ—ãƒ¬ã‚¤é ˜åŸŸã®ä¸‹é»’å¸¯ã«å¹…ãƒ”ãƒƒã‚¿ãƒªã§ä¸­å¤®è¡¨ç¤º
    el.style.left   = PLAY.x + 'px';
    el.style.width  = PLAY.w + 'px';
    el.style.textAlign = 'center';
    el.style.top    = 'auto';
    el.style.right  = 'auto';
    el.style.bottom = 'calc(env(safe-area-inset-bottom) + 12px)';
    el.style.transform = 'none';
  } else {
    // æ¨ªï¼šå³ä¸Šï¼ˆHUDã®ä¸‹ï¼‰ï¼‹muteãƒœã‚¿ãƒ³å¹…ã‚’é¿ã‘ã‚‹
    el.style.width  = '';
    el.style.left   = 'auto';
    el.style.right  = 'calc(env(safe-area-inset-right) + 12px + var(--snd-offset, 0px))';
    el.style.top    = 'calc(env(safe-area-inset-top) + 92px)';
    el.style.bottom = 'auto';
    el.style.textAlign = 'right';
    el.style.transform = 'none';
  }
  el.style.display = 'block';
}


  
function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const r = cv.getBoundingClientRect();
  W = Math.floor(r.width * DPR);
  H = Math.floor(r.height * DPR);
  cv.width = W; 
  cv.height = H;

  // ç­‰å€æç”»ï¼ˆç¸®å°ã¯ã—ãªã„ï¼‰
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

// ãƒ—ãƒ¬ã‚¤æ ã®å†è¨ˆç®— â†’ ãƒ‰ãƒƒã‚¯é…ç½® â†’ HUDç”Ÿæˆ â†’ HUDä½ç½®æ›´æ–°ï¼ˆã“ã®é †ï¼‰
computePlayRect();
updateDock();
ensurePcTimer();  // â† è¿½åŠ ï¼šPCç”¨ã‚¿ã‚¤ãƒãƒ¼ã‚’ä¸€åº¦ä½œã£ã¦ãŠã
ensureTopHud();
ensureSoundButton(); 
layoutTopRightUI(); 
positionPcTimer();
updateHudTop();

}

// ç”»é¢ã«ã‚µã‚¦ãƒ³ãƒ‰ãƒœã‚¿ãƒ³ã‚’å¿…ãšä½œã‚‹ï¼ˆç¸¦=HUDå†… / æ¨ª=ãƒ‰ãƒƒã‚¯å³å¯„ã›ï¼‰
function ensureSoundButton(){
  let el = document.getElementById('btnSound');
  if (!el){
    el = document.createElement('button');
    el.id = 'btnSound';
    el.innerHTML = `<span class="icon">ğŸ”Š</span><span class="label">SOUND</span>`;
    el.title = 'Sound On/Off (M)';
    el.addEventListener('click', ()=>{
      initAudioOnce();
      const next = !window.AUDIO_MUTED;
      if (typeof window.setAudioMuted === 'function') setAudioMuted(next);
      else {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        window.AUDIO_MUTED = next;
        const AC = window.AC;
        if (window.bus && bus.master && AC){
          const t = AC.currentTime;
          bus.master.gain.setTargetAtTime(next ? 0.0001 : 1.0, t, 0.03);
        }
      }
      // åŠ¹æœéŸ³ã‚‚ãƒŸãƒ¥ãƒ¼ãƒˆ
      soundEnabled = !next;
      
      if (typeof saveMute === 'function') saveMute(next);
      refreshSoundIcon();
    }, {passive:true});
    document.body.appendChild(el); // canvasã‚ˆã‚Šä¸Šã«å›ºå®š
  }
  refreshSoundIcon();
  layoutTopRightUI();
}

function refreshSoundIcon(){
  const el = document.getElementById('btnSound');
  if (!el) return;
  const muted = !!window.AUDIO_MUTED;
  el.dataset.muted = String(muted);
  const icon  = el.querySelector('.icon');
  const label = el.querySelector('.label');
  if (icon)  icon.textContent  = muted ? 'ğŸ”‡' : 'ğŸ”Š';
  if (label) label.textContent = muted ? 'MUTE' : 'SOUND';
}


// èµ·å‹•æ™‚ã¯å¸¸ã«éŸ³å£°ONã§é–‹å§‹ï¼ˆ2ç®‡æ‰€ç›®ã‚‚åŒæ§˜ã«ä¿®æ­£ï¼‰
(function(){
  // localStorageã®ä¿å­˜å€¤ã¯ç„¡è¦–ã—ã€å¸¸ã«ãƒŸãƒ¥ãƒ¼ãƒˆè§£é™¤ã§é–‹å§‹
  if (typeof window.setAudioMuted === 'function') setAudioMuted(false);
  else window.AUDIO_MUTED = false;
})();

  new ResizeObserver(resize).observe(cv); resize();
  
  window.addEventListener('orientationchange', resize);
window.addEventListener('resize', resize);
window.addEventListener('resize', layoutTopRightUI);



  const rnd = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  
// ç½®æ›ï¼šãƒ¯ãƒ¼ãƒ«ãƒ‰å†…ã®çµ¶å¯¾å¢ƒç•Œï¼ˆç§»å‹•ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ç”¨ï¼‰
function worldBounds(radius = 0){
  return {
    minX: 0 + radius,
    maxX: WORLD.w - radius,
    minY: 0 + radius,
    maxY: WORLD.h - radius
  };
}

// è¿½åŠ ï¼šç¾åœ¨ã‚ºãƒ¼ãƒ ã§è¦‹ãˆã¦ã„ã‚‹ä¸­å¤®ã®åˆ‡ã‚ŠæŠœãï¼ˆã‚¹ãƒãƒ¼ãƒ³ç”¨ï¼‰
function visibleBounds(radius = 0){
  const z = (typeof state?.cameraZoom === 'number' && state.cameraZoom > 1) ? state.cameraZoom : 1;
  // z=1 ãªã‚‰ WORLD å…¨é¢ãŒè¦‹ãˆã¦ã„ã‚‹ã€‚z>1 ãªã‚‰ä¸­å¤®ã‚’ (1/z) å€ã§åˆ‡ã‚ŠæŠœã
  const vw = WORLD.w / z;
  const vh = WORLD.h / z;
  const minX = (WORLD.w - vw) * 0.5 + radius;
  const maxX = (WORLD.w + vw) * 0.5 - radius;
  const minY = (WORLD.h - vh) * 0.5 + radius;
  const maxY = (WORLD.h + vh) * 0.5 - radius;
  return { minX, maxX, minY, maxY };
}

  
  
  const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy;}
  const pick=(arr)=>arr[(Math.random()*arr.length)|0];

  // === ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ  ===
  const RANKING_KEY = 'gameRankings_v2';  // â˜…v2ã«å¤‰æ›´ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥å¯¾å¿œï¼‰
  const MAX_RANKINGS = 10;

  function saveScore(scoreData) {
    try {
      const allRankings = loadAllRankings();
      const stage = scoreData.stage || 'stage1';  // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥
      
      if (!allRankings[stage]) allRankings[stage] = [];
      allRankings[stage].push(scoreData);
      // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆï¼ˆé™é †ï¼‰
      allRankings[stage].sort((a, b) => b.score - a.score);
      // ä¸Šä½10ä»¶ã®ã¿ä¿æŒ
      allRankings[stage] = allRankings[stage].slice(0, MAX_RANKINGS);
      localStorage.setItem(RANKING_KEY, JSON.stringify(allRankings));
      return allRankings[stage];
    } catch (e) {
      console.error('Failed to save score:', e);
      return [];
    }
  }

  function loadAllRankings() {
    try {
      const data = localStorage.getItem(RANKING_KEY);
      return data ? JSON.parse(data) : { stage1: [], stage2: [] };
    } catch (e) {
      console.error('Failed to load rankings:', e);
      return { stage1: [], stage2: [] };
    }
  }

  function loadRankings(stage = 'stage1') {
    const all = loadAllRankings();
    return all[stage] || [];
  }

  function formatTime(seconds) {
    const min = Math.floor(seconds / 60);
    const sec = Math.floor(seconds % 60);
    return `${min}:${sec.toString().padStart(2, '0')}`;
  }

  function createScoreData(result) {
    // state.scoreã¯updateEndScoreã§æ—¢ã«ãƒœãƒ¼ãƒŠã‚¹åŠ ç®—æ¸ˆã¿
    const score = state.score || 0;
    
    // ãƒœãƒ¼ãƒŠã‚¹ã®è¨˜éŒ²ç”¨ï¼ˆè¡¨ç¤ºã®ãŸã‚ï¼‰
    let timeBonus = 0;
    let clearBonus = 0;
    
    if (result === 'clear') {
      clearBonus = 10000;
      
      const clearTime = state.timeSec;
      const targetTime = 780;
      if (clearTime < targetTime) {
        timeBonus = Math.floor((targetTime - clearTime) * 1000);
      }
    }
    
    return {
      score: score, // æ—¢ã«ãƒœãƒ¼ãƒŠã‚¹åŠ ç®—æ¸ˆã¿
      kills: state.kills || 0,
      bossKills: state.bossKills || 0,
      time: state.timeSec,
      timeBonus: timeBonus,
      clearBonus: clearBonus,
      level: state.player.level,
      result: result, // 'clear' or 'gameover'
      mode: state.mode.hardcore ? 'Hardcore' : 'Normal',
      stage: state.currentStage || 'stage1',  // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸è¿½åŠ 
      date: new Date().toISOString()
    };
  }

  function showRankingModal(currentScore = null) {
    const currentStage = currentScore?.stage || state.currentStage || 'stage1';
    let selectedStage = currentStage;
    
    function renderRankings(stage) {
      const rankings = loadRankings(stage);
      const stageName = stage === 'stage1' ? 'â–  ã‚¹ãƒ†ãƒ¼ã‚¸1' : 'â–² ã‚¹ãƒ†ãƒ¼ã‚¸2';
      const stageColor = stage === 'stage1' ? '#60a5fa' : '#ec4899';
      
      let html = `
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:13030;" id="rankingModal">
          <div style="background:#1a1a2e;border:3px solid #4a90e2;border-radius:12px;padding:20px;max-width:500px;width:90%;max-height:80vh;display:flex;flex-direction:column;">
            
            <!-- â˜…CLOSEãƒœã‚¿ãƒ³ã‚’ä¸Šéƒ¨ã«é…ç½® -->
            <button onclick="document.getElementById('rankingModal').remove();" style="width:100%;padding:10px;background:#ef4444;color:#fff;border:none;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;margin-bottom:12px;">
              âœ• CLOSE
            </button>
            
            <h2 style="color:#4a90e2;text-align:center;margin:0 0 12px 0;font-size:22px;">ğŸ† RANKING ğŸ†</h2>
            
            <!-- â˜…ã‚¹ãƒ†ãƒ¼ã‚¸åˆ‡ã‚Šæ›¿ãˆã‚¿ãƒ– -->
            <div style="display:flex;gap:8px;margin-bottom:12px;">
              <button id="tabStage1" onclick="window._switchRankingTab('stage1')" style="flex:1;padding:8px;border:none;border-radius:6px;font-weight:bold;cursor:pointer;font-size:14px;${stage === 'stage1' ? 'background:#60a5fa;color:#fff;' : 'background:#334155;color:#94a3b8;'}">
                â–  ã‚¹ãƒ†ãƒ¼ã‚¸1
              </button>
              <button id="tabStage2" onclick="window._switchRankingTab('stage2')" style="flex:1;padding:8px;border:none;border-radius:6px;font-weight:bold;cursor:pointer;font-size:14px;${stage === 'stage2' ? 'background:#ec4899;color:#fff;' : 'background:#334155;color:#94a3b8;'}">
                â–² ã‚¹ãƒ†ãƒ¼ã‚¸2
              </button>
            </div>
            
            <div style="flex:1;overflow-y:auto;">
      `;

      if (rankings.length === 0) {
        html += `<p style="color:#999;text-align:center;padding:30px 0;">è¨˜éŒ²ãªã—</p>`;
      } else {
        rankings.forEach((entry, index) => {
          const isCurrent = currentScore && entry.score === currentScore.score && 
                           entry.date === currentScore.date;
          const bgColor = isCurrent ? '#2a4a2e' : (index % 2 === 0 ? '#16213e' : '#1a1a2e');
          const borderColor = isCurrent ? '#4ade80' : 'transparent';
          
          const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
          const resultIcon = entry.result === 'clear' ? 'âœ…' : 'ğŸ’€';
          const modeColor = entry.mode === 'Hardcore' ? '#ef4444' : '#4a90e2';
          const hasBo = entry.timeBonus && entry.timeBonus > 0;
          
          html += `
            <div style="background:${bgColor};border:2px solid ${borderColor};border-radius:8px;padding:10px;margin-bottom:6px;">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                <span style="font-size:18px;font-weight:bold;color:#fff;">${medal}</span>
                <span style="font-size:20px;font-weight:bold;color:#fbbf24;">${entry.score.toLocaleString()}</span>
              </div>
              <div style="display:flex;justify-content:space-between;font-size:12px;color:#aaa;">
                <span>${resultIcon} ${entry.kills + entry.bossKills} kills</span>
                <span>â±ï¸ ${formatTime(entry.time)}${hasBo ? ` ğŸ+${entry.timeBonus.toLocaleString()}` : ''}</span>
              </div>
              <div style="display:flex;justify-content:space-between;font-size:11px;color:#888;margin-top:2px;">
                <span style="color:${modeColor};font-weight:bold;">${entry.mode}</span>
                <span>Lv ${entry.level}</span>
                <span>${new Date(entry.date).toLocaleDateString()}</span>
              </div>
            </div>
          `;
        });
      }

      html += `
            </div>
          </div>
        </div>
      `;
      return html;
    }
    
    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆé–¢æ•°ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«
    window._switchRankingTab = function(stage) {
      selectedStage = stage;
      const modal = document.getElementById('rankingModal');
      if (modal) modal.remove();
      const newModal = document.createElement('div');
      newModal.innerHTML = renderRankings(stage);
      document.body.appendChild(newModal);
    };

    const modal = document.createElement('div');
    modal.innerHTML = renderRankings(selectedStage);
    document.body.appendChild(modal);
  }

  // === å®Ÿç¸¾ã‚·ã‚¹ãƒ†ãƒ  ===
  const ACHIEVEMENTS_KEY = 'gameAchievements_v1';
  const ACHIEVEMENT_PROGRESS_KEY = 'achievementProgress_v1';

  // å®Ÿç¸¾å®šç¾©
  const ACHIEVEMENTS = {
    // åŸºæœ¬å®Ÿç¸¾
    first_play: { id: 'first_play', name: 'åˆãƒ—ãƒ¬ã‚¤', desc: 'ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹', icon: 'ğŸ®', tier: 'bronze' },
    first_kill: { id: 'first_kill', name: 'åˆæ’ƒç ´', desc: 'æ•µã‚’1ä½“å€’ã™', icon: 'âš”ï¸', tier: 'bronze' },
    first_clear: { id: 'first_clear', name: 'åˆã‚¯ãƒªã‚¢', desc: 'ã‚²ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹', icon: 'âœ…', tier: 'silver' },
    kill_100: { id: 'kill_100', name: 'è™æ®ºè€…', desc: 'æ•µ100ä½“æ’ƒç ´', icon: 'ğŸ’€', tier: 'bronze' },
    kill_500: { id: 'kill_500', name: 'å¤§è™æ®ºè€…', desc: 'æ•µ500ä½“æ’ƒç ´', icon: 'ğŸ’€ğŸ’€', tier: 'silver' },
    boss_10: { id: 'boss_10', name: 'ãƒœã‚¹ãƒãƒ³ã‚¿ãƒ¼', desc: 'ãƒœã‚¹10ä½“æ’ƒç ´', icon: 'ğŸ°', tier: 'silver' },
    level_20: { id: 'level_20', name: 'æˆé•·æ ª', desc: 'ãƒ¬ãƒ™ãƒ«20åˆ°é”', icon: 'ğŸ“Š', tier: 'bronze' },
    level_30: { id: 'level_30', name: 'ç†Ÿç·´è€…', desc: 'ãƒ¬ãƒ™ãƒ«30åˆ°é”', icon: 'ğŸ“', tier: 'silver' },
    hardcore_clear: { id: 'hardcore_clear', name: 'ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã‚µãƒã‚¤ãƒãƒ¼', desc: 'Hardcoreã§ã‚¯ãƒªã‚¢', icon: 'ğŸ”¥', tier: 'gold' },
    speed_11min: { id: 'speed_11min', name: 'ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ãƒ³ãƒŠãƒ¼', desc: '11åˆ†ä»¥å†…ã«ã‚¯ãƒªã‚¢', icon: 'âš¡', tier: 'gold' },
    hp_90_clear: { id: 'hp_90_clear', name: 'å®Œå…¨å‹åˆ©', desc: 'HP90%ä»¥ä¸Šã§ã‚¯ãƒªã‚¢', icon: 'ğŸ’', tier: 'silver' },
    chest_10: { id: 'chest_10', name: 'å®ç®±ãƒãƒ‹ã‚¢', desc: 'å®ç®±10å€‹é–‹ã‘ã‚‹', icon: 'ğŸ“¦', tier: 'bronze' },
    gem_500: { id: 'gem_500', name: 'ã‚¸ã‚§ãƒ ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼', desc: 'ã‚¸ã‚§ãƒ 500å€‹å–å¾—', icon: 'ğŸ’', tier: 'bronze' },
    play_10: { id: 'play_10', name: 'ãƒ™ãƒ†ãƒ©ãƒ³', desc: 'ç·ãƒ—ãƒ¬ã‚¤10å›', icon: 'ğŸ®', tier: 'silver' },
    total_kill_5000: { id: 'total_kill_5000', name: 'ç”Ÿæ¶¯æ®ºæˆ®è€…', desc: 'ç´¯è¨ˆæ’ƒç ´5000ä½“', icon: 'ğŸ’€', tier: 'gold' },

    // æ­¦å™¨é–¢é€£
    pure_blaster: { id: 'pure_blaster', name: 'ãƒ”ãƒ¥ã‚¢ã‚¬ãƒ³ãƒŠãƒ¼', desc: 'Blasterã®ã¿ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ”«', tier: 'gold' },
    weapon_2: { id: 'weapon_2', name: 'äºŒåˆ€æµ', desc: 'æ­¦å™¨2ç¨®é¡ã®ã¿ã§ã‚¯ãƒªã‚¢', icon: 'âš”ï¸ğŸ”«', tier: 'silver' },
    weapon_3: { id: 'weapon_3', name: 'ä¸‰éŠƒå£«', desc: 'æ­¦å™¨3ç¨®é¡ã®ã¿ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ¯ğŸ”«âš”ï¸', tier: 'silver' },
    all_weapons: { id: 'all_weapons', name: 'æ­¦å™¨ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼', desc: 'å…¨æ­¦å™¨å–å¾—ã—ã¦ã‚¯ãƒªã‚¢', icon: 'ğŸŒˆ', tier: 'silver' },
    awaken_blade: { id: 'awaken_blade', name: 'ãƒ–ãƒ¬ãƒ¼ãƒ‰ãƒã‚¹ã‚¿ãƒ¼', desc: 'Bladeè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'âš”ï¸', tier: 'silver' },
    awaken_shotgun: { id: 'awaken_shotgun', name: 'ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³ãƒã‚¹ã‚¿ãƒ¼', desc: 'Shotgunè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ’¥', tier: 'silver' },
    awaken_lightning: { id: 'awaken_lightning', name: 'é›·ç¥', desc: 'Lightningè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'âš¡', tier: 'silver' },
    awaken_nova: { id: 'awaken_nova', name: 'ãƒãƒ´ã‚¡ãƒã‚¹ã‚¿ãƒ¼', desc: 'Novaè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸŒŸ', tier: 'silver' },
    awaken_homing: { id: 'awaken_homing', name: 'ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ãƒã‚¹ã‚¿ãƒ¼', desc: 'Homingè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ¯', tier: 'silver' },
    awaken_ghost: { id: 'awaken_ghost', name: 'ã‚´ãƒ¼ã‚¹ãƒˆãƒã‚¹ã‚¿ãƒ¼', desc: 'Ghostè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ‘»', tier: 'silver' },
    awaken_rubber: { id: 'awaken_rubber', name: 'ãƒ©ãƒãƒ¼ãƒã‚¹ã‚¿ãƒ¼', desc: 'Rubberè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ¾', tier: 'silver' },
    awaken_rock: { id: 'awaken_rock', name: 'ãƒ­ãƒƒã‚¯ãƒã‚¹ã‚¿ãƒ¼', desc: 'Rockè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸª¨', tier: 'silver' },
    awaken_orbit: { id: 'awaken_orbit', name: 'ã‚ªãƒ¼ãƒ“ãƒƒãƒˆãƒã‚¹ã‚¿ãƒ¼', desc: 'Orbitè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ”„', tier: 'silver' },
    awaken_poison: { id: 'awaken_poison', name: 'ãƒã‚¤ã‚ºãƒ³ãƒã‚¹ã‚¿ãƒ¼', desc: 'Poisonè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ§ª', tier: 'silver' },
    awaken_laser: { id: 'awaken_laser', name: 'ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¹ã‚¿ãƒ¼', desc: 'Laserè¦šé†’ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ“¡', tier: 'silver' },
    laser_only: { id: 'laser_only', name: 'ãƒ“ãƒ¼ãƒ ã‚µãƒã‚¤ãƒãƒ¼', desc: 'Laserã®ã¿ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ“¡', tier: 'gold' },
    laser_no_damage: { id: 'laser_no_damage', name: 'ãƒ¬ãƒ¼ã‚¶ãƒ¼ç„¡åŒ', desc: 'Laserè¦šé†’ã§ãƒãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸30ç§’', icon: 'ğŸ“¡ğŸ›¡ï¸', tier: 'silver' },
    all_awaken: { id: 'all_awaken', name: 'ã‚°ãƒ©ãƒ³ãƒ‰ãƒã‚¹ã‚¿ãƒ¼', desc: 'ç´¯è¨ˆã§å…¨11ç¨®é¡è¦šé†’', icon: 'ğŸŒŸğŸŒŸğŸŒŸ', tier: 'platinum' },
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹MAXç³»
    max_hp_clear: { id: 'max_hp_clear', name: 'ã‚¿ãƒ³ã‚¯ãƒã‚¹ã‚¿ãƒ¼', desc: 'HP MAXã§ã‚¯ãƒªã‚¢', icon: 'ğŸ’ª', tier: 'gold' },
    max_damage_clear: { id: 'max_damage_clear', name: 'ãƒ‘ãƒ¯ãƒ¼ãƒã‚¦ã‚¹', desc: 'çƒã®ãƒ€ãƒ¡ãƒ¼ã‚¸MAXã§ã‚¯ãƒªã‚¢', icon: 'ğŸ’¥', tier: 'gold' },
    max_rate_clear: { id: 'max_rate_clear', name: 'ãƒã‚·ãƒ³ã‚¬ãƒ³ãƒŠãƒ¼', desc: 'æ”»æ’ƒé€Ÿåº¦MAXã§ã‚¯ãƒªã‚¢', icon: 'âš¡', tier: 'gold' },
    max_speed_clear: { id: 'max_speed_clear', name: 'ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ‡ãƒ¼ãƒ¢ãƒ³', desc: 'ç§»å‹•é€Ÿåº¦MAXã§ã‚¯ãƒªã‚¢', icon: 'ğŸƒ', tier: 'gold' },
    
    hardcore_2weapon: { id: 'hardcore_2weapon', name: 'ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒŸãƒ‹ãƒãƒªã‚¹ãƒˆ', desc: 'Hardcore + æ­¦å™¨2ç¨®é¡ä»¥ä¸‹', icon: 'ğŸ”¥âš”ï¸', tier: 'platinum' },
    blaster_speed: { id: 'blaster_speed', name: 'ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼é€Ÿæ”»', desc: 'Blasterã®ã¿ + 11åˆ†ä»¥å†…', icon: 'ğŸš€ğŸ”«', tier: 'platinum' },
    all_weapon_master: { id: 'all_weapon_master', name: 'çœŸã®æ­¦å™¨ãƒã‚¹ã‚¿ãƒ¼', desc: 'å…¨10ç¨®é¡ã®è¦šé†’ã‚¯ãƒªã‚¢é”æˆ', icon: 'ğŸ†', tier: 'platinum' },

    // ç¸›ã‚Šãƒ—ãƒ¬ã‚¤
    no_upgrade: { id: 'no_upgrade', name: 'åŸå§‹äºº', desc: 'ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãªã—ã§ã‚¯ãƒªã‚¢', icon: 'ğŸš«', tier: 'platinum' },
    no_item: { id: 'no_item', name: 'ç¦æ¬²ä¸»ç¾©è€…', desc: 'ã‚¢ã‚¤ãƒ†ãƒ ãªã—ã§ã‚¯ãƒªã‚¢ï¼ˆå®ç®±é™¤ãï¼‰', icon: 'ğŸš·', tier: 'platinum' },
    stoic: { id: 'stoic', name: 'ã‚¹ãƒˆã‚¤ãƒƒã‚¯', desc: 'ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãªã—ã‚¯ãƒªã‚¢', icon: 'ğŸ’ª', tier: 'platinum' },

    // è¶…é›£é–¢
    speed_1030: { id: 'speed_1030', name: 'ã‚½ãƒ‹ãƒƒã‚¯', desc: '10:30ã‚¯ãƒªã‚¢', icon: 'ğŸš€', tier: 'platinum' },
    no_damage: { id: 'no_damage', name: 'ç„¡å‚·ã®å‹åˆ©', desc: 'ãƒãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸ã§ã‚¯ãƒªã‚¢', icon: 'ğŸ›¡ï¸', tier: 'platinum' },
    hardcore_no_damage: { id: 'hardcore_no_damage', name: 'çœŸã®å®ŸåŠ›è€…', desc: 'Hardcoreãƒãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¯ãƒªã‚¢', icon: 'ğŸŒŸ', tier: 'platinum' },
    play_100: { id: 'play_100', name: 'å»ƒäºº', desc: 'ç·ãƒ—ãƒ¬ã‚¤100å›', icon: 'ğŸ®ğŸ®', tier: 'platinum' },
    total_kill_10000: { id: 'total_kill_10000', name: 'æ®²æ»…è€…', desc: 'ç´¯è¨ˆæ’ƒç ´10000ä½“', icon: 'ğŸ’€ğŸ’€ğŸ’€', tier: 'platinum' },
    all_complete: { id: 'all_complete', name: 'å®Œç’§ä¸»ç¾©è€…', desc: 'å…¨å®Ÿç¸¾ã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆ', icon: 'ğŸ”®', tier: 'platinum' }
  };

  // é€²æ—ãƒ‡ãƒ¼ã‚¿ï¼ˆç´¯ç©è¨˜éŒ²ç”¨ï¼‰
  let achievementProgress = {
    totalPlays: 0,
    totalKills: 0,
    totalBossKills: 0,
    totalGemsCollected: 0,
    totalChestsOpened: 0,
    totalRerolls: 0,
    awakenedWeapons: {}, // { blade: true, shotgun: true, ... }
    awakenClearCount: {} // { blade: 1, shotgun: 2, ... }
  };

  // ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ã‚»ãƒƒã‚·ãƒ§ãƒ³ç”¨ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
  let sessionTracking = {
    gemsCollected: 0,
    chestsOpened: 0,
    rerollCount: 0,
    itemsCollected: 0,
    upgradesTaken: 0,
    attackTimer: 0, // æ”»æ’ƒã—ã¦ã„ãªã„æ™‚é–“
    hp10Timer: 0, // HP10ä»¥ä¸‹ã®æ™‚é–“
    maxHpReached: 0,
    damageTaken: 0
  };

  function loadAchievements() {
    try {
      const data = localStorage.getItem(ACHIEVEMENTS_KEY);
      return data ? JSON.parse(data) : {};
    } catch (e) {
      return {};
    }
  }

  function saveAchievements(achievements) {
    try {
      localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(achievements));
    } catch (e) {
      console.error('Failed to save achievements:', e);
    }
  }

  function loadProgress() {
    try {
      const data = localStorage.getItem(ACHIEVEMENT_PROGRESS_KEY);
      if (data) {
        const loaded = JSON.parse(data);
        achievementProgress = { ...achievementProgress, ...loaded };
      }
    } catch (e) {
      console.error('Failed to load progress:', e);
    }
  }

  function saveProgress() {
    try {
      localStorage.setItem(ACHIEVEMENT_PROGRESS_KEY, JSON.stringify(achievementProgress));
    } catch (e) {
      console.error('Failed to save progress:', e);
    }
  }

  function unlockAchievement(achievementId) {
    const achievements = loadAchievements();
    if (achievements[achievementId]) return; // æ—¢ã«è§£é™¤æ¸ˆã¿

    achievements[achievementId] = {
      unlockedAt: new Date().toISOString()
    };
    saveAchievements(achievements);

    // é€šçŸ¥è¡¨ç¤º
    showAchievementNotification(achievementId);
    
    // ã‚¯ãƒªã‚¢æ™‚ã®å®Ÿç¸¾ã‚’è¨˜éŒ²ï¼ˆã‚¯ãƒªã‚¢ç”»é¢ã§è¡¨ç¤ºã™ã‚‹ãŸã‚ï¼‰
    if (!window._unlockedThisSession) window._unlockedThisSession = [];
    window._unlockedThisSession.push(achievementId);

    // å…¨å®Ÿç¸¾ã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
    const totalCount = Object.keys(ACHIEVEMENTS).length - 1; // all_completeé™¤ã
    const unlockedCount = Object.keys(achievements).length;
    if (unlockedCount === totalCount && !achievements.all_complete) {
      unlockAchievement('all_complete');
    }
  }

  function showAchievementNotification(achievementId) {
    const achievement = ACHIEVEMENTS[achievementId];
    if (!achievement) return;

    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      left: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      padding: 16px 20px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 10001;
      font-size: 14px;
      max-width: 300px;
      animation: slideInLeft 0.3s ease-out;
    `;
    
    notification.innerHTML = `
      <div style="font-size: 24px; margin-bottom: 4px;">${achievement.icon}</div>
      <div style="font-weight: bold; margin-bottom: 4px;">å®Ÿç¸¾è§£é™¤ï¼</div>
      <div style="font-size: 16px; font-weight: bold;">${achievement.name}</div>
      <div style="font-size: 12px; opacity: 0.9; margin-top: 4px;">${achievement.desc}</div>
    `;

    document.body.appendChild(notification);

    setTimeout(() => {
      notification.style.animation = 'slideOutLeft 0.3s ease-in';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  // ã‚¹ã‚¿ã‚¤ãƒ«è¿½åŠ 
  const achievementStyle = document.createElement('style');
  achievementStyle.textContent = `
    @keyframes slideInLeft {
      from { transform: translateX(-400px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOutLeft {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(-400px); opacity: 0; }
    }
  `;
  document.head.appendChild(achievementStyle);

  // åˆæœŸåŒ–
  loadProgress();

  // === å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯é–¢æ•° ===
  function checkAchievementsOnClear() {
    const totalKills = (state.kills || 0) + (state.bossKills || 0);
    
    // ã‚¯ãƒªã‚¢å®Ÿç¸¾
    unlockAchievement('first_clear');
    
    // Hardcoreã‚¯ãƒªã‚¢
    if (state.mode.hardcore) {
      unlockAchievement('hardcore_clear');
    }
    
    // ã‚¿ã‚¤ãƒ å®Ÿç¸¾
    const clearTime = state.timeSec;
    if (clearTime <= 630) unlockAchievement('speed_1030'); // 10:30
    if (clearTime <= 660) unlockAchievement('speed_11min'); // 11:00
    
    // HPå®Ÿç¸¾
    const hpPercent = (state.player.hp / state.player.maxHp) * 100;
    if (hpPercent >= 90) unlockAchievement('hp_90_clear');
    if (sessionTracking.damageTaken === 0) {
      unlockAchievement('no_damage');
      if (state.mode.hardcore) unlockAchievement('hardcore_no_damage');
    }
    
    // æ­¦å™¨æ•°å®Ÿç¸¾
    const weapons = state.weapons;
    const weaponCount = Object.keys(weapons).filter(k => weapons[k].lv > 0).length;
    
    if (weaponCount === 1) {
      unlockAchievement('pure_blaster'); // Blasterã®ã¿
      // â˜…Laserã®ã¿ã§ã‚¯ãƒªã‚¢
      if (weapons.laser && weapons.laser.lv > 0) {
        unlockAchievement('laser_only');
      }
    }
    if (weaponCount === 2) unlockAchievement('weapon_2');
    if (weaponCount === 3) unlockAchievement('weapon_3');
    if (weaponCount === 11) unlockAchievement('all_weapons'); // â˜…10â†’11ï¼ˆlaserè¿½åŠ ï¼‰
    
    // è¦šé†’å®Ÿç¸¾
    for (const key in weapons) {
      if (weapons[key].awaken) {
        unlockAchievement(`awaken_${key}`);
        
        // ç´¯ç©è¦šé†’ã‚«ã‚¦ãƒ³ãƒˆ
        if (!achievementProgress.awakenedWeapons[key]) {
          achievementProgress.awakenedWeapons[key] = true;
        }
        achievementProgress.awakenClearCount[key] = (achievementProgress.awakenClearCount[key] || 0) + 1;
      }
    }
    
    // å…¨è¦šé†’å®Ÿç¸¾
    const awakenedCount = Object.keys(achievementProgress.awakenedWeapons).length;
    if (awakenedCount >= 11) unlockAchievement('all_awaken'); // â˜…10â†’11ï¼ˆlaserè¿½åŠ ï¼‰
    
    // å…¨æ­¦å™¨è¦šé†’ã‚¯ãƒªã‚¢å®Ÿç¸¾
    const allAwakenCleared = Object.keys(achievementProgress.awakenClearCount).length >= 11; // â˜…10â†’11
    if (allAwakenCleared) unlockAchievement('all_weapon_master');
    
    // è¤‡åˆå®Ÿç¸¾
    if (state.mode.hardcore && weaponCount <= 2) {
      unlockAchievement('hardcore_2weapon');
    }
    if (weaponCount === 1 && clearTime <= 660) {
      unlockAchievement('blaster_speed');
    }
    
    // ç¸›ã‚Šãƒ—ãƒ¬ã‚¤å®Ÿç¸¾
    if (sessionTracking.upgradesTaken === 0) {
      unlockAchievement('no_upgrade');
    }
    if (sessionTracking.itemsCollected === 0) {
      unlockAchievement('no_item');
    }
    if (sessionTracking.upgradesTaken === 0 && sessionTracking.itemsCollected === 0) {
      unlockAchievement('stoic');
    }
    
    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹MAXå®Ÿç¸¾
    if (state.player.maxHp >= 220) { // CAPS.hpMax
      unlockAchievement('max_hp_clear');
    }
    if (state.mods.dmgMul >= 1.5) { // CAPS.dmgMulMax
      unlockAchievement('max_damage_clear');
    }
    if (state.mods.rateMul <= 0.60) { // CAPS.rateMulMinï¼ˆå°ã•ã„ã»ã©é€Ÿã„ï¼‰
      unlockAchievement('max_rate_clear');
    }
    if (state.player.speed >= 340) { // CAPS.speedMax
      unlockAchievement('max_speed_clear');
    }
    
    saveProgress();
  }

  function checkKillAchievements() {
    const totalKills = (state.kills || 0) + (state.bossKills || 0);
    
    // åˆæ’ƒç ´
    if (totalKills === 1) unlockAchievement('first_kill');
    
    // æ’ƒç ´æ•°å®Ÿç¸¾ï¼ˆç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ï¼‰
    if (totalKills >= 100) unlockAchievement('kill_100');
    if (totalKills >= 500) unlockAchievement('kill_500');
    
    // ãƒœã‚¹æ’ƒç ´æ•°ï¼ˆç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ï¼‰
    if (state.bossKills >= 10) unlockAchievement('boss_10');
    
    // ç´¯ç©æ’ƒç ´æ•°
    achievementProgress.totalKills++;
    achievementProgress.totalBossKills += (arguments[0] && (arguments[0].type === 'mid' || arguments[0].type === 'big' || arguments[0].type === 'final')) ? 1 : 0;
    
    if (achievementProgress.totalKills >= 5000) unlockAchievement('total_kill_5000');
    if (achievementProgress.totalKills >= 10000) unlockAchievement('total_kill_10000');
    
    saveProgress();
  }

  function checkLevelAchievements() {
    if (state.player.level >= 20) unlockAchievement('level_20');
    if (state.player.level >= 30) unlockAchievement('level_30');
  }

  function showAchievementsModal() {
    const achievements = loadAchievements();
    const totalCount = Object.keys(ACHIEVEMENTS).length;
    const unlockedCount = Object.keys(achievements).length;
    const progress = Math.floor((unlockedCount / totalCount) * 100);

    const tierOrder = { platinum: 4, gold: 3, silver: 2, bronze: 1 };
    const sortedAchievements = Object.values(ACHIEVEMENTS).sort((a, b) => {
      const tierDiff = tierOrder[b.tier] - tierOrder[a.tier];
      if (tierDiff !== 0) return tierDiff;
      return a.name.localeCompare(b.name);
    });

    let html = `
      <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:13030;overflow-y:auto;" id="achievementsModal">
        <div style="background:#1a1a2e;border:3px solid #8b5cf6;border-radius:12px;padding:20px;max-width:700px;width:90%;max-height:85vh;display:flex;flex-direction:column;">
          
          <!-- â˜…CLOSEãƒœã‚¿ãƒ³ã‚’ä¸Šéƒ¨ã«é…ç½® -->
          <button onclick="document.getElementById('achievementsModal').remove();" style="width:100%;padding:10px;background:#ef4444;color:#fff;border:none;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;margin-bottom:12px;">
            âœ• CLOSE
          </button>
          
          <h2 style="color:#8b5cf6;text-align:center;margin:0 0 10px 0;font-size:28px;">ğŸ–ï¸ å®Ÿç¸¾</h2>
          <div style="text-align:center;margin-bottom:20px;color:#fff;">
            <div style="font-size:18px;margin-bottom:8px;">${unlockedCount} / ${totalCount} è§£é™¤ (${progress}%)</div>
            <div style="background:#2a2a3e;border-radius:20px;height:24px;overflow:hidden;">
              <div style="background:linear-gradient(90deg, #8b5cf6, #a78bfa);height:100%;width:${progress}%;transition:width 0.3s;"></div>
            </div>
          </div>
          <div style="flex:1;overflow-y:auto;margin-bottom:10px;">
    `;

    for (const achievement of sortedAchievements) {
      const isUnlocked = !!achievements[achievement.id];
      const tierColors = {
        platinum: '#e5e7eb',
        gold: '#fbbf24',
        silver: '#94a3b8',
        bronze: '#d97706'
      };
      const tierColor = tierColors[achievement.tier];
      const bgColor = isUnlocked ? '#2a3a4e' : '#1a1a2e';
      const opacity = isUnlocked ? '1' : '0.5';

      html += `
        <div style="background:${bgColor};border:2px solid ${tierColor};border-radius:8px;padding:12px;margin-bottom:8px;opacity:${opacity};">
          <div style="display:flex;align-items:center;gap:12px;">
            <div style="font-size:32px;">${achievement.icon}</div>
            <div style="flex:1;">
              <div style="font-size:16px;font-weight:bold;color:#fff;margin-bottom:4px;">${achievement.name}</div>
              <div style="font-size:13px;color:#aaa;">${achievement.desc}</div>
            </div>
            ${isUnlocked ? '<div style="font-size:24px;">âœ…</div>' : '<div style="font-size:24px;opacity:0.3;">ğŸ”’</div>'}
          </div>
        </div>
      `;
    }

    html += `
          </div>
        </div>
      </div>
    `;

    const modal = document.createElement('div');
    modal.innerHTML = html;
    document.body.appendChild(modal);
  }

  // === ã‚²ãƒ¼ãƒ ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡ŒçŠ¶æ³ï¼‰ ===
  window.SAVE_DATA_KEY = '10min-survivor-save-v1';

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹
  window.loadSaveData = function() {
    try {
      const data = localStorage.getItem(window.SAVE_DATA_KEY);
      return data ? JSON.parse(data) : {};
    } catch (e) {
      console.error('Failed to load save data:', e);
      return {};
    }
  }

  window.saveSaveData = function(data) {
    try {
      localStorage.setItem(window.SAVE_DATA_KEY, JSON.stringify(data));
    } catch (e) {
      console.error('Failed to save data:', e);
    }
  }
  
  // å³æ™‚é–¢æ•°å†…ã‹ã‚‰ã‚‚å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«ã‚‚ä»£å…¥
  const loadSaveData = window.loadSaveData;
  const saveSaveData = window.saveSaveData;

  // === åŠ¹æœéŸ³ã‚·ã‚¹ãƒ†ãƒ  ===
  let audioCtx = null;
  let soundEnabled = true;

  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return audioCtx;
  }

  // åŠ¹æœéŸ³ï¼šæ­¦å™¨ç™ºå°„ï¼ˆæ§ãˆã‚ï¼‰
  function playShotSound(weaponType = 'blaster') {
    if (!soundEnabled) return;
    const ctx = initAudio();
    const t = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    if (weaponType === 'blaster') {
      osc.frequency.setValueAtTime(300, t);
      osc.frequency.exponentialRampToValueAtTime(150, t + 0.05);
      gain.gain.setValueAtTime(0.03, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
    } else if (weaponType === 'shotgun') {
      osc.type = 'square';
      osc.frequency.setValueAtTime(180, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.08);
      gain.gain.setValueAtTime(0.04, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    } else if (weaponType === 'blade') {
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(500, t);
      osc.frequency.exponentialRampToValueAtTime(200, t + 0.06);
      gain.gain.setValueAtTime(0.025, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
    } else if (weaponType === 'nova') {
      osc.frequency.setValueAtTime(400, t);
      osc.frequency.exponentialRampToValueAtTime(250, t + 0.1);
      gain.gain.setValueAtTime(0.02, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    } else if (weaponType === 'orbit') {
      osc.frequency.setValueAtTime(350, t);
      gain.gain.setValueAtTime(0.015, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
    } else if (weaponType === 'ghost') {
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(450, t);
      osc.frequency.exponentialRampToValueAtTime(300, t + 0.07);
      gain.gain.setValueAtTime(0.022, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
    } else if (weaponType === 'rock') {
      osc.type = 'square';
      osc.frequency.setValueAtTime(120, t);
      osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
      gain.gain.setValueAtTime(0.035, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    } else if (weaponType === 'poison') {
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(280, t);
      osc.frequency.exponentialRampToValueAtTime(180, t + 0.15);
      gain.gain.setValueAtTime(0.018, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    } else if (weaponType === 'lightning') {
      // ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ï¼šé«˜å‘¨æ³¢ã§ãƒãƒãƒãƒã—ãŸéŸ³
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.exponentialRampToValueAtTime(400, t + 0.12);
      gain.gain.setValueAtTime(0.06, t); // éŸ³é‡å¤§ãã‚
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    } else if (weaponType === 'laser') {
      // â˜…ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼šä½ãæŸ”ã‚‰ã‹ã„ãƒ“ãƒ¼ãƒ éŸ³
      osc.type = 'sine';  // â˜…sawtoothâ†’sineï¼ˆæŸ”ã‚‰ã‹ãï¼‰
      osc.frequency.setValueAtTime(60, t);   // â˜…80â†’60ï¼ˆã‚ˆã‚Šä½ãï¼‰
      osc.frequency.linearRampToValueAtTime(80, t + 0.15);
      osc.frequency.linearRampToValueAtTime(70, t + 0.4);
      gain.gain.setValueAtTime(0.04, t);     // â˜…0.08â†’0.04ï¼ˆéŸ³é‡æ§ãˆã‚ï¼‰
      gain.gain.linearRampToValueAtTime(0.03, t + 0.3);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
    }
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  // åŠ¹æœéŸ³ï¼šæ•µæ’ƒç ´
  function playKillSound(enemyType = 'normal') {
    if (!soundEnabled) return;
    const ctx = initAudio();
    const t = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    if (enemyType === 'normal') {
      // é€šå¸¸æ•µï¼šçŸ­ãè»½ã„
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(200, t + 0.08);
      gain.gain.setValueAtTime(0.05, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    } else if (enemyType === 'mid') {
      // ä¸­ãƒœã‚¹ï¼šæ´¾æ‰‹ã«ï¼ˆ0.15ç§’ â†’ 0.35ç§’ï¼‰
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(900, t);
      osc.frequency.exponentialRampToValueAtTime(120, t + 0.35);
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    } else if (enemyType === 'big') {
      // å¤§ãƒœã‚¹ï¼šã‹ãªã‚Šæ´¾æ‰‹ï¼ˆ0.25ç§’ â†’ 0.6ç§’ï¼‰
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      
      osc.type = 'square';
      osc.frequency.setValueAtTime(1200, t);
      osc.frequency.exponentialRampToValueAtTime(80, t + 0.6);
      gain.gain.setValueAtTime(0.18, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
      
      osc2.type = 'sawtooth';
      osc2.frequency.setValueAtTime(900, t);
      osc2.frequency.exponentialRampToValueAtTime(60, t + 0.6);
      gain2.gain.setValueAtTime(0.12, t);
      gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
      
      osc2.connect(gain2);
      gain2.connect(ctx.destination);
      osc2.start(t);
      osc2.stop(t + 0.7);
    } else if (enemyType === 'final') {
      // ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ãƒœã‚¹ï¼šè¶…æ´¾æ‰‹ï¼ˆ0.4ç§’ â†’ 1.2ç§’ï¼‰
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      const osc3 = ctx.createOscillator();
      const gain3 = ctx.createGain();
      
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(1500, t);
      osc.frequency.exponentialRampToValueAtTime(60, t + 1.2);
      gain.gain.setValueAtTime(0.22, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
      
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(1000, t);
      osc2.frequency.exponentialRampToValueAtTime(40, t + 1.2);
      gain2.gain.setValueAtTime(0.15, t);
      gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
      
      osc3.frequency.setValueAtTime(750, t);
      osc3.frequency.exponentialRampToValueAtTime(30, t + 1.2);
      gain3.gain.setValueAtTime(0.12, t);
      gain3.gain.exponentialRampToValueAtTime(0.001, t + 1.2);
      
      osc2.connect(gain2);
      gain2.connect(ctx.destination);
      osc2.start(t);
      osc2.stop(t + 1.3);
      
      osc3.connect(gain3);
      gain3.connect(ctx.destination);
      osc3.start(t);
      osc3.stop(t + 1.3);
    }
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(t);
    osc.stop(t + 1.5);
  }

  // åŠ¹æœéŸ³ï¼šãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
  function playLevelUpSound() {
    if (!soundEnabled) return;
    const ctx = initAudio();
    const t = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.frequency.setValueAtTime(400, t);
    osc.frequency.setValueAtTime(600, t + 0.05);
    osc.frequency.setValueAtTime(800, t + 0.1);
    
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  // åŠ¹æœéŸ³ï¼šã‚¢ã‚¤ãƒ†ãƒ å–å¾—
  function playItemSound() {
    if (!soundEnabled) return;
    const ctx = initAudio();
    const t = ctx.currentTime;
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, t);
    osc.frequency.setValueAtTime(1000, t + 0.04);
    
    gain.gain.setValueAtTime(0.06, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(t);
    osc.stop(t + 0.15);
  }

  // åŠ¹æœéŸ³ï¼šãƒœã‚¹å‡ºç¾è­¦å‘Š
  function playBossWarningSound(isFinal = false) {
    if (!soundEnabled) return;
    const ctx = initAudio();
    const t = ctx.currentTime;
    
    if (isFinal) {
      // ãƒ©ã‚¹ãƒœã‚¹ï¼šã‚ˆã‚Šé‡åšãªè­¦å‘ŠéŸ³
      const osc1 = ctx.createOscillator();
      const gain1 = ctx.createGain();
      const osc2 = ctx.createOscillator();
      const gain2 = ctx.createGain();
      
      osc1.type = 'sawtooth';
      osc1.frequency.setValueAtTime(180, t);
      osc1.frequency.setValueAtTime(180, t + 0.15);
      osc1.frequency.setValueAtTime(180, t + 0.3);
      gain1.gain.setValueAtTime(0.15, t);
      gain1.gain.setValueAtTime(0.15, t + 0.15);
      gain1.gain.setValueAtTime(0.15, t + 0.3);
      gain1.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(90, t);
      gain2.gain.setValueAtTime(0.12, t);
      gain2.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
      
      osc1.connect(gain1);
      gain1.connect(ctx.destination);
      osc1.start(t);
      osc1.stop(t + 0.55);
      
      osc2.connect(gain2);
      gain2.connect(ctx.destination);
      osc2.start(t);
      osc2.stop(t + 0.55);
    } else {
      // é€šå¸¸ãƒœã‚¹ï¼šçŸ­ã‚ã®è­¦å‘ŠéŸ³
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      
      osc.type = 'square';
      osc.frequency.setValueAtTime(220, t);
      osc.frequency.setValueAtTime(220, t + 0.12);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.setValueAtTime(0.1, t + 0.12);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(t);
      osc.stop(t + 0.35);
    }
  }


  const state = {
    t:0, last:performance.now(), paused:true, started:false,
    player:{ x:200, y:200, r:14, speed:170, maxHp:110, hp:110, xp:0, level:1, nextXp: (lv)=> 24 + (lv*lv*6), iTime: 0, // ç„¡æ•µæ®‹ã‚Šæ™‚é–“ï¼ˆç§’ï¼‰
  kbx: 0, kby: 0, // ãƒãƒƒã‚¯ãƒãƒƒã‚¯é€Ÿåº¦ï¼ˆpx/sï¼‰
},
    input:{ vx:0, vy:0, keys:{} , lastDir:{x:1,y:0}},
    enemies:[], bullets:[], enemyBullets:[], gems:[], sparks:[], effects:[], items:[],
    weapons:{}, upgradesTaken:new Set(), owned:new Set(['blaster']),
    spawnTimer:0, difficulty:1, timeSec:0, finalSpawned:false,
    score:0, kills:0, bossKills:0, killScore:0, bossBonus:0, // ã‚¹ã‚³ã‚¢é–¢é€£
    mods:{ sizeMul:1.0, rateMul:1.0, dmgMul:1.0, damageMul:1.0 },  // damageMul: è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ï¼ˆ1.0=é€šå¸¸ã€0.6=40%è»½æ¸›ï¼‰
    pickupLv: 0,
    defenseLv: 0, // è€ä¹…åŠ›ãƒ¬ãƒ™ãƒ«ï¼ˆæ–°èƒ½åŠ›ï¼‰
    regenLv: 0, // è‡ªç„¶å›å¾©ãƒ¬ãƒ™ãƒ«
    bossTimer: 9999, bigBossTimer: 9999,
        gather:{ active:false, time:0, dur:0.5, totalXP:0 },
        gather:{ active:false, time:0, dur:0.5, totalXP:0 },
magnet:{ active:false, time:0, dur:1.0, speed:1800 },
    winCountdown: 0,
  mode: {
    hardcore: false,          // ç¾åœ¨ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã‹ï¼Ÿ
    unlockedHardcore: false,  // ãƒãƒ¼ãƒ‰ã‚³ã‚¢è§£æ”¾æ¸ˆã¿ï¼Ÿ
  },
  currentStage: 'stage1',  // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸
  obstacles: []  // ã‚¹ãƒ†ãƒ¼ã‚¸2ã®éšœå®³ç‰©
  
  };
  
  window.state = state; // â† ã“ã‚Œã‚’å¿…ãšè¿½åŠ ï¼ˆå‚ç…§ã‚’å˜ä¸€åŒ–ï¼‰

  // UI
  const lvEl = document.getElementById('lv');
  const hpw = document.getElementById('hpw');
  const hpValEl = document.getElementById('hpval'); // â† è¿½åŠ 
  const xpw = document.getElementById('xpw');
const timeFloatEl = document.getElementById('timeFloat');
  const levelupEl = document.getElementById('levelup');
  const cardRow = document.getElementById('cardRow');
  const wepEl = document.getElementById('wep');
// #bossmsg ã‚’å‰Šé™¤ã—ã¦ã„ã¦ã‚‚è½ã¡ãªã„ã‚ˆã†ã«ãƒ€ãƒŸãƒ¼ã‚’å½“ã¦ã‚‹
const bossMsg = document.getElementById('bossmsg') || {
  style: {},
  classList: { add(){}, remove(){}, toggle(){}, contains(){ return false; } },
  remove(){},
  set textContent(_){}, get textContent(){ return ''; }
};
  const gatherEl = document.getElementById('gather');
  const gbar = document.getElementById('gbar');
  const chestEl = document.getElementById('chest');
  const chestRow = document.getElementById('chestRow');
  const chestHUD = document.getElementById('chestHUD');
  const pickLeftEl = document.getElementById('pickLeft');
  const startEl = document.getElementById('start');
if (!startBtn) {
  console.warn('[init] start button not found');
}  
// StartæŠ¼ä¸‹ã§BGMã‚’èª­ã¿è¾¼ã¿ï¼†å†ç”Ÿï¼ˆ1å›ã ã‘ï¼‰
(function(){
  const btn = document.getElementById('startBtn');
  if (!btn || !window.bgm) return;

  btn.addEventListener('click', ()=>{
    try{
      // AudioContext ã‚’ç¢ºå®Ÿã«ç”¨æ„ï¼†å†é–‹
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();

      // BGM ã‚’å¿…ãšãƒ­ãƒ¼ãƒ‰â†’éŸ³é‡è¨­å®šâ†’å†ç”Ÿ
      bgm.load('main.mp3');      // index.html ã¨åŒã˜éšå±¤ã®ãƒ•ã‚¡ã‚¤ãƒ«å
      bgm.setVolume(0.09);       // åˆæœŸéŸ³é‡ï¼ˆ0.18ã®50%ï¼‰
      const p = bgm.play();
      if (p && p.catch) p.catch(e=>console.warn('BGM play blocked:', e));
    }catch(e){
      console.warn('BGM start error:', e);
    }
  }, {once:true});
})();

// ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã‚¹ã‚¿ãƒ¼ãƒˆæŠ¼ä¸‹ã§ã‚‚BGMã‚’èª­ã¿è¾¼ã¿ï¼†å†ç”Ÿï¼ˆ1å›ã ã‘ï¼‰
(function(){
  const btn = document.getElementById('startHardcoreBtn');
  if (!btn || !window.bgm) return;

  btn.addEventListener('click', ()=>{
    try{
      // AudioContext ã‚’ç¢ºå®Ÿã«ç”¨æ„ï¼†å†é–‹
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();

      // BGM ã‚’å¿…ãšãƒ­ãƒ¼ãƒ‰â†’éŸ³é‡è¨­å®šâ†’å†ç”Ÿ
      bgm.load('main.mp3');      // index.html ã¨åŒã˜éšå±¤ã®ãƒ•ã‚¡ã‚¤ãƒ«å
      bgm.setVolume(0.09);       // åˆæœŸéŸ³é‡ï¼ˆ0.18ã®50%ï¼‰
      const p = bgm.play();
      if (p && p.catch) p.catch(e=>console.warn('BGM play blocked:', e));
    }catch(e){
      console.warn('BGM start error:', e);
    }
  }, {once:true});
})();

  
  const goEl = document.getElementById('gameover');
  // === å¤§ãã„ã‚¹ã‚³ã‚¢è¡¨ç¤º ç”¨ã‚¹ã‚¿ã‚¤ãƒ«æ³¨å…¥ï¼ˆ1å›ã ã‘ï¼‰ ===
(() => {
  if (document.getElementById('score-style')) return;
  const st = document.createElement('style'); st.id = 'score-style';
  st.textContent = `
  .final-score{
    font-size: clamp(36px, 9vw, 84px);
    font-weight: 900;
    letter-spacing: .02em;
    line-height: 1.05;
    margin: .2rem 0 .6rem;
    text-shadow: 0 4px 20px rgba(0,0,0,.35);
  }
  .final-sub{
    font-size: clamp(12px, 2.8vw, 18px);
    opacity: .9;
    margin-bottom: .6rem;
  }
  `;
  document.head.appendChild(st);
})();
  const retryBtn = document.getElementById('retryBtn');
  const clearEl = document.getElementById('gameclear');
const replayBtn = document.getElementById('replayBtn');

// === camera zoom resolverï¼ˆå…¨ç«¯æœ«ã§ç­‰å€å›ºå®šã€‚æ‹¡å¤§ãƒ»ç¸®å°ã‚’ç¦æ­¢ï¼‰ ===
function computeCameraZoom(){
  state.cameraZoom = 1.0;
}

function ensureTopHud(){
  const host = document.getElementById('hudTop');
  if (!host || host.dataset.init) return;

  host.dataset.init = '1';
  host.innerHTML = `
    <div class="tophud tophud3" style="height:100%;display:flex;flex-direction:column;gap:6px;padding:0 10px;">
      <!-- 1è¡Œç›®ï¼šHP -->
      <div class="row row1" style="display:flex;align-items:center;gap:8px;">
        <span class="label" style="font-size:12px;opacity:.9;min-width:28px;text-align:right;">HP</span>
        <div class="bar hp" style="position:relative;flex:1;height:14px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);border-radius:8px;overflow:hidden">
          <!-- åˆæœŸã¯ç·‘ã§æç”»ï¼ˆå¾Œã§JSãŒï¼…ã«å¿œã˜ã¦èµ¤ã¸åˆ‡æ›¿ï¼‰-->
          <i id="hpTop" style="position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#27e38a,#12c574)"></i>
        </div>
        <span class="v" id="hpTopVal" style="font-weight:700;letter-spacing:.02em;white-space:nowrap"></span>
      </div>

      <!-- 2è¡Œç›®ï¼šEX -->
      <div class="row row2" style="display:flex;align-items:center;gap:8px;">
        <span class="label" style="font-size:12px;opacity:.9;min-width:28px;text-align:right;">EX</span>
        <div class="bar xp" style="position:relative;flex:1;height:14px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);border-radius:8px;overflow:hidden">
          <i id="xpTop" style="position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#6ae3ff,#4da6ff)"></i>
        </div>
        <span class="v" id="xpTopVal" style="font-weight:700;letter-spacing:.02em;white-space:nowrap"></span>
      </div>

      <!-- 3è¡Œç›®ï¼šLv / WL / ã‚¿ã‚¤ãƒãƒ¼ -->
      <div class="row row3" style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
        <span class="v" style="font-weight:700;letter-spacing:.02em">Lv <b id="lvTop">1</b> / WL <b id="wlTop">1</b></span>
        <span class="v" id="timeTop" style="font-weight:800;letter-spacing:.03em">0:00</span>
      </div>
    </div>
  `;
}



const pauseBtn = document.getElementById('btnPause'); 
// åˆæœŸçŠ¶æ…‹ã§ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«è¡¨ç¤ºï¼‰
if (pauseBtn) pauseBtn.style.display = 'none';

// === Floating Joystick listeners ===
let joyBase = document.getElementById('joyBase');
let joyKnob = document.getElementById('joyKnob');
// ç„¡ã‘ã‚Œã°å‹•çš„ã«ä½œã‚‹ï¼ˆHTMLè¿½è¨˜æ¼ã‚Œå¯¾ç­–ï¼‰
if (!joyBase) { joyBase = document.createElement('div'); joyBase.id = 'joyBase'; document.body.appendChild(joyBase); }
if (!joyKnob) { joyKnob = document.createElement('div'); joyKnob.id = 'joyKnob'; document.body.appendChild(joyKnob); }


function joyShow(x,y){
  joyBase.style.left = x+'px'; joyBase.style.top = y+'px';
  joyKnob.style.left = x+'px'; joyKnob.style.top = y+'px';
  joyBase.style.display = 'block'; joyKnob.style.display = 'block';
}
function joyMove(x,y){
  const r = state.touchJoy.radius;
  let dx = x - state.touchJoy.x0, dy = y - state.touchJoy.y0;
  const len = Math.hypot(dx,dy) || 1;
  const clamp = Math.min(1, len / r);
  dx = dx / len * clamp; dy = dy / len * clamp;
  state.touchJoy.dx = dx; state.touchJoy.dy = dy;
  joyKnob.style.left = (state.touchJoy.x0 + dx * r) + 'px';
  joyKnob.style.top  = (state.touchJoy.y0 + dy * r) + 'px';
}
function joyHide(){
  joyBase.style.display = 'none'; joyKnob.style.display = 'none';
  state.touchJoy.active = false; state.touchJoy.id = null;
  state.touchJoy.dx = 0; state.touchJoy.dy = 0;
}

// ã©ã“ã‚’æŠ¼ã—ã¦ã‚‚ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å‡ºç¾ï¼ˆPCã¯ç„¡è¦–ã•ã‚Œã‚‹ï¼‰
cv.addEventListener('touchstart', (ev)=>{
  const t = ev.changedTouches[0];
  if (!t) return;
  // æ—¢ã«ä»–ã®æŒ‡ã§ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ä½¿ç”¨ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆå¿…è¦ãªã‚‰2æœ¬ç›®ã¯æ”»æ’ƒãªã©ã«æ‹¡å¼µå¯èƒ½ï¼‰
  if (state.touchJoy.active) return;

  state.touchJoy.active = true;
  state.touchJoy.id = t.identifier;
  state.touchJoy.x0 = t.clientX; state.touchJoy.y0 = t.clientY;
  joyShow(state.touchJoy.x0, state.touchJoy.y0);
  joyMove(t.clientX, t.clientY);
  ev.preventDefault();
}, {passive:false});

cv.addEventListener('touchmove', (ev)=>{
  if (!state.touchJoy.active) return;
  for (const t of ev.changedTouches){
    if (t.identifier === state.touchJoy.id){
      joyMove(t.clientX, t.clientY);
      ev.preventDefault(); break;
    }
  }
}, {passive:false});

cv.addEventListener('touchend', (ev)=>{
  if (!state.touchJoy.active) return;
  for (const t of ev.changedTouches){
    if (t.identifier === state.touchJoy.id){
      joyHide(); ev.preventDefault(); break;
    }
  }
}, {passive:false});

cv.addEventListener('touchcancel', ()=>{ joyHide(); }, {passive:true});



const scoreVal = document.getElementById('scoreVal');



// === Startç”»é¢: H/N/F ãƒ‡ãƒãƒƒã‚°ã‚­ãƒ¼ï¼ˆã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤ºä¸­ã®ã¿æœ‰åŠ¹ï¼‰ ===
(function(){
  function showStartToast(msg){
    const host = document.getElementById('start') || document.body;
    let t = host.querySelector?.('#startToast');
    if (!t){
      t = document.createElement('div');
      t.id = 'startToast';
      t.style.cssText = 'position:absolute;left:50%;transform:translateX(-50%);top:14%;padding:.4em .8em;background:rgba(0,0,0,.6);color:#fff;border-radius:8px;font-weight:600;opacity:0;transition:opacity .12s ease;pointer-events:none;z-index:9999';
      host.appendChild(t);
    }
    t.textContent = msg;
    requestAnimationFrame(()=>{ t.style.opacity = '1'; });
    setTimeout(()=>{ t.style.opacity = '0'; }, 900);
  }

  // â˜…ãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ–‡å­—åˆ—å…¥åŠ›æ–¹å¼ï¼‰
  let debugBuffer = '';
  let debugTimer = null;
  
  document.addEventListener('keydown', (ev)=>{
    // ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤ºä¸­ã®ã¿æœ‰åŠ¹
    const s = document.getElementById('start');
    if (!s || s.style.display === 'none') return;
    window.state = window.state || {};
    state.mode = state.mode || {};

    const k = ev.key.toLowerCase();
    if (k.length === 1 && /[a-z0-9]/.test(k)) {
      debugBuffer += k;
      
      // 3ç§’å¾Œã«ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢
      if (debugTimer) clearTimeout(debugTimer);
      debugTimer = setTimeout(() => { debugBuffer = ''; }, 3000);
      
      // ã‚³ãƒãƒ³ãƒ‰ãƒã‚§ãƒƒã‚¯
      if (debugBuffer.endsWith('powerup')) {
        // å…¨æ­¦å™¨ãƒ•ãƒ«ãƒ‘ãƒ¯ãƒ¼ï¼ˆè¦šé†’ï¼‰ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
        state._debugFullPower = true;
        showStartToast('ğŸ”¥ FULL POWER MODE!');
        debugBuffer = '';
      } else if (debugBuffer.endsWith('fboss')) {
        // ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ãƒœã‚¹æˆ¦ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠã¸ï¼‰+ ä¸»äººå…¬ç„¡æ•µ
        state._debugSkipToFinal = true;
        state._didSkipFinal = false;
        state._debugInvincible = true; // â˜…ä¸»äººå…¬ç„¡æ•µ
        showStartToast('ğŸ‘¹ FINAL BOSS MODE! (ç„¡æ•µ)');
        debugBuffer = '';
      } else if (debugBuffer.endsWith('debug2')) {
        // ã‚¹ãƒ†ãƒ¼ã‚¸1ã‚¯ãƒªã‚¢æ¸ˆã¿ã«ã™ã‚‹
        const saveData = loadSaveData();
        if (!saveData.stageProgress) saveData.stageProgress = {};
        if (!saveData.stageProgress.stage1) saveData.stageProgress.stage1 = {};
        saveData.stageProgress.stage1.cleared = true;
        saveSaveData(saveData);
        STAGES.stage2.unlocked = true;
        showStartToast('ğŸ”“ STAGE 2 UNLOCKED!');
        debugBuffer = '';
      }
    }
  }, {passive:true});
})();

// â˜…ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šå…¨æ­¦å™¨ãƒ•ãƒ«ãƒ‘ãƒ¯ãƒ¼åŒ–
function applyDebugFullPower() {
  if (!state._debugFullPower) return;
  state._debugFullPower = false;
  
  // å…¨æ­¦å™¨ã‚’Lv3 + è¦šé†’
  if (state.weapons) {
    for (const key in state.weapons) {
      const w = state.weapons[key];
      if (w && typeof w.lv !== 'undefined') {
        w.lv = 3;
        w.awaken = true;
      }
    }
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼·åŒ–
  state.player.maxHp = 300;
  state.player.hp = 300;
  state.player.speed = 280;
  state.mods.dmgMul = 2.0;
  state.mods.rateMul = 0.5;
}


// ã‚¯ãƒªãƒƒã‚¯ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆ
replayBtn.onclick = () => {
  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¶ˆå»
  const rankingModal = document.getElementById('rankingModal');
  if (rankingModal) rankingModal.remove();
  
  // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  state.gameover = false;
  state._pendingRanking = null;
  
  state.mode.hardcore = false;      // â† ãƒãƒ¼ãƒãƒ«ã§å†æŒ‘æˆ¦
  clearEl.style.display='none';
  resetGame();
  syncPauseButton();
};

// ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³
const titleBtn = document.getElementById('titleBtn');
if (titleBtn) {
  titleBtn.onclick = () => {
    // ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    closeAllModals();
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¶ˆå»
    const rankingModal = document.getElementById('rankingModal');
    if (rankingModal) rankingModal.remove();
    
    // ã‚¯ãƒªã‚¢ç”»é¢ã‚’éš ã™
    clearEl.style.display = 'none';
    
    // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚’è¡¨ç¤º
    const startEl = document.getElementById('start');
    if (startEl) startEl.style.display = 'flex';
    
    // ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
    state.started = false;
    state.gameover = false;
    state.paused = true;
    state.manualPaused = false;
    state._pendingRanking = null; // ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    state._debugInvincible = false; // ãƒ‡ãƒãƒƒã‚°ç„¡æ•µã‚’ãƒªã‚»ãƒƒãƒˆ
    state._debugSkipToFinal = false; // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
    state._didSkipFinal = false;
    
    // é…åˆ—ã‚’ã‚¯ãƒªã‚¢
    state.enemies.length = 0;
    state.bullets.length = 0;
    state.enemyBullets.length = 0;
    state.gems.length = 0;
    state.items.length = 0;
    state.effects.length = 0;
    state.sparks.length = 0;
    
    // ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
    if (pauseBtn) pauseBtn.style.display = 'none';
  };
}

// resetGame() ã®æœ€å¾Œã‚ãŸã‚Šã§ã‚¯ãƒªã‚¢ç”»é¢ã‚‚éš ã™
clearEl.style.display = 'none';
  
async function tryFullscreenAndLandscape(){
  // WebViewã‚„iOSã§ã¯å…¨ã¦ã‚¹ã‚­ãƒƒãƒ—ï¼ˆã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isWebView = /(WebView|wv|FBAN|FBAV|Instagram|Claude)/i.test(navigator.userAgent);
  if (isIOS || isWebView) return Promise.resolve();
  
  return new Promise((resolve) => {
    try {
      // ã‚¿ãƒƒãƒç«¯æœ«åˆ¤å®š
      const isTouch =
        (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) ||
        ('ontouchstart' in window) ||
        (navigator.maxTouchPoints > 0);

      // PCã‚„ file: ã§ã¯ã‚¹ã‚­ãƒƒãƒ—
      if (!isTouch || location.protocol === 'file:') {
        resolve();
        return;
      }

      // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ï¼ˆAndroid Chromeç­‰ï¼‰
      const el = document.documentElement;
      if (el.requestFullscreen) {
        el.requestFullscreen()
          .then(() => {
            // ç”»é¢å›è»¢ãƒ­ãƒƒã‚¯
            if (screen.orientation && typeof screen.orientation.lock === 'function') {
              screen.orientation.lock('landscape').catch(() => {});
            }
          })
          .catch(() => {})
          .finally(() => resolve());
      } else {
        resolve();
      }
    } catch (e) {
      resolve();
    }
  });
}


// === Start ãƒœã‚¿ãƒ³ï¼šå˜ä¸€ã®å®Œæˆç‰ˆãƒãƒ³ãƒ‰ãƒ©ï¼ˆé‡è¤‡ç¦æ­¢ï¼‰ ===
if (typeof window.__START_BOUND === 'undefined') window.__START_BOUND = false;

if (!window.__START_BOUND) {
  const startBtn = document.getElementById('startBtn') || document.querySelector('#start .btn');
  if (startBtn) {
    window.__START_BOUND = true;
    startBtn.onclick = () => {
      // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠç”»é¢ã‚’è¡¨ç¤ºï¼ˆé€šå¸¸ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
      window._pendingHardcore = false;
      showStageSelect();
    };
  } else {
    console.warn('[init] start button not found');
  }
  
  // ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
  const startHardcoreBtn = document.getElementById('startHardcoreBtn');
  if (startHardcoreBtn) {
    startHardcoreBtn.onclick = () => {
      // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠç”»é¢ã‚’è¡¨ç¤ºï¼ˆãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
      window._pendingHardcore = true;
      showStageSelect();
    };
  }
  
  // RANKINGãƒœã‚¿ãƒ³
  const rankingBtn = document.getElementById('rankingBtn');
  if (rankingBtn) {
    rankingBtn.onclick = () => {
      showRankingModal();
    };
  }
  
  // å®Ÿç¸¾ãƒœã‚¿ãƒ³
  const achievementsBtn = document.getElementById('achievementsBtn');
  if (achievementsBtn) {
    achievementsBtn.onclick = () => {
      showAchievementsModal();
    };
  }
  
  // æ›´æ–°å±¥æ­´ãƒœã‚¿ãƒ³
  const updateLogBtn = document.getElementById('updateLogBtn');
  if (updateLogBtn) {
    updateLogBtn.onclick = () => {
      const modal = document.getElementById('updateLogModal');
      if (modal) modal.style.display = 'block';
    };
  }
  
  // è¨­å®šãƒœã‚¿ãƒ³
  const settingsBtn = document.getElementById('settingsBtn');
  if (settingsBtn) {
    settingsBtn.onclick = () => {
      const modal = document.getElementById('settingsModal');
      if (modal) {
        // ç¾åœ¨ã®éŸ³é‡ã‚’åæ˜ 
        const bgmVol = Math.round((window.bus?.bgm?.gain?.value || 0.25) * 100);
        const sfxVol = Math.round((window.bus?.sfx?.gain?.value || 0.9) * 100);
        
        const bgmSlider = document.getElementById('settingsBgmVolume');
        const sfxSlider = document.getElementById('settingsSfxVolume');
        const bgmValue = document.getElementById('settingsBgmValue');
        const sfxValue = document.getElementById('settingsSfxValue');
        
        if (bgmSlider) bgmSlider.value = bgmVol;
        if (sfxSlider) sfxSlider.value = sfxVol;
        if (bgmValue) bgmValue.textContent = bgmVol + '%';
        if (sfxValue) sfxValue.textContent = sfxVol + '%';
        
        modal.style.display = 'block';
      }
    };
  }
  
  // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
  const closeSettings = document.getElementById('closeSettings');
  if (closeSettings) {
    closeSettings.onclick = () => {
      const modal = document.getElementById('settingsModal');
      if (modal) modal.style.display = 'none';
    };
  }
  
  // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã®éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
  const settingsBgmSlider = document.getElementById('settingsBgmVolume');
  const settingsSfxSlider = document.getElementById('settingsSfxVolume');
  
  if (settingsBgmSlider) {
    settingsBgmSlider.oninput = () => {
      const val = settingsBgmSlider.value / 100;
      // BGMã¯bgm.setVolume()ã‚’ä½¿ç”¨ï¼ˆBG.gainã‚’ç›´æ¥å¤‰æ›´ï¼‰
      if (window.bgm && typeof bgm.setVolume === 'function') {
        bgm.setVolume(val * 0.36); // å…ƒã®setVolume(0.09)ã¯ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼25%ç›¸å½“ãªã®ã§ã€0.36ã‚’æ›ã‘ã¦èª¿æ•´
      }
      const bgmValue = document.getElementById('settingsBgmValue');
      if (bgmValue) bgmValue.textContent = settingsBgmSlider.value + '%';
      // localStorage ã«ä¿å­˜
      try { localStorage.setItem('bgmVolume', settingsBgmSlider.value); } catch(e){}
    };
  }
  
  if (settingsSfxSlider) {
    settingsSfxSlider.oninput = () => {
      const val = settingsSfxSlider.value / 100;
      if (window.bus?.sfx) bus.sfx.gain.value = val;
      if (window.bus?.ui) bus.ui.gain.value = val * 0.9;
      const sfxValue = document.getElementById('settingsSfxValue');
      if (sfxValue) sfxValue.textContent = settingsSfxSlider.value + '%';
      // localStorage ã«ä¿å­˜
      try { localStorage.setItem('sfxVolume', settingsSfxSlider.value); } catch(e){}
    };
  }
  
  // ä¿å­˜ã•ã‚ŒãŸéŸ³é‡ã‚’èª­ã¿è¾¼ã¿ãƒ»é©ç”¨
  try {
    const savedBgm = localStorage.getItem('bgmVolume');
    const savedSfx = localStorage.getItem('sfxVolume');
    if (savedBgm !== null) {
      const val = savedBgm / 100;
      if (window.bgm && typeof bgm.setVolume === 'function') {
        bgm.setVolume(val * 0.36);
      }
    }
    if (savedSfx !== null && window.bus?.sfx) {
      bus.sfx.gain.value = savedSfx / 100;
      if (bus.ui) bus.ui.gain.value = (savedSfx / 100) * 0.9;
    }
  } catch(e){}
}


retryBtn.onclick = () => { 
  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¶ˆå»
  const rankingModal = document.getElementById('rankingModal');
  if (rankingModal) rankingModal.remove();
  
  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’éš ã™
  if (goEl) goEl.style.display = 'none';
  
  // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  state.gameover = false;
  state._pendingRanking = null;
  
  ensureEndScoreNodes();
  resetGame(); 
  syncPauseButton(); 
};

// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã®ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³
const titleBtnGameover = document.getElementById('titleBtnGameover');
const gameoverEl = document.getElementById('gameover');
if (titleBtnGameover && gameoverEl) {
  titleBtnGameover.onclick = () => {
    // ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    closeAllModals();
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¶ˆå»
    const rankingModal = document.getElementById('rankingModal');
    if (rankingModal) rankingModal.remove();
    
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’éš ã™
    gameoverEl.style.display = 'none';
    
    // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‚’è¡¨ç¤º
    const startEl = document.getElementById('start');
    if (startEl) startEl.style.display = 'flex';
    
    // ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
    state.started = false;
    state.gameover = false;
    state.paused = true;
    state.manualPaused = false;
    state._pendingRanking = null; // ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤ºã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    state._debugInvincible = false; // ãƒ‡ãƒãƒƒã‚°ç„¡æ•µã‚’ãƒªã‚»ãƒƒãƒˆ
    state._debugSkipToFinal = false; // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
    state._didSkipFinal = false;
    
    // é…åˆ—ã‚’ã‚¯ãƒªã‚¢
    state.enemies.length = 0;
    state.bullets.length = 0;
    state.enemyBullets.length = 0;
    state.gems.length = 0;
    state.items.length = 0;
    state.effects.length = 0;
    state.sparks.length = 0;
    
    // ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
    if (pauseBtn) pauseBtn.style.display = 'none';
  };
}


function syncPauseButton(){
  if (!pauseBtn) return;
  // è¡¨ç¤ºã¯ manualPaused ã‚’è¦‹ã¦æ±ºã‚ã‚‹ï¼ˆâ–¶=åœæ­¢ä¸­ï¼â¸=å‹•ä½œä¸­ï¼‰
  const showingPlay = !!state.manualPaused;
  pauseBtn.textContent = showingPlay ? 'â–¶' : 'â¸';
  pauseBtn.setAttribute('aria-label', showingPlay ? 'Resume' : 'Pause');
}

// ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
function showPauseMenu() {
  state.manualPaused = true;
  syncPauseButton();
  
  // æ—¢å­˜ã®ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
  const existing = document.getElementById('pauseMenuModal');
  if (existing) existing.remove();
  
  const modal = document.createElement('div');
  modal.id = 'pauseMenuModal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: flex; align-items: center;
    justify-content: center; z-index: 15000; backdrop-filter: blur(4px);
  `;
  
  const container = document.createElement('div');
  container.style.cssText = `
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border: 2px solid #475569; border-radius: 16px; padding: 20px;
    max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
  `;
  
  // ã‚¿ã‚¤ãƒˆãƒ«
  const title = document.createElement('h2');
  title.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
  title.style.cssText = 'color: #fff; margin: 0 0 16px 0; font-size: 24px; text-align: center;';
  container.appendChild(title);
  
  // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
  const statusSection = document.createElement('div');
  statusSection.style.cssText = 'margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;';
  
  const timeSec = state.timeSec || 0;
  const minutes = Math.floor(timeSec / 60);
  const seconds = Math.floor(timeSec % 60);
  const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  statusSection.innerHTML = `
    <div style="display: flex; justify-content: space-around; text-align: center; color: #94a3b8; font-size: 14px;">
      <div><div style="font-size: 20px; color: #fff; font-weight: bold;">â± ${timeStr}</div>çµŒéæ™‚é–“</div>
      <div><div style="font-size: 20px; color: #fff; font-weight: bold;">Lv.${state.player?.level || 1}</div>ãƒ¬ãƒ™ãƒ«</div>
      <div><div style="font-size: 20px; color: #fff; font-weight: bold;">${(state.kills || 0).toLocaleString()}</div>è¨ä¼æ•°</div>
    </div>
  `;
  container.appendChild(statusSection);
  
  // æ­¦å™¨ä¸€è¦§
  const weaponSection = document.createElement('div');
  weaponSection.style.cssText = 'margin-bottom: 16px;';
  
  const weaponTitle = document.createElement('h3');
  weaponTitle.textContent = 'âš”ï¸ æ‰€æŒæ­¦å™¨';
  weaponTitle.style.cssText = 'color: #60a5fa; margin: 0 0 8px 0; font-size: 16px;';
  weaponSection.appendChild(weaponTitle);
  
  const weaponGrid = document.createElement('div');
  weaponGrid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;';
  
  const weapons = state.weapons;
  for (const key in weapons) {
    const w = weapons[key];
    if (w.lv > 0) {
      const item = document.createElement('div');
      item.style.cssText = `
        background: rgba(96,165,250,0.15); border: 1px solid rgba(96,165,250,0.3);
        border-radius: 6px; padding: 8px; font-size: 13px;
      `;
      const awakenBadge = w.awaken ? '<span style="color:#fbbf24; font-size:11px;"> â˜…è¦šé†’</span>' : '';
      item.innerHTML = `
        <div style="color: #fff; font-weight: bold;">${w.name || key} ${awakenBadge}</div>
        <div style="color: #94a3b8; font-size: 12px;">Lv.${w.lv}${w.lv >= 3 ? ' (MAX)' : ''}</div>
      `;
      weaponGrid.appendChild(item);
    }
  }
  weaponSection.appendChild(weaponGrid);
  container.appendChild(weaponSection);
  
  // èƒ½åŠ›ã‚¢ãƒƒãƒ—ä¸€è¦§
  const abilitySection = document.createElement('div');
  abilitySection.style.cssText = 'margin-bottom: 20px;';
  
  const abilityTitle = document.createElement('h3');
  abilityTitle.textContent = 'ğŸ“Š èƒ½åŠ›å¼·åŒ–';
  abilityTitle.style.cssText = 'color: #10b981; margin: 0 0 8px 0; font-size: 16px;';
  abilitySection.appendChild(abilityTitle);
  
  const abilityGrid = document.createElement('div');
  abilityGrid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px;';
  
  // èƒ½åŠ›ã®çŠ¶æ…‹ã‚’åé›†
  const abilities = [];
  const p = state.player;
  const m = state.mods;
  
  if (p.maxHp > 120) abilities.push({ name: 'HPä¸Šé™', value: `${Math.floor(p.maxHp)}` });
  if (p.speed > 180) abilities.push({ name: 'ç§»å‹•é€Ÿåº¦', value: `${Math.floor(p.speed)}` });
  if (p.regen > 0) abilities.push({ name: 'HPå›å¾©', value: `${p.regen.toFixed(1)}/s` });
  if (m.dmgMul > 1.0) abilities.push({ name: 'æ”»æ’ƒåŠ›', value: `${Math.round(m.dmgMul * 100)}%` });
  if (m.rateMul < 1.0) abilities.push({ name: 'æ”»æ’ƒé€Ÿåº¦', value: `${Math.round((1/m.rateMul) * 100)}%` });
  if (m.sizeMul > 1.0) abilities.push({ name: 'å¼¾ã‚µã‚¤ã‚º', value: `${Math.round(m.sizeMul * 100)}%` });
  if (m.damageMul < 1.0) abilities.push({ name: 'è€ä¹…åŠ›', value: `-${Math.round((1 - m.damageMul) * 100)}%è¢«ãƒ€ãƒ¡` });
  if (p.pickupRange > 60) abilities.push({ name: 'å›åç¯„å›²', value: `${Math.floor(p.pickupRange)}` });
  if (m.doubleItem) abilities.push({ name: 'Wãƒ‰ãƒ­ãƒƒãƒ—', value: 'æœ‰åŠ¹' });
  
  if (abilities.length === 0) {
    const noAbility = document.createElement('div');
    noAbility.style.cssText = 'color: #64748b; font-size: 13px; padding: 8px;';
    noAbility.textContent = 'èƒ½åŠ›å¼·åŒ–ãªã—';
    abilityGrid.appendChild(noAbility);
  } else {
    for (const ab of abilities) {
      const item = document.createElement('div');
      item.style.cssText = `
        background: rgba(16,185,129,0.15); border: 1px solid rgba(16,185,129,0.3);
        border-radius: 6px; padding: 8px; font-size: 13px;
      `;
      item.innerHTML = `
        <div style="color: #fff; font-weight: bold;">${ab.name}</div>
        <div style="color: #94a3b8; font-size: 12px;">${ab.value}</div>
      `;
      abilityGrid.appendChild(item);
    }
  }
  abilitySection.appendChild(abilityGrid);
  container.appendChild(abilitySection);
  
  // éŸ³é‡èª¿æ•´ã‚»ã‚¯ã‚·ãƒ§ãƒ³
  const volumeSection = document.createElement('div');
  volumeSection.style.cssText = 'margin-bottom: 20px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;';
  
  const volumeTitle = document.createElement('h3');
  volumeTitle.textContent = 'ğŸ”Š éŸ³é‡è¨­å®š';
  volumeTitle.style.cssText = 'color: #f59e0b; margin: 0 0 12px 0; font-size: 16px;';
  volumeSection.appendChild(volumeTitle);
  
  // ç¾åœ¨ã®éŸ³é‡ã‚’å–å¾—ï¼ˆlocalStorageã‹ã‚‰ã€ãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
  let currentBgmVol = 25, currentSfxVol = 90;
  try {
    const savedBgm = localStorage.getItem('bgmVolume');
    const savedSfx = localStorage.getItem('sfxVolume');
    if (savedBgm !== null) currentBgmVol = parseInt(savedBgm);
    if (savedSfx !== null) currentSfxVol = parseInt(savedSfx);
  } catch(e){}
  
  // BGMéŸ³é‡
  const bgmRow = document.createElement('div');
  bgmRow.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 10px;';
  bgmRow.innerHTML = `
    <span style="color: #94a3b8; font-size: 14px; width: 60px;">BGM</span>
    <input type="range" id="bgmVolume" min="0" max="100" value="${currentBgmVol}" style="flex: 1; cursor: pointer;">
    <span id="bgmVolValue" style="color: #fff; font-size: 14px; width: 40px; text-align: right;">${currentBgmVol}%</span>
  `;
  volumeSection.appendChild(bgmRow);
  
  // åŠ¹æœéŸ³éŸ³é‡
  const sfxRow = document.createElement('div');
  sfxRow.style.cssText = 'display: flex; align-items: center; gap: 10px;';
  sfxRow.innerHTML = `
    <span style="color: #94a3b8; font-size: 14px; width: 60px;">åŠ¹æœéŸ³</span>
    <input type="range" id="sfxVolume" min="0" max="100" value="${currentSfxVol}" style="flex: 1; cursor: pointer;">
    <span id="sfxVolValue" style="color: #fff; font-size: 14px; width: 40px; text-align: right;">${currentSfxVol}%</span>
  `;
  volumeSection.appendChild(sfxRow);
  
  container.appendChild(volumeSection);
  
  // éŸ³é‡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå¾Œã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼‰
  setTimeout(() => {
    const bgmSlider = document.getElementById('bgmVolume');
    const sfxSlider = document.getElementById('sfxVolume');
    const bgmValue = document.getElementById('bgmVolValue');
    const sfxValue = document.getElementById('sfxVolValue');
    
    if (bgmSlider) {
      bgmSlider.oninput = () => {
        const val = bgmSlider.value / 100;
        // BGMã¯bgm.setVolume()ã‚’ä½¿ç”¨
        if (window.bgm && typeof bgm.setVolume === 'function') {
          bgm.setVolume(val * 0.36);
        }
        if (bgmValue) bgmValue.textContent = bgmSlider.value + '%';
        try { localStorage.setItem('bgmVolume', bgmSlider.value); } catch(e){}
      };
    }
    if (sfxSlider) {
      sfxSlider.oninput = () => {
        const val = sfxSlider.value / 100;
        if (window.bus?.sfx) bus.sfx.gain.value = val;
        if (window.bus?.ui) bus.ui.gain.value = val * 0.9;
        if (sfxValue) sfxValue.textContent = sfxSlider.value + '%';
        try { localStorage.setItem('sfxVolume', sfxSlider.value); } catch(e){}
      };
    }
  }, 0);
  
  // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢
  const buttonArea = document.createElement('div');
  buttonArea.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
  
  // ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹ãƒœã‚¿ãƒ³
  const resumeBtn = document.createElement('button');
  resumeBtn.textContent = 'â–¶ ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹';
  resumeBtn.style.cssText = `
    background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    color: #fff; border: none; padding: 14px 20px; border-radius: 8px;
    font-size: 16px; font-weight: bold; cursor: pointer;
    box-shadow: 0 4px 12px rgba(16,185,129,0.3);
  `;
  resumeBtn.onclick = () => {
    modal.remove();
    state.manualPaused = false;
    syncPauseButton();
  };
  buttonArea.appendChild(resumeBtn);
  
  // ãƒªã‚¿ã‚¤ã‚¢ãƒœã‚¿ãƒ³
  const retireBtn = document.createElement('button');
  retireBtn.textContent = 'ğŸšª ãƒªã‚¿ã‚¤ã‚¢ï¼ˆã‚²ãƒ¼ãƒ çµ‚äº†ï¼‰';
  retireBtn.style.cssText = `
    background: linear-gradient(135deg, #64748b 0%, #475569 100%);
    color: #fff; border: none; padding: 12px 20px; border-radius: 8px;
    font-size: 14px; font-weight: bold; cursor: pointer;
    box-shadow: 0 4px 12px rgba(100,116,139,0.3);
  `;
  retireBtn.onclick = () => {
    modal.remove();
    state.manualPaused = false;
    // ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    closeAllModals();
    triggerGameOver();
  };
  buttonArea.appendChild(retireBtn);
  
  container.appendChild(buttonArea);
  modal.appendChild(container);
  document.body.appendChild(modal);
  
  // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.remove();
      state.manualPaused = false;
      syncPauseButton();
    }
  };
}

// ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
function closePauseMenu() {
  const modal = document.getElementById('pauseMenuModal');
  if (modal) {
    modal.remove();
    state.manualPaused = false;
    syncPauseButton();
  }
}

// ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ãƒ»ãƒªã‚¿ã‚¤ã‚¢æ™‚ç”¨ï¼‰
function closeAllModals() {
  const modalIds = [
    'pauseMenuModal',
    'startBonusModal', 
    'rankingModal',
    'achievementsModal'
  ];
  // å‹•çš„ç”Ÿæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã¯å‰Šé™¤
  for (const id of modalIds) {
    const el = document.getElementById(id);
    if (el) el.remove();
  }
  // HTMLã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ¼ãƒ€ãƒ«ã¯å‰Šé™¤ã›ãšéè¡¨ç¤ºã«
  const stageModal = document.getElementById('stageSelectModal');
  if (stageModal) stageModal.style.display = 'none';
  const updateModal = document.getElementById('updateLogModal');
  if (updateModal) updateModal.style.display = 'none';
  const settingsModal = document.getElementById('settingsModal');
  if (settingsModal) settingsModal.style.display = 'none';
  
  // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ãƒ»å®ç®±ç”»é¢ã‚‚é–‰ã˜ã‚‹
  if (levelupEl) levelupEl.style.display = 'none';
  if (chestEl) chestEl.style.display = 'none';
  if (chestHUD) chestHUD.style.display = 'none';
}


if (pauseBtn){
  pauseBtn.onclick = () => {
    // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—/å®ç®±ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä¸­ã¯ç„¡åŠ¹åŒ–
    const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
    const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
    if (lvlOpen || chestOpen) return;
    
    // ã‚²ãƒ¼ãƒ ãŒå§‹ã¾ã£ã¦ã„ãªã‘ã‚Œã°ç„¡è¦–
    if (!state.started || state.gameover) return;

    // æ—¢ã«ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ã¦ã„ã‚Œã°é–‰ã˜ã‚‹ã€ãªã‘ã‚Œã°é–‹ã
    const existingMenu = document.getElementById('pauseMenuModal');
    if (existingMenu) {
      closePauseMenu();
    } else {
      showPauseMenu();
    }
  };
}

// === Game Over ä¸€æ‹¬å‡¦ç† ===
function triggerGameOver(){
  if (state.gameover) return;
  state.gameover = true;

  // å…¥åŠ›ã‚’æ­¢ã‚ã‚‹
  state.manualPaused = false;
  if (state.input){ state.input.vx = 0; state.input.vy = 0; }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼éè¡¨ç¤ºï¼ˆæç”»å´ã§ã‚‚è¦‹ãªã„ï¼‰
  if (state.player) state.player.visible = false;

  // UI
  if (goEl) goEl.style.display = 'flex';
  
  ensureEndScoreNodes();
  updateEndScore('over');

  // ã‚¹ã‚³ã‚¢ä¿å­˜ï¼ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯è‡ªå‹•è¡¨ç¤ºã—ãªã„ï¼‰
  const scoreData = createScoreData('gameover');
  saveScore(scoreData);

  // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯OFF
  delete document.body.dataset.fjoy;
}

// === ã‚¨ãƒ³ãƒ‰ç”»é¢ï¼ˆGO/ã‚¯ãƒªã‚¢ï¼‰ã«å¤§ã‚¹ã‚³ã‚¢ã‚’å·®ã—è¾¼ã‚€ ===
function ensureEndScoreNodes(){
  // GameOver
  if (goEl){
    let big = goEl.querySelector('.final-score');
    if (!big){
      big = document.createElement('div');
      big.className = 'final-score';
      goEl.insertBefore(big, goEl.firstChild);
    }
    let sub = goEl.querySelector('.final-sub');
    if (!sub){
      sub = document.createElement('div');
      sub.className = 'final-sub';
      goEl.insertBefore(sub, big.nextSibling);
    }
  }
  // Clear
  if (clearEl){
    let big = clearEl.querySelector('.final-score');
    if (!big){
      big = document.createElement('div');
      big.className = 'final-score';
      clearEl.insertBefore(big, clearEl.firstChild);
    }
    let sub = clearEl.querySelector('.final-sub');
    if (!sub){
      sub = document.createElement('div');
      sub.className = 'final-sub';
      clearEl.insertBefore(sub, big.nextSibling);
    }
  }
}

function updateEndScore(kind){ // kind: 'over' | 'clear'
  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ã‚³ã‚¢ã‚’åŸºæº–ã«
  const baseScore = state.score || 0;
  let score = baseScore;
  
  // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã®ãƒœãƒ¼ãƒŠã‚¹
  let timeBonus = 0;
  let clearBonus = 0;
  
  if (kind === 'clear') {
    // ã‚¯ãƒªã‚¢ãƒœãƒ¼ãƒŠã‚¹
    clearBonus = 10000;
    
    // ã‚¿ã‚¤ãƒ ãƒœãƒ¼ãƒŠã‚¹ï¼ˆ13åˆ†åŸºæº–ã€1000ç‚¹/ç§’ï¼‰
    const clearTime = state.timeSec;
    const targetTime = 780; // 13åˆ†
    if (clearTime < targetTime) {
      timeBonus = Math.floor((targetTime - clearTime) * 1000);
    }
    
    score += clearBonus + timeBonus;
    state.score += clearBonus + timeBonus; // state.scoreã«ã‚‚åæ˜ 
  }

  const root = (kind === 'clear') ? clearEl : goEl;
  if (!root) return;
  const big = root.querySelector('.final-score');
  const sub = root.querySelector('.final-sub');

  const key  = (state.mode && state.mode.hardcore) ? 'best_hc' : 'best';
  let prev = 0;
  try { prev = +(localStorage.getItem(key) || 0) || 0; } catch(_) {}
  const best = Math.max(score, prev);
  try { localStorage.setItem(key, String(best)); } catch(_) {}

  if (big) big.textContent = `SCORE  ${score.toLocaleString()}` + (score > prev ? '  â˜…NEW!' : '');
  const totalKills = (state.kills || 0) + (state.bossKills || 0);
  
  // è©³ç´°è¡¨ç¤º
  const detail = kind === 'clear' 
    ? `Base: ${baseScore.toLocaleString()}  +  Clear: ${clearBonus.toLocaleString()}  +  Time: ${timeBonus.toLocaleString()}  =  Best: ${best.toLocaleString()}`
    : `Kill: ${totalKills}ä½“   Best: ${best.toLocaleString()}`;
  if (sub) sub.textContent = detail;
}



// === ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ« ===
function showStageSelect() {
  const modal = document.getElementById('stageSelectModal');
  const cardsContainer = document.getElementById('stageCards');
  
  // nullãƒã‚§ãƒƒã‚¯
  if (!modal || !cardsContainer) {
    console.warn('Stage select modal elements not found');
    return;
  }
  
  const saveData = window.loadSaveData();
  const isHardcore = window._pendingHardcore || false;
  
  cardsContainer.innerHTML = '';
  
  // ãƒ¢ãƒ¼ãƒ‰ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º
  const modeHeader = document.createElement('div');
  modeHeader.style.cssText = 'margin-bottom:1rem; text-align:center;';
  modeHeader.innerHTML = isHardcore 
    ? '<span style="color:#a78bfa; font-size:1.2rem; font-weight:700;">ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰</span>'
    : '<span style="color:#60a5fa; font-size:1.2rem; font-weight:700;">é€šå¸¸ãƒ¢ãƒ¼ãƒ‰</span>';
  cardsContainer.appendChild(modeHeader);
  
  // ã‚¹ãƒ†ãƒ¼ã‚¸1
  const stage1Card = document.createElement('div');
  stage1Card.style.cssText = 'background:#334155; border-radius:12px; padding:1.5rem; cursor:pointer; transition:all 0.2s; margin-bottom:1rem;';
  stage1Card.innerHTML = `
    <h3 style="margin:0 0 0.5rem; color:#60a5fa; font-size:1.4rem;">â–  ${STAGES.stage1.name}</h3>
    <p style="margin:0 0 0.5rem; color:#cbd5e1;">å››è§’ã„æ•µã¨ã®åŸºæœ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã€‚éšœå®³ç‰©ãªã—ã€‚</p>
    ${saveData.stageProgress?.stage1?.cleared ? '<span style="color:#10b981;">âœ“ ã‚¯ãƒªã‚¢æ¸ˆã¿</span>' : '<span style="color:#94a3b8;">æœªã‚¯ãƒªã‚¢</span>'}
  `;
  stage1Card.onmouseenter = () => stage1Card.style.background = '#475569';
  stage1Card.onmouseleave = () => stage1Card.style.background = '#334155';
  stage1Card.onclick = () => startStage('stage1', isHardcore).catch(e => console.warn(e));
  cardsContainer.appendChild(stage1Card);
  
  // ã‚¹ãƒ†ãƒ¼ã‚¸2
  const stage1Cleared = saveData.stageProgress?.stage1?.cleared || false;
  const stage2Card = document.createElement('div');
  stage2Card.style.cssText = `background:${stage1Cleared ? '#334155' : '#1e293b'}; border-radius:12px; padding:1.5rem; ${stage1Cleared ? 'cursor:pointer;' : 'opacity:0.5;'}`;
  stage2Card.innerHTML = `
    <h3 style="margin:0 0 0.5rem; color:#ec4899; font-size:1.4rem;">â–² ${STAGES.stage2.name}</h3>
    <p style="margin:0 0 0.5rem; color:#cbd5e1;">ä¸‰è§’ã®æ•µã¨éšœå®³ç‰©ã®ã‚ã‚‹ä¸Šç´šè€…å‘ã‘ã‚¹ãƒ†ãƒ¼ã‚¸ã€‚</p>
    ${stage1Cleared ? 
      (saveData.stageProgress?.stage2?.cleared ? '<span style="color:#10b981;">âœ“ ã‚¯ãƒªã‚¢æ¸ˆã¿</span>' : '<span style="color:#94a3b8;">æœªã‚¯ãƒªã‚¢</span>') :
      '<span style="color:#ef4444;">ğŸ”’ ã‚¹ãƒ†ãƒ¼ã‚¸1ã‚’ã‚¯ãƒªã‚¢ã§è§£æ”¾</span>'
    }
  `;
  if (stage1Cleared) {
    stage2Card.onmouseenter = () => stage2Card.style.background = '#475569';
    stage2Card.onmouseleave = () => stage2Card.style.background = '#334155';
    stage2Card.onclick = () => startStage('stage2', isHardcore).catch(e => console.warn(e));
  }
  cardsContainer.appendChild(stage2Card);
  
  // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
  document.getElementById('closeStageSelect').onclick = () => {
    modal.style.display = 'none';
  };
  
  modal.style.display = 'flex';
  modal.style.alignItems = 'center';
  modal.style.justifyContent = 'center';
}

async function startStage(stageId, hardcore) {
  try {
    ensureEndScoreNodes();
    
    // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³è©¦è¡Œï¼ˆå¤±æ•—ã—ã¦ã‚‚ç¶šè¡Œï¼‰
    try {
      await tryFullscreenAndLandscape();
    } catch(e) { /* ç„¡è¦– */ }
    
    // â˜…BGMå†ç”Ÿå‡¦ç†ã‚’è¿½åŠ 
    try {
      if (window.initAudioOnce) initAudioOnce();
      if (window.AC && AC.state === 'suspended') AC.resume();
      if (window.bgm) {
        bgm.load('main.mp3');
        bgm.setVolume(0.09);
        const p = bgm.play();
        if (p && p.catch) p.catch(() => {});
      }
    } catch(e) { /* ç„¡è¦– */ }
    
    state.currentStage = stageId;
    state.mode.hardcore = hardcore;
    resetGame();
    state.started = true;
    state.paused = false;
    document.getElementById('start').style.display = 'none';
    document.getElementById('stageSelectModal').style.display = 'none';
    state.last = performance.now();
    syncPauseButton();
    // ãƒãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
    if (pauseBtn) pauseBtn.style.display = '';
  } catch(e) {
    console.warn('startStage error:', e);
  }
}


  function resetGame(){
    // ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å®Ÿç¸¾ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
    window._unlockedThisSession = [];
    
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ãƒªã‚»ãƒƒãƒˆ
    sessionTracking = {
      gemsCollected: 0,
      chestsOpened: 0,
      rerollCount: 0,
      itemsCollected: 0,
      upgradesTaken: 0,
      attackTimer: 0,
      hp10Timer: 0,
      maxHpReached: state.player?.hp || 110,
      damageTaken: 0
    };

    // ç·ãƒ—ãƒ¬ã‚¤å›æ•°ã‚«ã‚¦ãƒ³ãƒˆ
    achievementProgress.totalPlays++;
    saveProgress();
    
    // åˆãƒ—ãƒ¬ã‚¤å®Ÿç¸¾
    if (achievementProgress.totalPlays === 1) {
      unlockAchievement('first_play');
    }
    
    // ãƒ—ãƒ¬ã‚¤å›æ•°å®Ÿç¸¾
    if (achievementProgress.totalPlays >= 10) unlockAchievement('play_10');
    if (achievementProgress.totalPlays >= 100) unlockAchievement('play_100');

    // Clear arrays
    state.enemies.length=0; state.bullets.length=0; state.enemyBullets.length=0;
    state.gems.length=0; state.sparks.length=0; state.effects.length=0; state.items.length=0;



// Reset player
state.player.x = WORLD.w * 0.5;
state.player.y = WORLD.h * 0.5;
state.player.aimAngle = 0; // åˆæœŸå‘ãï¼ˆå³å‘ãç›¸å½“ï¼‰

    state.player.r = 14;
    state.player.speed = 180;      // â˜…170â†’180ï¼ˆå°‘ã—é€Ÿãï¼‰
    state.player.maxHp = 120;      // â˜…110â†’120ï¼ˆå°‘ã—ç¡¬ãï¼‰
    state.player.hp = 120;
    state.player.xp = 0;
    state.player.level = 1;
    state.player.iTime = 0;
state.player.kbx = 0;
state.player.kby = 0;
state.pickupLv = 0;
state.defenseLv = 0; // è€ä¹…åŠ›ãƒ¬ãƒ™ãƒ«ãƒªã‚»ãƒƒãƒˆ
state.regenLv = 0; // è‡ªç„¶å›å¾©ãƒ¬ãƒ™ãƒ«ãƒªã‚»ãƒƒãƒˆ
    // Reset meta
    state.manualPaused = false;
    state.mods.sizeMul = 1.0;
    state.mods.damageMul = 1.0; // è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ãƒªã‚»ãƒƒãƒˆ
    state.spawnTimer = 0;
    state.difficulty = 1;
    state.timeSec = 0;
    state.finalSpawned = false;
    state.bossTimer = 9999;
    state.bigBossTimer = 9999;
    state.gather.active = false; state.gather.time = 0; state.gather.totalXP = 0;
    state.gather.active = false; state.gather.time = 0; state.gather.totalXP = 0;
state.magnet.active = false; state.magnet.time = 0;

      state.winCountdown = 0;
    state.score = 0;
state.killScore = 0;
state.bossBonus = 0;
state.kills = 0;
state.bossKills = 0;

    // éšœå®³ç‰©ã®åˆæœŸåŒ–ï¼ˆç›¸å¯¾åº§æ¨™â†’å®Ÿåº§æ¨™ã«å¤‰æ›ï¼‰
    const currentStageData = STAGES[state.currentStage];
    state.obstacles = [];
    
    if (currentStageData.obstaclesTemplate) {
      // â˜…ç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ã¦æŸ±ã®ã‚µã‚¤ã‚ºã‚’ã‚¹ã‚±ãƒ¼ãƒ«
      // åŸºæº–: 960x540 â†’ å°ã•ã„ç”»é¢ã§ã¯æŸ±ã‚‚å°ã•ã
      const baseWidth = 960;
      const baseHeight = 540;
      const cvs = document.getElementById('c');  // â˜…canvasã‚’å–å¾—
      const screenScale = Math.min(
        (cvs ? cvs.width : baseWidth) / baseWidth,
        (cvs ? cvs.height : baseHeight) / baseHeight,
        1.0  // æœ€å¤§1.0ï¼ˆå¤§ç”»é¢ã§ã‚‚æŸ±ã¯å¤§ããã—ã™ããªã„ï¼‰
      );
      const minScale = 0.5; // æœ€å°50%
      const sizeScale = Math.max(minScale, screenScale);
      
      for (const template of currentStageData.obstaclesTemplate) {
        state.obstacles.push({
          x: WORLD.w * template.rx,  // ç›¸å¯¾åº§æ¨™ã‚’å®Ÿåº§æ¨™ã«
          y: WORLD.h * template.ry,
          size: template.size * sizeScale  // â˜…ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨
        });
      }
    }


// === touch joystick state ===
// æ—¢ã«ã‚ã‚Œã°ä½¿ã„å›ã—ã€ç„¡ã‘ã‚Œã°ä½œæˆ
if (!state.touchJoy) {
  state.touchJoy = { active:false, id:null, x0:0, y0:0, x:0, y:0, dx:0, dy:0, radius:56 };
} else {
  state.touchJoy.active = false;
  state.touchJoy.id = null;
  state.touchJoy.x0 = 0; state.touchJoy.y0 = 0;
  state.touchJoy.x = 0;  state.touchJoy.y = 0;
  state.touchJoy.dx = 0; state.touchJoy.dy = 0;
  state.touchJoy.radius = 56; // æ“ä½œæ„Ÿã¯ã“ã“ã§èª¿æ•´
}

    // Reset upgrades
    state.upgradesTaken = new Set();
    state.owned = new Set(['blaster']);
    // Reset weapons
    for(const k in state.weapons){
      const w = state.weapons[k];
      w.lv = (k==='blaster')? 1 : 0;
      w.awaken = false;
      if('cd' in w) w.cd = 0;
      if(k==='orbit'){ w.ang = 0; }
    }
    
    state.gameover = false;
if (state.player) state.player.visible = true;
    
    // UI
    levelupEl.style.display='none';
    chestEl.style.display='none';
    chestHUD.style.display='none';
if (gatherEl) gatherEl.style.display = 'none';
    goEl.style.display='none';
    state.started = true;
    state.paused = false;
    state.last = performance.now();
    clearEl.style.display='none';
    
    // === score & records ===
state.score = 0;                 // ç¾åœ¨ã‚¹ã‚³ã‚¢
state.killScore = 0;             // ã‚­ãƒ«ã®ã¿ã®åŠ ç®—è¿½è·¡ï¼ˆä»»æ„ï¼‰
state.bossBonus = 0;             // ãƒœã‚¹æ’ƒç ´ãƒœãƒ¼ãƒŠã‚¹

// === viewport zoomï¼ˆç¸¦ç”»é¢ã¯å°‘ã—å¼•ãï¼‰===
computeCameraZoom();


state.records = JSON.parse(localStorage.getItem('vs_records') || '[]'); // [{score,timeSec,date,hardcore}]

    // â˜…ãƒ‡ãƒãƒƒã‚°ï¼šãƒ•ãƒ«ãƒ‘ãƒ¯ãƒ¼ãƒ¢ãƒ¼ãƒ‰é©ç”¨
    if (typeof applyDebugFullPower === 'function') applyDebugFullPower();

    // â˜…ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹ï¼ˆé€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã®ã¿ã€6ç¨®é¡ã‹ã‚‰é¸æŠï¼‰
    if (!state.mode.hardcore) {
      showStartBonus();
    }

  }

// â˜…ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹é¸æŠï¼ˆæ­¦å™¨6ç¨®é¡ã‹ã‚‰é¸æŠï¼‰
function showStartBonus() {
  state.paused = true;
  
  const modal = document.createElement('div');
  modal.id = 'startBonusModal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: flex; align-items: center;
    justify-content: center; z-index: 10000;
  `;
  
  const container = document.createElement('div');
  container.style.cssText = `
    background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
    border: 3px solid #fbbf24; border-radius: 16px; padding: 20px;
    max-width: 600px; width: 90%; text-align: center;
  `;
  
  const title = document.createElement('h2');
  title.textContent = 'ğŸ ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹';
  title.style.cssText = 'color: #fbbf24; margin: 0 0 8px 0; font-size: 24px;';
  container.appendChild(title);
  
  const subtitle = document.createElement('p');
  subtitle.textContent = 'æ­¦å™¨ã‚’1ã¤é¸ã‚“ã§ã‚¹ã‚¿ãƒ¼ãƒˆï¼';
  subtitle.style.cssText = 'color: #94a3b8; margin: 0 0 16px 0; font-size: 14px;';
  container.appendChild(subtitle);
  
  // æ­¦å™¨è¿½åŠ ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆblasterä»¥å¤–ã®æ–°è¦æ­¦å™¨ï¼‰
  const weaponKeys = ['shotgun', 'orbit', 'lightning', 'nova', 'rock', 'homing', 'ghost', 'poison', 'blade', 'rubber', 'laser'];
  const weaponAdds = ALL_UPGRADES.filter(u => {
    // weaponAddç³»ã®ã¿ï¼ˆid ãŒ "add:" ã§å§‹ã¾ã‚Šã€can() ãŒ trueï¼‰
    return u.id && u.id.startsWith('add:') && weaponKeys.includes(u.id.replace('add:', '')) && u.can();
  });
  
  // ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦6ã¤é¸ã¶
  const shuffled = weaponAdds.sort(() => Math.random() - 0.5);
  const choices = shuffled.slice(0, 6);
  
  const grid = document.createElement('div');
  grid.style.cssText = `
    display: grid; grid-template-columns: repeat(3, 1fr);
    gap: 10px;
  `;
  
  choices.forEach((upg, i) => {
    const btn = document.createElement('button');
    btn.style.cssText = `
      background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
      border: 2px solid #475569; border-radius: 12px; padding: 12px 8px;
      color: #fff; cursor: pointer; transition: all 0.2s;
      display: flex; flex-direction: column; align-items: center; gap: 4px;
    `;
    btn.innerHTML = `
      <span style="font-size: 12px; font-weight: bold; color: #60a5fa;">${upg.name}</span>
      <span style="font-size: 10px; color: #94a3b8; line-height: 1.3;">${typeof upg.desc === 'function' ? upg.desc() : upg.desc}</span>
    `;
    
    btn.onmouseenter = () => {
      btn.style.borderColor = '#fbbf24';
      btn.style.transform = 'scale(1.03)';
    };
    btn.onmouseleave = () => {
      btn.style.borderColor = '#475569';
      btn.style.transform = 'scale(1)';
    };
    
    btn.onclick = () => {
      upg.apply();
      modal.remove();
      state.paused = false;
      // ãƒˆãƒ¼ã‚¹ãƒˆè¡¨ç¤º
      showStartToast(`ğŸ ${upg.name}ï¼`);
    };
    
    grid.appendChild(btn);
  });
  
  container.appendChild(grid);
  
  // ãƒ‘ã‚¹ãƒœã‚¿ãƒ³
  const passBtn = document.createElement('button');
  passBtn.textContent = 'â­ ãƒ‘ã‚¹';
  passBtn.style.cssText = `
    margin-top: 12px; background: #64748b; color: #fff; border: none;
    padding: 10px 20px; border-radius: 8px; font-size: 14px;
    font-weight: bold; cursor: pointer; opacity: 0.8;
  `;
  passBtn.onmouseenter = () => { passBtn.style.opacity = '1'; };
  passBtn.onmouseleave = () => { passBtn.style.opacity = '0.8'; };
  passBtn.onclick = () => {
    modal.remove();
    state.paused = false;
  };
  container.appendChild(passBtn);
  
  modal.appendChild(container);
  document.body.appendChild(modal);
}

function hoistPcTimerToBody(){
  const el = document.getElementById('pcTimer');
  if (el && el.parentNode !== document.body){
    document.body.appendChild(el);
  }
}


function updateHUD(){
  lvEl.textContent = state.player.level;

  hpw.style.width = (100*state.player.hp/state.player.maxHp)+'%';
    // â˜… HPæ•°å€¤ã®æ›´æ–°
  if (hpValEl) {
hpValEl.textContent = `${Math.max(0, Math.floor(state.player.hp))} / ${Math.floor(state.player.maxHp)}`;
  }
  
  xpw.style.width = (100*state.player.xp/state.player.nextXp(state.player.level))+'%';

const m   = Math.floor(state.timeSec/60);
const s   = (state.timeSec%60)|0;
const txt = `${m}:${String(s).padStart(2,'0')}`;
const tf  = document.getElementById('timeFloat'); // å¸¸ã«æµ®éŠã‚¿ã‚¤ãƒãƒ¼ã¸
if (tf) tf.textContent = `âŒ› ${txt}`;

  const names = Object.entries(state.weapons)
    .filter(([k,w])=>w.lv>0)
    .map(([k,w])=> `${w.short}${w.lv}${w.awaken?'â˜…':''}`);
  wepEl.textContent = names.join(', ') || '-';
  
const bodyEl = document.body;
if (state.mode.hardcore) {
  bodyEl.dataset.hc = "1";
} else {
  delete bodyEl.dataset.hc;
}

if (scoreVal) scoreVal.textContent = Math.floor(state.score || 0);

// === Top HUD åŒæœŸ ===
(function(){
  const p = state.player;
  if (!p) return;

  const hpNow = Math.max(0, Math.min(p.hp, p.maxHp || 0));
  const hpPct = (p.maxHp > 0) ? (hpNow / p.maxHp) * 100 : 0;

  // XP / æ¬¡ãƒ¬ãƒ™ãƒ«å¿…è¦é‡
  const xp = Math.max(0, state?.player?.xp || 0);
  let needXP = 0;
  if (typeof p.nextXp === 'function')           needXP = p.nextXp(p.level);
  else if (typeof state?.nextXp === 'function') needXP = state.nextXp(p.level);
  else if (typeof state?.xpToNext === 'function') needXP = state.xpToNext(p.level);
  const xpPct = needXP > 0 ? Math.min(100, (xp / needXP) * 100) : 0;

  // å‚ç…§è¦ç´ 
  const hpTop    = document.getElementById('hpTop');
  const hpTopVal = document.getElementById('hpTopVal');
  const xpTop    = document.getElementById('xpTop');
  const xpTopVal = document.getElementById('xpTopVal');
  const lvTop    = document.getElementById('lvTop');
  const wlTop    = document.getElementById('wlTop');
  const timeTop  = document.getElementById('timeTop');

  // HPï¼šå¹…ï¼†è‰²ï¼ˆ20%ä»¥ä¸‹ã§èµ¤ï¼ãã‚Œä»¥å¤–ã¯ç·‘ï¼‰
  if (hpTop){
    hpTop.style.width = hpPct.toFixed(1) + '%';
    const low = hpPct <= 20;
    hpTop.style.background = low
      ? 'linear-gradient(90deg,#ff6464,#ff3a3a)'
      : 'linear-gradient(90deg,#27e38a,#12c574)';
  }
  if (hpTopVal) hpTopVal.textContent = `${Math.floor(hpNow)} / ${p.maxHp || 0}`;

  // EXï¼šå¹…ï¼†æ•°å€¤
  if (xpTop)    xpTop.style.width = xpPct.toFixed(1) + '%';
  if (xpTopVal) xpTopVal.textContent = needXP > 0 ? `${Math.floor(xp)} / ${needXP}` : `${Math.floor(xp)}`;

  // Lv / æ­¦å™¨Lv
  if (lvTop) lvTop.textContent = p.level || 1;
  const wl =
    (state?.weapons?.main?.level) ??
    (state?.weaponLevel) ??
    (p?.weaponLevel) ?? 1;
  if (wlTop) wlTop.textContent = wl;

  // ã‚¿ã‚¤ãƒãƒ¼ï¼ˆmm:ssï¼‰â€” ä¸€åº¦ã ã‘è¨ˆç®—ã—ã¦ä¸¡æ–¹ã«ä½¿ã†
  const t  = Math.max(0, Math.floor(state?.timeSec || 0));
  const mm = String(Math.floor(t/60));
  const ss = String(t%60).padStart(2,'0');

  if (timeTop) timeTop.textContent = `${mm}:${ss}`;
// å¤§ã‚¿ã‚¤ãƒãƒ¼ã‚‚åŒæœŸï¼ˆè¡¨ç¤ºä½ç½®ã¯ positionPcTimer ã§èª¿æ•´ï¼‰
const pcTimer = document.getElementById('pcTimer');
if (pcTimer){
  pcTimer.textContent = `${mm}:${ss}`;
  pcTimer.style.display = 'block';
  if (typeof positionPcTimer === 'function') positionPcTimer();
}

  
  
})();



  }

  
  
  
// å®‰å…¨ã« #wrap ã‚’å–å¾—ã—ã¦ã‹ã‚‰ãƒªã‚¹ãƒŠãƒ¼ç™»éŒ²
{
  const wrapEl = document.getElementById('wrap');
  if (wrapEl) {
    wrapEl.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  } else {
    console.warn('[init] #wrap element not found (skipped touchmove preventDefault)');
  }
}

window.addEventListener('keydown', e=>{
if(e.key==='p'||e.key==='P'){ 
  const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
  const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
  if (!(lvlOpen || chestOpen)) {
    state.manualPaused = !state.manualPaused;
    syncPauseButton();
  }
}

// Lï¼šãƒ©ã‚¹ãƒœã‚¹ã«ãƒ‡ãƒãƒƒã‚°ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆShift+L ã§å³æ­»ç´šï¼‰
if (e.key === 'l' || e.key === 'L') {
  const finals = (state?.enemies || []).filter(en => en?.type === 'final');
  if (finals.length === 0) {
    console.warn('[debug] final boss not found');
  } else {
    const dmg = e.shiftKey ? 99999 : 5000;
    for (const b of finals) {
      if (!Number.isFinite(b.hp)) continue;
      const before = b.hp;
      b.hp = Math.max(0, b.hp - dmg);
      b.hitFlash = 0.2;

      if (typeof addEffect === 'function') {
        addEffect('text', { text: `-${Math.min(dmg, before).toFixed(0)}`, x: b.x, y: b.y - 22, life: 0.6, color: '#ff7a7a' });
      }
      // â˜…HPãŒ0ã«ãªã£ãŸã‚‰ç¢ºå®Ÿã«æ’ƒç ´å‡¦ç†ã¸
      if (b.hp <= 0 && typeof safeKillEnemy === 'function') {
        safeKillEnemy(b);
      }
    }
  }
}
if (e.key === 'j' || e.key === 'J') state.player.hp = Math.max(0, state.player.hp - 25);
if (e.key === 'k' || e.key === 'K') state.player.hp = Math.min(state.player.maxHp, state.player.hp + 25);


  state.input.keys[e.key]=true;
});
  window.addEventListener('keyup', e=>{ state.input.keys[e.key]=false; });
  function keyboardVec(){
    const k = state.input.keys; let x=0,y=0;
    if(k['ArrowLeft']||k['a']) x-=1; if(k['ArrowRight']||k['d']) x+=1;
    if(k['ArrowUp']||k['w']) y-=1; if(k['ArrowDown']||k['s']) y+=1;
    const m=Math.hypot(x,y)||1; return {x:x/m,y:y/m};
  }

// Spawns
function spawnEnemy(){
  const B = worldBounds();              // â† ã‚ºãƒ¼ãƒ åæ˜ ã®è¡¨ç¤ºå¢ƒç•Œ
  const margin = 30;
  const side = Math.floor(Math.random()*4);
  let x, y;

  // ç”»é¢ã®å››è¾ºã€Œå¤–ã€ã‹ã‚‰æ¹§ã‹ã›ã‚‹ï¼ˆã‚ºãƒ¼ãƒ å¯¾å¿œï¼‰
  if (side === 0) { // ä¸Š
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.minY - margin;
  } else if (side === 1) { // å³
    x = B.maxX + margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  } else if (side === 2) { // ä¸‹
    x = rnd(B.minX - margin, B.maxX + margin);
    y = B.maxY + margin;
  } else { // å·¦
    x = B.minX - margin;
    y = rnd(B.minY - margin, B.maxY + margin);
  }

  const shooterProb = state.timeSec > 150 ? 0.04 : 0.0;
  // ãƒ¯ãƒ¼ãƒ‘ãƒ¼ã¨ãƒœãƒ ã¯ã‚¹ãƒ†ãƒ¼ã‚¸2ã§ã¯å‡ºç¾ã—ãªã„ï¼ˆä¸¸ã„æ•µãªã®ã§ï¼‰
  const warperProb = (state.currentStage !== 'stage2' && state.timeSec > 240) ? 0.025 : 0.0;
  const laserProb = state.timeSec > 180 ? 0.015 : 0.0;   // 3åˆ†ä»¥é™
  const bomProb = (state.currentStage !== 'stage2' && state.timeSec > 120) ? 0.03 : 0.0;
  
  // ã‚¹ãƒ†ãƒ¼ã‚¸2å°‚ç”¨æ•µ
  const spinnerProb = (state.currentStage === 'stage2' && state.timeSec > 60) ? 0.08 : 0.0;
  const dasherProb = (state.currentStage === 'stage2' && state.timeSec > 90) ? 0.06 : 0.0;
  const sniperProb = (state.currentStage === 'stage2' && state.timeSec > 120) ? 0.05 : 0.0;
  const orbiterProb = (state.currentStage === 'stage2' && state.timeSec > 90) ? 0.04 : 0.0;
  const pillarTrapProb = (state.currentStage === 'stage2' && state.timeSec > 180) ? 0.02 : 0.0;
  
  const roll = Math.random();

  if (roll < spinnerProb) {
    // ã‚¹ãƒ”ãƒŠãƒ¼ï¼ˆå›è»¢ä¸‰è§’ï¼‰
    let hp = 40 + state.difficulty * 2;
    if (state.mode.hardcore) hp *= 2.0;
    
    state.enemies.push({
      x, y, size: 26, hp, maxHp: hp, speed: 60, type: 'spinner', // â˜…20â†’26ã«æ‹¡å¤§
      rotation: Math.random() * Math.PI * 2,  // åˆæœŸå›è»¢è§’
      rotationSpeed: 3.0,  // é€šå¸¸å›è»¢é€Ÿåº¦ï¼ˆrad/sï¼‰
      highSpinSpeed: 20.0, // é«˜é€Ÿå›è»¢é€Ÿåº¦ï¼ˆrad/sï¼‰
      spinPhase: 'normal',  // normal or highspin
      spinTimer: 0,         // ãƒ•ã‚§ãƒ¼ã‚ºã‚¿ã‚¤ãƒãƒ¼
      normalDuration: 2.0,  // é€šå¸¸å›è»¢æ™‚é–“ï¼ˆ2ç§’ï¼‰
      highSpinDuration: 2.0, // é«˜é€Ÿå›è»¢æ™‚é–“ï¼ˆ2ç§’ï¼‰
      shootCd: 3.0,         // â˜…å¼¾ç™ºå°„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
      shootInterval: 4.0,   // â˜…å¼¾ç™ºå°„é–“éš”ï¼ˆ4ç§’ï¼‰
      hitFlash: 0, kbx: 0, kby: 0
    });
  } else if (roll < spinnerProb + dasherProb) {
    // ãƒ€ãƒƒã‚·ãƒ£ãƒ¼ï¼ˆçªé€²ä¸‰è§’ï¼‰- â˜…ç”»é¢å¤–ã‹ã‚‰ç™»å ´
    let hp = 35 + state.difficulty * 2; // â˜…50â†’35ã«ä½ä¸‹
    if (state.mode.hardcore) hp *= 2.0;
    
    // â˜…ç”»é¢å¤–ã®ã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã‚’è¨ˆç®—
    const B = worldBounds();
    const margin = 60;
    const side = Math.floor(Math.random() * 4);
    let spawnX, spawnY;
    
    if (side === 0) { // ä¸Š
      spawnX = rnd(B.minX, B.maxX);
      spawnY = B.minY - margin;
    } else if (side === 1) { // å³
      spawnX = B.maxX + margin;
      spawnY = rnd(B.minY, B.maxY);
    } else if (side === 2) { // ä¸‹
      spawnX = rnd(B.minX, B.maxX);
      spawnY = B.maxY + margin;
    } else { // å·¦
      spawnX = B.minX - margin;
      spawnY = rnd(B.minY, B.maxY);
    }
    
    state.enemies.push({
      x: spawnX, y: spawnY, 
      size: 22,        // åŸºæœ¬ã‚µã‚¤ã‚ºï¼ˆå½“ãŸã‚Šåˆ¤å®šç”¨ï¼‰
      width: 12,       // æ¨ªå¹…ï¼ˆç´°ã„ï¼‰
      height: 40,      // ç¸¦å¹…ï¼ˆé•·ã„ï¼‰é ‚è§’20åº¦ã®äºŒç­‰è¾ºä¸‰è§’å½¢
      hp, maxHp: hp, type: 'dasher',
      phase: 'aim',           // aim â†’ dash â†’ stop
      phaseTimer: 0.8,        // aimæ™‚é–“
      dashDir: { x: 0, y: 0 }, // ãƒ€ãƒƒã‚·ãƒ¥æ–¹å‘
      targetX: 0,             // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™
      targetY: 0,
      dashSpeed: 640,         // ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦ï¼ˆ800ã®80%ã«èª¿æ•´ï¼‰
      rotation: 0,            // å‘ãï¼ˆå…ˆç«¯ã®å‘ãï¼‰
      hitFlash: 0, kbx: 0, kby: 0
    });
  } else if (roll < spinnerProb + dasherProb + sniperProb) {
    // ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ï¼ˆç‹™æ’ƒä¸‰è§’ï¼‰
    // â˜…é€šå¸¸ã¯æœ€å¤§3ä½“ã¾ã§ï¼ˆ8åˆ†ä»¥é™ã¯5ä½“ï¼‰ã€ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã¯5ä½“ï¼ˆ8åˆ†ä»¥é™ã¯7ä½“ï¼‰
    const baseLimit = state.timeSec >= 480 ? 5 : 3;
    const sniperLimit = state.mode.hardcore ? baseLimit + 2 : baseLimit;
    const existingSnipers = state.enemies.filter(en => en.type === 'sniper').length;
    if (existingSnipers >= sniperLimit) return;
    
    let hp = 35 + state.difficulty * 2;
    if (state.mode.hardcore) hp *= 2.0;
    
    // ç”»é¢å†…ã®åœæ­¢ä½ç½®ã‚’è¨ˆç®—ï¼ˆç«¯ã‹ã‚‰100pxå†…å´ï¼‰
    const B = worldBounds();
    let stopX, stopY;
    const margin = 100;
    
    // å‡ºç¾ä½ç½®ã‹ã‚‰ç”»é¢å†…ã«ç§»å‹•ã™ã‚‹æ–¹å‘ã‚’è¨ˆç®—
    if (x < B.minX) {
      stopX = B.minX + margin;
    } else if (x > B.maxX) {
      stopX = B.maxX - margin;
    } else {
      stopX = x;
    }
    
    if (y < B.minY) {
      stopY = B.minY + margin;
    } else if (y > B.maxY) {
      stopY = B.maxY - margin;
    } else {
      stopY = y;
    }
    
    state.enemies.push({
      x, y, 
      size: 18,
      hp, maxHp: hp, type: 'sniper',
      phase: 'move',          // move â†’ aim â†’ lock â†’ fire â†’ cooldown
      phaseTimer: 0,
      moveSpeed: 120,         // ç§»å‹•é€Ÿåº¦
      stopX, stopY,           // åœæ­¢ä½ç½®
      aimTime: 1.2,           // äºˆå‚™ç·šè¡¨ç¤ºæ™‚é–“ï¼ˆè¿½å°¾ï¼‰
      lockTime: 1.0,          // ç…§æº–å›ºå®šæ™‚é–“ï¼ˆå›é¿ãƒãƒ£ãƒ³ã‚¹ï¼‰â€»0.5â†’1.0ã«å»¶é•·
      cooldownTime: 2.0,      // æ¬¡å¼¾ã¾ã§
      laserDamage: 25,        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸
      laserWidth: 4,          // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¹…
      targetAngle: 0,         // ç‹™ã„è§’åº¦
      lockedAngle: 0,         // å›ºå®šã•ã‚ŒãŸè§’åº¦
      hitFlash: 0, kbx: 0, kby: 0
    });
  } else if (roll < spinnerProb + dasherProb + sniperProb + orbiterProb) {
    // ã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ï¼ˆæŸ±ã®å‘¨ã‚Šã‚’å›è»¢ã™ã‚‹æ•µï¼‰
    if (state.obstacles.length > 0) {
      // ãƒ©ãƒ³ãƒ€ãƒ ãªæŸ±ã‚’é¸ã¶
      const obs = state.obstacles[Math.floor(Math.random() * state.obstacles.length)];
      
      let hp = 90 + state.difficulty * 4; // â˜…60â†’90ã«å¢—åŠ 
      if (state.mode.hardcore) hp *= 2.0;
      
      const orbitRadius = 80 + Math.random() * 40;  // æŸ±ã‹ã‚‰ã®è·é›¢
      const startAngle = Math.random() * Math.PI * 2;
      
      state.enemies.push({
        x: obs.x + Math.cos(startAngle) * orbitRadius,
        y: obs.y + Math.sin(startAngle) * orbitRadius,
        size: 28, // â˜…18â†’28ã«å¢—åŠ 
        hp, maxHp: hp, type: 'orbiter',
        centerX: obs.x,           // å‘¨å›ä¸­å¿ƒï¼ˆæŸ±ã®ä½ç½®ï¼‰
        centerY: obs.y,
        orbitRadius: orbitRadius,
        orbitAngle: startAngle,   // ç¾åœ¨ã®è§’åº¦
        orbitSpeed: 1.5,          // å›è»¢é€Ÿåº¦ï¼ˆrad/sï¼‰
        shootTimer: 0,            // å°„æ’ƒã‚¿ã‚¤ãƒãƒ¼
        shootInterval: 1.2,       // å°„æ’ƒé–“éš”
        hitFlash: 0, kbx: 0, kby: 0
      });
    }
  } else if (roll < spinnerProb + dasherProb + sniperProb + orbiterProb + pillarTrapProb) {
    // ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ï¼ˆæŸ±ã®ä¸Šã«å‡ºç¾ã€å›è»¢ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼‰
    // â˜…åŒæ™‚ã«1ä½“ã®ã¿å­˜åœ¨å¯èƒ½ + äºˆå‘Šä¸­ã‚‚è€ƒæ…®
    const existingPillarTraps = state.enemies.filter(en => en.type === 'pillarTrap' && !en.fromBoss).length;
    const isPillarTrapPending = state._pillarTrapPending || false; // â˜…äºˆå‘Šä¸­ãƒ•ãƒ©ã‚°
    if (state.obstacles.length > 0 && existingPillarTraps === 0 && !isPillarTrapPending) {
      // ãƒ©ãƒ³ãƒ€ãƒ ãªæŸ±ã‚’é¸ã¶
      const obs = state.obstacles[Math.floor(Math.random() * state.obstacles.length)];
      
      // â˜…äºˆå‘Šä¸­ãƒ•ãƒ©ã‚°ã‚’ã‚»ãƒƒãƒˆ
      state._pillarTrapPending = true;
      
      // â˜…å‡ºç¾äºˆå‘Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆ1.2ç§’é–“è¡¨ç¤ºï¼‰
      addEffect('warning', { x: obs.x, y: obs.y, r: 100, life: 1.2, color: 'rgba(255,50,50,0.7)' });
      addEffect('text', { x: obs.x, y: obs.y - 50, life: 1.2, text: 'âš ï¸ TRAP', size: 20, color: '#ff6666' });
      
      // 1.2ç§’å¾Œã«å®Ÿéš›ã«å‡ºç¾
      const spawnX = obs.x, spawnY = obs.y;
      setTimeout(() => {
        state._pillarTrapPending = false; // â˜…äºˆå‘Šçµ‚äº†
        if (!state.paused && state.started) {
          // å†åº¦ãƒã‚§ãƒƒã‚¯ï¼ˆé…å»¶ä¸­ã«åˆ¥ã®ãŒå‡ºãŸå ´åˆã‚’é˜²ãï¼‰
          const currentTraps = state.enemies.filter(en => en.type === 'pillarTrap' && !en.fromBoss).length;
          if (currentTraps > 0) return;
          
          state.enemies.push({
            x: spawnX, y: spawnY,
            size: 25,
            hp: 999999,           // å€’ã›ãªã„
            maxHp: 999999,
            type: 'pillarTrap',
            invincible: true,     // ç„¡æ•µãƒ•ãƒ©ã‚°
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: 1.5,   // å›è»¢é€Ÿåº¦
            laserLength: 250,     // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®é•·ã•
            laserDamage: 40,      // ãƒ€ãƒ¡ãƒ¼ã‚¸/ç§’ï¼ˆ20â†’40ã«å¢—åŠ ï¼‰
            lifeTime: 6.0,        // å­˜åœ¨æ™‚é–“
            timer: 6.0,
            hitFlash: 0, kbx: 0, kby: 0
          });
          // å‡ºç¾æ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          addEffect('nova', { x: spawnX, y: spawnY, r: 60, life: 0.3 });
        }
      }, 1200);
    }
  } else if (roll < spinnerProb + dasherProb + sniperProb + orbiterProb + pillarTrapProb + bomProb) {
    // BOMæ•µï¼ˆè‡ªçˆ†å‹ï¼‰- å‡ºç¾äºˆå‘Šä»˜ã
    let hp = (40 + state.difficulty*3) * 4.8; // 1.2 â†’ 4.8ï¼ˆ4å€ï¼‰
    if (state.mode.hardcore) hp *= 2.0; // 1.5 â†’ 2.0

    // ç”»é¢å†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ãµã‚‰ãµã‚‰å‡ºç¾
    const B = worldBounds();
    const spawnX = rnd(B.minX + 100, B.maxX - 100);
    const spawnY = rnd(B.minY + 100, B.maxY - 100);

    // å‡ºç¾äºˆå‘Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆ0.8ç§’é–“è¡¨ç¤ºï¼‰
    addEffect('warning', { x: spawnX, y: spawnY, r: 60, life: 0.8, color: 'rgba(255,100,100,0.6)' });
    addEffect('text', { x: spawnX, y: spawnY - 40, life: 0.8, text: 'âš ï¸', size: 28 });

    // 0.8ç§’å¾Œã«å®Ÿéš›ã«å‡ºç¾
    setTimeout(() => {
      if (!state.paused && state.started) {
        state.enemies.push({
          x: spawnX, y: spawnY, size:28, sizeW:40, hp, maxHp:hp, type:'bom',
          phase:'float',
          phaseTimer:rnd(2.5, 3.5),
          targetX: rnd(B.minX + 100, B.maxX - 100),
          targetY: rnd(B.minY + 100, B.maxY - 100),
          floatSpeed: 50,
          warningTime: 2.5,
          explodeRadius: 180,
          explodeDamage: 60,
          warningRadius: 0,
          hitFlash:0, kbx:0, kby:0
        });
        // å‡ºç¾æ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        addEffect('nova', { x: spawnX, y: spawnY, r: 50, life: 0.3 });
      }
    }, 800);
  } else if (roll < bomProb + warperProb) {
    // ãƒ¯ãƒ¼ãƒ—ã™ã‚‹æ•µï¼ˆç´«ã®ç¸¦é•·å››è§’ï¼‰- å‡ºç¾äºˆå‘Šä»˜ã
    let hp = (28 + state.difficulty*3) * 3.9; // 1.3 â†’ 3.9 (3å€ç¡¬ã)
    if (state.mode.hardcore) hp *= 2.0; // 1.5 â†’ 2.0

    // ç”»é¢å†…ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«å‡ºç¾
    const B = worldBounds();
    const spawnX = rnd(B.minX + 80, B.maxX - 80);
    const spawnY = rnd(B.minY + 80, B.maxY - 80);

    // å‡ºç¾äºˆå‘Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆ0.6ç§’é–“è¡¨ç¤ºï¼‰
    addEffect('warning', { x: spawnX, y: spawnY, r: 50, life: 0.6, color: 'rgba(150,100,255,0.6)' });
    addEffect('text', { x: spawnX, y: spawnY - 35, life: 0.6, text: 'âš¡', size: 26 });

    // 0.6ç§’å¾Œã«å®Ÿéš›ã«å‡ºç¾
    setTimeout(() => {
      if (!state.paused && state.started) {
        state.enemies.push({
          x: spawnX, y: spawnY, size:22, sizeH:40, hp, maxHp:hp, type:'warper',
          phase:'visible', phaseTimer:rnd(4.0, 5.0),
          fadeTimer:0, cd:rnd(0.3, 0.7), hitFlash:0, kbx:0, kby:0,
          spawnFlash: 0.5
        });
        
        // å‡ºç¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå¼·åŒ–
        addEffect('flash', { life: 0.1 });
        addEffect('nova', { x: spawnX, y: spawnY, r: 80, life: 0.3 });
        // è¿½åŠ ã®ç™½ãƒªãƒ³ã‚°
        for(let i=0; i<3; i++){
          setTimeout(() => {
            if (state.started) {
              addEffect('nova', { x: spawnX, y: spawnY, r: 50 + i*15, life: 0.15 });
            }
          }, i * 50);
        }
      }
    }, 600);
  } else if (roll < bomProb + warperProb + laserProb) {
    // ãƒ¬ãƒ¼ã‚¶ãƒ¼æ•µï¼ˆé»„è‰²ã„æ¨ªé•·å››è§’ï¼‰
    let hp = (24 + state.difficulty*2.8) * 2.5; // 1.8 â†’ 2.5 (ã•ã‚‰ã«ç¡¬ã)
    if (state.mode.hardcore) hp *= 2.0; // 1.5 â†’ 2.0

    // æ™‚é–“çµŒéã§å‡ºç¾æ•°ãŒå¢—ãˆã‚‹
    let spawnCount = 1; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1ä½“
    if (state.timeSec >= 420) spawnCount = 3; // 7åˆ†ä»¥é™ã¯3ä½“
    else if (state.timeSec >= 300) spawnCount = 2; // 5åˆ†ä»¥é™ã¯2ä½“

    // å·¦å³ã©ã¡ã‚‰ã‹ã®ç«¯ã«é…ç½®ï¼ˆç”»é¢å†…å´ã«å°‘ã—å…¥ã‚Œã‚‹ï¼‰
    const B = worldBounds();
    
    for (let i = 0; i < spawnCount; i++) {
      const isLeft = Math.random() < 0.5;
      const offset = 60; // ç”»é¢å†…å´ã«60pxãšã‚‰ã™
      const spawnX = isLeft ? B.minX + offset : B.maxX - offset;
      const spawnY = rnd(B.minY + 50, B.maxY - 50);

      state.enemies.push({
        x: spawnX, y: spawnY, size:12, sizeW:32, hp, maxHp:hp, type:'laser',
        phase:'move', side: isLeft ? 'left' : 'right',
        yTarget: rnd(B.minY + 50, B.maxY - 50), moveSpeed:80,
        cd:rnd(1.5, 2.0), hitFlash:0, kbx:0, kby:0
      });
    }
  } else if (roll < bomProb + warperProb + laserProb + shooterProb) {
    // å°„æ’ƒã‚¿ã‚¤ãƒ—
    let hp = (20 + state.difficulty*2.5) * 1.5;
    if (state.mode.hardcore) hp *= 2.0; // 1.5 â†’ 2.0

    // ã­ã‚‰ã„ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆâ€»ç”»é¢ä¸­å¿ƒã«ã—ãŸã„ãªã‚‰ (B.minX+B.maxX)/2 ãªã©ã§ã‚‚å¯ï¼‰
    const tx = state.player.x, ty = state.player.y;
    const dx = tx - x, dy = ty - y; const m = Math.hypot(dx, dy) || 1;
    const dir = { x: dx/m, y: dy/m };

    state.enemies.push({
      x, y, size:20, hp, maxHp:hp, type:'shooter',
      phase:'move', dir, moved:0, moveDist:rnd(240,360),
      moveSpeed:120, cd:rnd(0.2,0.8), hitFlash:0, kbx:0, kby:0
    });
  } else {
    // è¿‘æ¥ã‚¿ã‚¤ãƒ—
    let hp = 16 + state.difficulty*2.2;
    if (state.mode.hardcore) hp *= 2.0; // 1.5 â†’ 2.0
    if (state.timeSec >= 360) hp *= 2.0;

    const dForSpeed = Math.min(state.difficulty, 16);
    const sp = 30 + dForSpeed*4.5;

    state.enemies.push({
      x, y, size:24, hp, maxHp:hp, speed:sp, type:'minion', // â˜…18â†’24ã«æ‹¡å¤§
      hitFlash:0, kbx:0, kby:0,
      // è¿‘æ¥çˆ†ç™ºç”¨
      blinkTimer: 0,      // ç‚¹æ»…ã‚¿ã‚¤ãƒãƒ¼
      explodeRadius: 50,  // çˆ†ç™ºç¯„å›²
      explodeDamage: 15,  // çˆ†ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸
      nearThreshold: 80   // ã“ã®è·é›¢ä»¥å†…ã§ç‚¹æ»…é–‹å§‹
    });
  }
}

function spawnMidBoss(){
  const B = worldBounds();
  const margin = 80;
  const side = Math.floor(Math.random()*4);
  let x,y;

  if (side===0){ x = rnd(B.minX - margin, B.maxX + margin); y = B.minY - margin; }
  else if (side===1){ x = B.maxX + margin; y = rnd(B.minY - margin, B.maxY + margin); }
  else if (side===2){ x = rnd(B.minX - margin, B.maxX + margin); y = B.maxY + margin; }
  else { x = B.minX - margin; y = rnd(B.minY - margin, B.maxY + margin); }

  let hp = 420 + state.difficulty*120;
  if (state.timeSec>=360) hp *= 1.6;
  if (state.mode.hardcore) hp *= 1.5; // â˜…ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã¯HP1.5å€

  const e = {
    x,y, size: state.currentStage === 'stage2' ? 55 : 48,
    hp, maxHp:hp, speed: state.currentStage === 'stage2' ? 50 : 80, type:'mid',
    cd:0, hitFlash:0, kbx:0, kby:0,
    // ã‚¹ãƒ†ãƒ¼ã‚¸2ç”¨
    isTriangle: state.currentStage === 'stage2',
    rotation: 0,
    burstCd: 0, burstInterval: 2.5, burstCount: 0, burstMax: 5,
    beamCd: 3, beamInterval: 6.0, beamCharging: false, beamChargeTime: 0, beamAngle: 0 // â˜…5â†’3ç§’ã€10â†’6ç§’é–“éš”ã«çŸ­ç¸®
  };

  state.enemies.push(e);
  flashBossMsg();
  playBossWarningSound(false);
}

function spawnBigBoss(){
  const B = worldBounds();
  const margin = 100;
  const side = Math.floor(Math.random()*4);
  let x,y;

  if (side===0){ x = rnd(B.minX - margin, B.maxX + margin); y = B.minY - margin; }
  else if (side===1){ x = B.maxX + margin; y = rnd(B.minY - margin, B.maxY + margin); }
  else if (side===2){ x = rnd(B.minX - margin, B.maxX + margin); y = B.maxY + margin; }
  else { x = B.minX - margin; y = rnd(B.minY - margin, B.maxY + margin); }

  let hp = 1000 + state.difficulty*240;
  if (state.timeSec>=360) hp *= 1.6;
  if (state.mode.hardcore) hp *= 1.5; // â˜…ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã¯HP1.5å€ï¼ˆ1.3â†’1.5ï¼‰

  const e = {
    x,y, size: state.currentStage === 'stage2' ? 80 : 70,
    hp, maxHp:hp, speed: state.currentStage === 'stage2' ? 60 : 95, type:'big',
    cd:0, phase:'shoot', tele:0, dashCD:6, dashDir:{x:0,y:0},
    hitFlash:0, kbx:0, kby:0,
    // ã‚¹ãƒ†ãƒ¼ã‚¸2ç”¨
    isTriangle: state.currentStage === 'stage2',
    rotation: 0,
    laserCd: 2, laserInterval: 4.0,
    dashPhase: 'idle', dashCd: 2.0, dashInterval: 8.0, dashWarnTime: 0, dashTargetX: 0, dashTargetY: 0, dashAngle: 0 // â˜…dashCdè¿½åŠ ï¼ˆ2ç§’ã§æœ€åˆã®çªé€²ï¼‰
  };

  state.enemies.push(e);
  flashBossMsg();
  playBossWarningSound(false);
}

// æ—§ï¼š#bossmsg DOM ã‚’ç›´æ¥ã„ã˜ã‚‹å®Ÿè£… â†’ å‰Šé™¤å¾Œã«ã‚¨ãƒ©ãƒ¼åŒ–
// æ–°ï¼šãƒœã‚¹å‘ŠçŸ¥ã¯åˆ¥UIã§å‡ºã™ãŸã‚ã€ã“ã“ã¯ç„¡å®³åŒ–ã—ã¦ãŠã
function flashBossMsg(ms = 2000, text = '!! BOSS APPROACHING !!') {
  // no-opï¼ˆä½•ã‚‚ã—ãªã„ï¼‰
}
  // â˜…ã‚¢ã‚¤ãƒ†ãƒ /ã‚¸ã‚§ãƒ ã®ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’æŸ±ã‹ã‚‰é›¢ã™
  function adjustDropPosition(x, y, radius = 20) {
    const margin = radius + 10;
    for (const obs of state.obstacles) {
      const halfSize = obs.size / 2 + margin;
      // æŸ±ã¨é‡ãªã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (x > obs.x - halfSize && x < obs.x + halfSize &&
          y > obs.y - halfSize && y < obs.y + halfSize) {
        // æŸ±ã®ä¸­å¿ƒã‹ã‚‰æœ€ã‚‚è¿‘ã„å¤–å´ã«æŠ¼ã—å‡ºã™
        const dx = x - obs.x;
        const dy = y - obs.y;
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);
        
        if (absDx > absDy) {
          // å·¦å³ã«æŠ¼ã—å‡ºã™
          x = obs.x + (dx > 0 ? halfSize : -halfSize);
        } else {
          // ä¸Šä¸‹ã«æŠ¼ã—å‡ºã™
          y = obs.y + (dy > 0 ? halfSize : -halfSize);
        }
      }
    }
    return { x, y };
  }
  
  // XP & particles
  function dropGem(x,y,val=1){ 
    const pos = adjustDropPosition(x, y, 5 + val);
    state.gems.push({x: pos.x, y: pos.y, r:5+val, val}); 
  }
  function spark(x,y,cnt=8){
    for(let i=0;i<cnt;i++){
      const a=rnd(0,Math.PI*2), v=rnd(40,160);
      state.sparks.push({x,y, vx:Math.cos(a)*v, vy:Math.sin(a)*v, t:0, life:.4});
    }
  }
  
  function playerHit(dmg, sx, sy, enemy){
  // ãƒ‡ãƒãƒƒã‚°ç„¡æ•µãƒ¢ãƒ¼ãƒ‰
  if (state._debugInvincible) return;
  
  // ã™ã§ã«ç„¡æ•µãªã‚‰ç„¡è¦–
  if (state.player.iTime > 0) return;

  // ãƒ€ãƒƒã‚·ãƒ£ãƒ¼ã®ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã¯1.5å€ãƒ€ãƒ¡ãƒ¼ã‚¸
  let multiplier = 1.0;
  if(enemy && enemy.type === 'dasher' && enemy.phase === 'dash'){
    multiplier = 1.5;
  }

  // è€ä¹…åŠ›ã«ã‚ˆã‚‹è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›
  const finalDmg = Math.round(dmg * multiplier * state.mods.damageMul);
  state.player.hp -= finalDmg;
  state.player.iTime = 1.0; // ç„¡æ•µ1.0ç§’

  // ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼šè¢«å¼¾å…ƒâ†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€†æ–¹å‘ã¸
  const dx = state.player.x - sx;
  const dy = state.player.y - sy;
  const m = Math.hypot(dx, dy) || 1;
  const kb = 360; // åˆé€Ÿ(px/s) å°ã•ã‚ãƒãƒƒã‚¯ãƒãƒƒã‚¯
  state.player.kbx = (dx / m) * kb;
  state.player.kby = (dy / m) * kb;

  // ã¡ã‚‡ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
  addEffect('flash', { life: .03 });

  if (state.player.hp <= 0) {
    gameOver();
  }
}

  
function addEffect(type, data){
  state.effects.push({ type, ...data });
}
// Items
function spawnItemRandom(){
  let chance = 0.03;
  if (state.mods.doubleItem) chance *= 2;   // â† ã“ã“ã¯ãã®ã¾ã¾

  if (Math.random() < chance) {
    const B = worldBounds();        // â† ã‚ºãƒ¼ãƒ å¯¾å¿œã®è¡¨ç¤ºå¢ƒç•Œ
    const pad = 30;                 // ç”»é¢ç«¯ã‹ã‚‰å°‘ã—å†…å´ã«å‡ºã™
    const x = rnd(B.minX + pad, B.maxX - pad);
    const y = rnd(B.minY + pad, B.maxY - pad);

    const roll = Math.random();
    const kind = roll < 0.45 ? 'magnet' : roll < 0.75 ? 'nuke' : 'heal';
    const rByKind =
  kind==='magnet' ? 10 :
  kind==='nuke'   ? 10 :
  kind==='heal'   ? 14 :   // â˜… ã“ã“ã‚’ 18ï¼ˆ= 12 * 1.5ï¼‰
  kind==='chest'  ? 14 : 12;
state.items.push({ kind, x, y, r:rByKind, t:0 });
  }
}

  function applyItem(it){
if(it.kind==='magnet'){
  // ã‚¢ã‚¤ãƒ†ãƒ ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå®ç®±é™¤ãï¼‰
  sessionTracking.itemsCollected++;
  
  // ãƒãƒ¼ã‚ºç„¡ã—ãƒ»å…¨XPé«˜é€Ÿå¸å¼•ï¼ˆå¿…é”ï¼‰
  state.magnet.active = true;
  state.magnet.time   = 0;
  state.magnet.dur    = 1.0;   // åŠ¹æœæ™‚é–“ï¼ˆç§’ï¼‰
  state.magnet.speed  = 1800;  // åŸºæº–é€Ÿåº¦ï¼ˆé€šå¸¸220ã®ç´„5å€ï¼‰

  // è¦‹ãŸç›®ï¼ˆä»»æ„ï¼‰ï¼šã‚ªãƒ¼ãƒ©ã®å¯¿å‘½ã‚’åŠ¹æœæ™‚é–“ã«åˆã‚ã›ã‚‹
  addEffect('aura', { x: state.player.x, y: state.player.y, r: 60, life: state.magnet.dur, life0: state.magnet.dur });
}else if(it.kind==='nuke'){
  // ã‚¢ã‚¤ãƒ†ãƒ ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå®ç®±é™¤ãï¼‰
  sessionTracking.itemsCollected++;
  
  // æ¼”å‡ºï¼šç™½ã„å…‰ã®å††ãŒç´ æ—©ãåºƒãŒã‚‹
  const R = Math.hypot(cv.width / DPR, cv.height / DPR) * 0.85;
  addEffect('whiteCharge', { x: state.player.x, y: state.player.y, r0: 22, r1: 120, life: 0.08 });
  addEffect('megaNova',    { x: state.player.x, y: state.player.y, r: R, life: 0.35 });
  addEffect('flash',       { life: 0.03 });
  const NUKE_KILL_SCORE = 5;   // 1ä½“ã‚ãŸã‚Šã®å°‘é¡ã‚¹ã‚³ã‚¢
  const NUKE_SCORE_CAP  = 50;  // ä¸€æƒ1å›ã‚ãŸã‚Šã®ä¸Šé™

  let killed = 0, gained = 0;
  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const e = state.enemies[i];
    // â˜…ãƒœã‚¹(mid, big, final)ã¨ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ä»¥å¤–ã®å…¨æ•µã‚’å€’ã™
    const isBoss = (e.type === 'mid' || e.type === 'big' || e.type === 'final');
    const isPillarTrap = (e.type === 'pillarTrap');
    
    if (!isBoss && !isPillarTrap) {
      // å°‘é¡ã‚¹ã‚³ã‚¢ï¼ˆä¸Šé™ã‚ã‚Šï¼‰
      if (gained < NUKE_SCORE_CAP) {
        gained += NUKE_KILL_SCORE;
        if (gained > NUKE_SCORE_CAP) gained = NUKE_SCORE_CAP;
      }
      // XPæ§ãˆã‚ï¼ˆminiTriangleã¯çµŒé¨“å€¤ãªã—ï¼‰
      if (e.type !== 'miniTriangle') {
        dropGem(e.x, e.y, 1);
      }
      spark(e.x, e.y, 16);
      state.enemies.splice(i, 1);
      killed++;
    }
  }
  if (gained > 0) {
    state.score += gained;
    state.killScore = (state.killScore || 0) + gained;
    if (scoreVal) scoreVal.textContent = Math.floor(state.score);
  }
  addEffect('text', { x: state.player.x, y: state.player.y, life: 1.2, text: `ä¸€æƒ(${killed})` });
}else if(it.kind==='heal'){
  // ã‚¢ã‚¤ãƒ†ãƒ ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå®ç®±é™¤ãï¼‰
  sessionTracking.itemsCollected++;
  
  const amount = Math.round(state.player.maxHp * 0.35);
  state.player.hp = Math.min(state.player.maxHp, state.player.hp + amount);
  addEffect('text',{x:state.player.x,y:state.player.y,life:1.2,text:`å›å¾© +${amount}`});
  addEffect('healSparkles', { x: state.player.x, y: state.player.y, r: 46, life: 0.7, life0: 0.7, count: 14 });
}else if(it.kind==='chest'){
  // å®ç®±ã¯ã‚«ã‚¦ãƒ³ãƒˆã—ãªã„
  openChest(it.picks||2);
}
  }
function openChest(pickCount = 2) {
  state.paused = true;

  // å®ç®±é–‹å°ã‚«ã‚¦ãƒ³ãƒˆ
  sessionTracking.chestsOpened++;
  achievementProgress.totalChestsOpened++;
  
  // å®ç®±å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
  if (sessionTracking.chestsOpened >= 10) unlockAchievement('chest_10');

  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
  chestEl.style.display = 'flex';
  chestHUD.style.display = 'flex';

  // è¦‹å‡ºã—ã€Œ1ã¤é¸æŠï¼2ã¤é¸æŠã€ã‚’å‹•çš„ã«ç”¨æ„
  let pickModeEl = document.getElementById('pickMode');
  if (!pickModeEl) {
    pickModeEl = document.createElement('div');
    pickModeEl.id = 'pickMode';
    pickModeEl.className = 'pickMode';
    // HUDã®å…ˆé ­ã«é…ç½®ï¼ˆæ®‹ã‚Šãƒãƒƒã‚¸ã®å·¦å´ï¼‰
    chestHUD.prepend(pickModeEl);
  }

  // æšæ•°è¡¨ç¤ºï¼ˆæ—¢å­˜è¦ç´ ãŒã‚ã‚Œã°æ›´æ–°ï¼‰
  let picksLeft = pickCount;
  const updatePickHUD = () => {
    // ä¾‹ï¼šã€Œ2ã¤é¸æŠï¼ˆæ®‹ã‚Š1/2ï¼‰ã€ã¾ãŸã¯ã€Œ1ã¤é¸æŠã€
    const modeText = (pickCount === 1) ? '1ã¤é¸æŠ' : `${pickCount}ã¤é¸æŠ`;
    pickModeEl.textContent = (pickCount > 1) ? `${modeText}ï¼ˆæ®‹ã‚Š${picksLeft}/${pickCount}ï¼‰` : modeText;
    if (typeof pickLeftEl !== 'undefined' && pickLeftEl) {
      pickLeftEl.textContent = picksLeft;
    }
  };

  // ã‚«ãƒ¼ãƒ‰è¡Œã®åˆæœŸåŒ–
  chestRow.innerHTML = '';

  // å€™è£œã‚’æŠ½é¸ï¼ˆcan() ã‚’æº€ãŸã™ã‚‚ã®ã‹ã‚‰æœ€å¤§6ã¤ï¼‰â˜…5â†’6ã«å¤‰æ›´
  const pool = ALL_UPGRADES.filter(u => u.can());
  const choices = [];
  while (choices.length < 6 && pool.length) { // â˜…5â†’6ã«å¤‰æ›´
    const i = (Math.random() * pool.length) | 0;
    choices.push(pool.splice(i, 1)[0]);
  }

  // æ—¢å®šã®â€œé¸æŠæ¸ˆã¿â€çŠ¶æ…‹ã¯ç„¡ã—ï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦åˆã‚ã¦é¸æŠï¼‰
  const chosen = new Set();

  // ã‚«ãƒ¼ãƒ‰ç”Ÿæˆ
  for (const u of choices) {
    const c = document.createElement('button');
    c.className = 'card';
    // descãŒé–¢æ•°ã®å ´åˆã¯å®Ÿè¡Œã€ãã†ã§ãªã‘ã‚Œã°ãã®ã¾ã¾ä½¿ç”¨
    const descText = typeof u.desc === 'function' ? u.desc() : (u.desc || '');
    c.innerHTML = `<h3>${u.name}</h3><p>${descText}</p>`;

    c.onclick = () => {
      if (picksLeft <= 0 || chosen.has(u)) return;
      try {
        // å…ˆã«é©ç”¨ï¼ˆå¤±æ•—ã—ãŸã‚‰ç¢ºå®šã—ãªã„ï¼‰
        const ret = (typeof u.apply === 'function') ? u.apply() : true;
        if (ret === false) return;

        // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæ­¦å™¨ä»¥å¤–ï¼‰
        if (!u.isWeapon) {
          sessionTracking.upgradesTaken++;
        }

        chosen.add(u);
        c.classList.add('selected');
        picksLeft--;
        updatePickHUD();

        if (picksLeft <= 0) {
          // å°‘ã—æ¼”å‡ºã‚’è¦‹ã›ã¦ã‹ã‚‰é–‰ã˜ã‚‹
          setTimeout(() => {
            chestEl.style.display = 'none';
            chestHUD.style.display = 'none';
            state.paused = false;
          }, 150);
        }
      } catch (err) {
        console.error('Chest upgrade apply failed:', u && u.name, err);
      }
    };

    chestRow.appendChild(c);
  }

  // åˆæœŸè¡¨ç¤ºã‚’æ›´æ–°
  updatePickHUD();
  
  // é¸æŠæ•°ãŒ2æšä»¥ä¸Šã®ã¨ãã¯ã€è¦‹å‡ºã—ã‚’ä¸€ç¬ã ã‘è»½ãæ‹¡å¤§ï¼ˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å‘ä¸Šï¼‰
if (pickCount > 1) {
  pickModeEl.animate([{ transform: 'translateY(-2px) scale(1.0)' }, { transform: 'translateY(-2px) scale(1.06)' }, { transform: 'translateY(-2px) scale(1.0)' }], { duration: 380, easing: 'ease-out' });
}

  // ãƒ‘ã‚¹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
  const chestPassBtn = document.getElementById('chestPassBtn');
  if (chestPassBtn) {
    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆè¤‡æ•°å›å‘¼ã°ã‚Œã‚‹å¯¾ç­–ï¼‰
    const newBtn = chestPassBtn.cloneNode(true);
    chestPassBtn.parentNode.replaceChild(newBtn, chestPassBtn);
    
    newBtn.onclick = () => {
      // å®ç®±ãƒ‘ã‚¹ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹: +3,000ç‚¹
      state.score += 3000;
      addEffect('text', { x: state.player.x, y: state.player.y, life: 1.4, text: 'å®ç®±ãƒ‘ã‚¹ +3,000' });
      
      // å®ç®±ã‚’é–‰ã˜ã‚‹
      chestEl.style.display = 'none';
      chestHUD.style.display = 'none';
      state.paused = false;
    };
  }

}


function addXP(v){
  // æ™‚é–“å€ç‡
  v = Math.round(v * xpMulByTime());
  // Hardcoreè£œæ­£ã¯å‰Šé™¤ï¼ˆé›£æ˜“åº¦èª¿æ•´ï¼‰

  state.player.xp += v;
  while (state.player.xp >= state.player.nextXp(state.player.level)) {
    state.player.xp -= state.player.nextXp(state.player.level);
    state.player.level++;
    playLevelUpSound(); // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—åŠ¹æœéŸ³
    
    // ãƒ¬ãƒ™ãƒ«å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
    checkLevelAchievements();
    
    if (state.player.level === 3) {
      state.bossTimer = 60 + Math.random()*20;
      state.bigBossTimer = 140 + Math.random()*30;
    }
    offerUpgrades();
  }
}

// ==== ä¿®æ­£ç‰ˆ offerUpgradesï¼ˆãƒªãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‰ ====
function pickUpgradeChoices(n=3){
  const pool = ALL_UPGRADES.filter(u => u.can());
  const choices = [];
  while (choices.length < n && pool.length) {
    const i = (Math.random() * pool.length) | 0;
    choices.push(pool.splice(i, 1)[0]);
  }
  return choices;
}

function offerUpgrades(){
  // ã“ã®ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ä¸­ã«ãƒªãƒ­ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸã‹ã©ã†ã‹ï¼ˆ1å›ã ã‘ï¼‰
  window._rerollUsedThisLevel = false;
  const choices = pickUpgradeChoices(4); // â˜…3â†’4ã«å¤‰æ›´
  showLevelUp(choices);
}

function xpMulByTime(){
  if(state.timeSec < 360) return 1.0;              // ã€œ6:00 ã¯ç­‰å€
  const t = Math.min(1, (state.timeSec - 360) / 240); // 6:00â†’10:00 ã® 240ç§’ã§æ®µéšä¸Šã’
  return 1.0 + t * 0.8;                            // 10:00ã§æœ€å¤§1.8å€ï¼ˆä¾‹ï¼‰
}

// ==== ä¿®æ­£ç‰ˆ showLevelUpï¼ˆãƒªãƒ­ãƒ¼ãƒ«å¯¾å¿œï¼‹èƒ½åŠ›ã‚’ã¨ã‚‰ãªã„é¸æŠè‚¢ï¼‰ ====
function showLevelUp(choices){
  // å‚ç…§ã¯æ¯å›å–ã‚Šç›´ã—ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—å·®ç•°ãƒ»é‡è¤‡å®šç¾©å¯¾ç­–ï¼‰
  const levelupEl = document.getElementById('levelup');
  const cardRow   = document.getElementById('cardRow');
  if (!levelupEl || !cardRow) return;

  state.paused = true;
  levelupEl.style.display = 'flex';
  cardRow.innerHTML = '';

  // é¸æŠã‚«ãƒ¼ãƒ‰ã‚’ä¸¦ã¹ã‚‹ï¼ˆå¾“æ¥ã¨åŒã˜ï¼‰
  for (const u of choices) {
    const c = document.createElement('button');
    c.className = 'card';
    // descãŒé–¢æ•°ã®å ´åˆã¯å®Ÿè¡Œã€ãã†ã§ãªã‘ã‚Œã°ãã®ã¾ã¾ä½¿ç”¨
    const descText = typeof u.desc === 'function' ? u.desc() : (u.desc || '');
    c.innerHTML = `<h3>${u.name}</h3><p>${descText}</p>`;
    c.onclick = () => {
      // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚«ã‚¦ãƒ³ãƒˆï¼ˆæ­¦å™¨ä»¥å¤–ï¼‰
      if (!u.isWeapon) {
        sessionTracking.upgradesTaken++;
      }
      
      // èƒ½åŠ›ã‚’é©ç”¨ã—ã¦é–‰ã˜ã‚‹
      u.apply();
      state.paused = false;
      levelupEl.style.display = 'none';
      cardRow.innerHTML = '';
      // æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§ã¯ã¾ãŸ1å›ãƒªãƒ­ãƒ¼ãƒ«å¯èƒ½ã«
      window._rerollUsedThisLevel = false;
      // ãƒªãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ãŒæ®‹ã£ã¦ã„ã‚Œã°å¿µã®ãŸã‚ç„¡åŠ¹åŒ–
      const btn = document.getElementById('rerollBtn');
      if (btn) btn.disabled = true;
    };
    cardRow.appendChild(c);
  }
  
  // ===== ã€Œèƒ½åŠ›ã‚’ã¨ã‚‰ãªã„ã€é¸æŠè‚¢ã‚’è¿½åŠ  =====
  const skipCard = document.createElement('button');
  skipCard.className = 'card';
  skipCard.style.background = '#2d2d2d';
  skipCard.style.borderColor = '#666';
  skipCard.innerHTML = `<h3>ğŸš« èƒ½åŠ›ã‚’ã¨ã‚‰ãªã„</h3><p>ç¸›ã‚Šãƒ—ãƒ¬ã‚¤ç”¨ã€‚ã‚¹ã‚³ã‚¢ +5000</p>`;
  skipCard.onclick = () => {
    // ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒŠã‚¹
    state.score = (state.score || 0) + 5000;
    addEffect('text', { x: state.player.x, y: state.player.y, life: 1.2, text: 'ã‚¹ã‚­ãƒƒãƒ—ãƒœãƒ¼ãƒŠã‚¹ +5000' });
    
    state.paused = false;
    levelupEl.style.display = 'none';
    cardRow.innerHTML = '';
    window._rerollUsedThisLevel = false;
    const btn = document.getElementById('rerollBtn');
    if (btn) btn.disabled = true;
  };
  cardRow.appendChild(skipCard);

  // ===== ãƒªãƒ­ãƒ¼ãƒ«ãƒ»ãƒœã‚¿ãƒ³ï¼ˆã“ã®ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ä¸­ã¯1å›ã ã‘ï¼‰ =====
  let rr = document.getElementById('rerollBtn');
  if (!rr){
    rr = document.createElement('button');
    rr.id = 'rerollBtn';
    rr.className = 'btn';
    rr.textContent = 'ãƒªãƒ­ãƒ¼ãƒ«ï¼ˆ1å›ã ã‘ï¼‰';
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯æ§ãˆã‚ã«ï¼šã‚«ãƒ¼ãƒ‰è¡Œã®ä¸‹ã¸é…ç½®
    rr.style.margin = '12px auto 0';
    rr.style.display = 'block';
    levelupEl.appendChild(rr);
  }
  // çŠ¶æ…‹åæ˜ 
  rr.disabled = !!window._rerollUsedThisLevel;
  rr.textContent = window._rerollUsedThisLevel ? 'ãƒªãƒ­ãƒ¼ãƒ«ä½¿ç”¨æ¸ˆã¿' : 'ãƒªãƒ­ãƒ¼ãƒ«ï¼ˆ1å›ã ã‘ï¼‰';

  rr.onclick = () => {
    if (window._rerollUsedThisLevel) return;
    window._rerollUsedThisLevel = true;
    
    // ãƒªãƒ­ãƒ¼ãƒ«ã‚«ã‚¦ãƒ³ãƒˆ
    sessionTracking.rerollCount++;
    achievementProgress.totalRerolls++;
    
    // ãƒªãƒ­ãƒ¼ãƒ«å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
    if (sessionTracking.rerollCount >= 20) unlockAchievement('reroll_20');
    
    // æ–°ã—ã„4æŠã‚’ä½œã‚Šç›´ã—ã¦ã€åŒã˜UIã«å·®ã—æ›¿ãˆ
    const newChoices = pickUpgradeChoices(4); // â˜…3â†’4ã«å¤‰æ›´
    showLevelUp(newChoices);
    // ä»Šå›ã¯ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    const btn = document.getElementById('rerollBtn');
    if (btn){
      btn.disabled = true;
      btn.textContent = 'ãƒªãƒ­ãƒ¼ãƒ«ä½¿ç”¨æ¸ˆã¿';
    }
  };

  // æœ€åˆã®ã‚«ãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œã®ã—ã‚„ã™ã•å‘ä¸Šï¼‰
  const first = cardRow.querySelector('.card');
  if (first) first.focus();
}


// === Stage Definitions ===
const STAGES = {
  stage1: {
    id: 'stage1',
    name: 'ã‚¹ãƒ†ãƒ¼ã‚¸1: å››è§’ã®ä¸–ç•Œ',
    shape: 'square',
    bgColor: '#1a1a2e',
    unlocked: true,
    obstacles: []  // éšœå®³ç‰©ãªã—
  },
  stage2: {
    id: 'stage2', 
    name: 'ã‚¹ãƒ†ãƒ¼ã‚¸2: ä¸‰è§’ã®ä¸–ç•Œ',
    shape: 'triangle',
    bgColor: '#2a1515',  // ã»ã‚“ã®ã‚Šèµ¤é»’ã
    unlocked: false,  // ã‚¹ãƒ†ãƒ¼ã‚¸1ã‚¯ãƒªã‚¢ã§è§£æ”¾
    // éšœå®³ç‰©ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆç›¸å¯¾åº§æ¨™ 0-1ï¼‰
    obstaclesTemplate: [
      // å·¦åˆ—
      { rx: 0.20, ry: 0.20, size: 60 },
      { rx: 0.20, ry: 0.50, size: 60 },
      { rx: 0.20, ry: 0.80, size: 60 },
      // ä¸­å¤®åˆ—
      { rx: 0.50, ry: 0.35, size: 60 },
      { rx: 0.50, ry: 0.65, size: 60 },
      // å³åˆ—
      { rx: 0.80, ry: 0.20, size: 60 },
      { rx: 0.80, ry: 0.50, size: 60 },
      { rx: 0.80, ry: 0.80, size: 60 }
    ]
  }
};


  // === Weapons with Awaken ===
  const weapons = {
blaster:{ short:'BL', name:'ãƒ–ãƒ©ã‚¹ã‚¿ãƒ¼', lv:1, awaken:false, cd:0, baseRate:.48, baseDmg:15, baseSpeed:360, range:500, rangeAwaken:660,  // â˜…baseDmg 12â†’15
      update(dt){
        if(this.lv<=0) return;
        this.cd-=dt; if(this.cd>0) return;
        const target = nearestEnemy(state.player.x,state.player.y); if(!target) return;
        const dmg = (this.baseDmg + 3*(this.lv-1)) * (this.awaken? 1.2:1);
        const rate = this.awaken ? 0.05 : Math.max(.05, this.baseRate * (1 - 0.22*(this.lv-1)));
        const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const off = 6;
        let positions;
        if(this.lv>=3){ positions = [0, -off, off]; }
        else if(this.lv>=2){ positions = [-off, off]; }
        else { positions = [0]; }
        // å¼¾æ•°ã‚’è€ƒæ…®ã—ã¦1ç™ºã‚ãŸã‚Šã®å¨åŠ›ã‚’èª¿æ•´
const shotCount = positions.length;
const lifeEach = ((this.awaken ? this.rangeAwaken : this.range) / this.baseSpeed);


for(const o of positions){
  state.bullets.push({
    type:'bullet',
    x: state.player.x + nx*o,
    y: state.player.y + ny*o,
    vx: Math.cos(ang) * this.baseSpeed,
    vy: Math.sin(ang) * this.baseSpeed,
    r: 5 * state.mods.sizeMul,
    dmg: (dmg * state.mods.dmgMul) / Math.max(1, shotCount * 0.90), // â˜… èª¿æ•´
    life: lifeEach
      });

}
playShotSound('blaster'); // åŠ¹æœéŸ³
        this.cd = rate * state.mods.rateMul;
      }
    },
    shotgun:{
  short:'SG', name:'ã‚·ãƒ§ãƒƒãƒˆã‚¬ãƒ³',
  lv:0, awaken:false, cd:0,
  baseRate:1.2, baseDmg:36, baseSpeed:340, // 20 â†’ 36ï¼ˆ1.8å€ï¼‰
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const target = nearestEnemy(state.player.x, state.player.y);
    if(!target) return;

    const count = 5 + (this.lv-1)*2;                // å¼¾æ•°ã¯ä»Šã®ã¾ã¾
    const spread = 0.2 - 0.02*(this.lv-1);           // æ‹¡æ•£ã‚‚ä»Šã®ã¾ã¾
    const dmg = (this.baseDmg + 5.4*(this.lv-1))    // 3 â†’ 5.4ï¼ˆ1.8å€ï¼‰
                 * state.mods.dmgMul;

    for(let i=0;i<count;i++){
      const ang = Math.atan2(target.y-state.player.y, target.x-state.player.x) + rnd(-spread,spread);
      state.bullets.push({
        type:'bullet',
        x: state.player.x, y: state.player.y,
        vx: Math.cos(ang)*this.baseSpeed,
        vy: Math.sin(ang)*this.baseSpeed,
        r: 4*state.mods.sizeMul,
        dmg,
        life: 1.0  // â˜… å¯¿å‘½ã‚’å°‘ã—çŸ­ç¸®ï¼ˆ1.2â†’1.0ï¼‰ã§ã€Œè¿‘è·é›¢å°‚ç”¨æ„Ÿã€
      });
    }

    if(this.awaken){
      const n = 24;
      for(let k=0;k<n;k++){
        const ang = (Math.PI*2*k)/n;
        state.bullets.push({
          type:'bullet',
          x: state.player.x, y: state.player.y,
          vx: Math.cos(ang)*this.baseSpeed*0.9,
          vy: Math.sin(ang)*this.baseSpeed*0.9,
          r: 4*state.mods.sizeMul,
          dmg: this.baseDmg * 0.85 * state.mods.dmgMul, // â˜… è¦šé†’æ™‚ã¯1ç™ºå°‘ã—å¼±ã‚
          life: 0.8
        });
      }
    }

    playShotSound('shotgun'); // åŠ¹æœéŸ³
    this.cd = Math.max(.45, this.baseRate * (1 - 0.15*(this.lv-1)))
              * (this.awaken? 0.8:1)
              * state.mods.rateMul;
  }
},

homing:{
  short:'HM', name:'ãƒ›ãƒ¼ãƒŸãƒ³ã‚°',
  lv:0, awaken:false, cd:0,
  baseRate:2.4, baseDmg:16,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const count = (2 + (this.lv-1)) * (this.awaken? 1.5:1);
    for(let i=0;i<Math.ceil(count);i++){
      const ang = Math.random()*Math.PI*2;
      const power = this.baseDmg * (this.awaken? 1.4:1) * 1.12; // 0.80 â†’ 1.12ï¼ˆ1.4å€å¼·åŒ–ï¼‰
      const life = this.awaken ? 4.0 : 5.0;

      state.bullets.push({
        type:'homing',
        x: state.player.x, y: state.player.y,
        vx: Math.cos(ang)*204, // 170 â†’ 204ï¼ˆ1.2å€ï¼‰
        vy: Math.sin(ang)*204, // 170 â†’ 204ï¼ˆ1.2å€ï¼‰
        r: 6*state.mods.sizeMul,
        dmg: power * state.mods.dmgMul,
        life: life,
        seek: 400,
        turn: 7.2,
        bigBoom: this.awaken,
        boomR: this.awaken ? 240 : 60, // è¦šé†’æ™‚ã‚’2å€ã«ï¼ˆ120â†’240ï¼‰
        boomMul: this.awaken ? 1.0 : 0.7
      });
    }

    this.cd = Math.max(1.2, this.baseRate * (1 - 0.2*(this.lv-1)))
              * (this.awaken? 0.85:1)
              * state.mods.rateMul;
  }
},

lightning:{ short:'LT', name:'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', lv:0, awaken:false, cd:0, baseRate:2.2, baseDmg:16,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    // â˜…Lvã§æœ¬æ•°å¢—ï¼è¦šé†’ã¯å¸¸ã«7ç™º
    let count = this.awaken ? 7 : Math.max(1, this.lv); // Lv1=1, Lv2=2, Lv3=3

    const targets = pickMultiple(state.enemies, count);
    if(!targets.length) return;
    for(const e of targets){
      strikeLightning(e, 1 + 0.25*(this.lv-1));
    }
    playShotSound('lightning'); // åŠ¹æœéŸ³

    this.cd = Math.max(0.8, this.baseRate * (1 - 0.22*(this.lv-1))) * (this.awaken? 0.65:0.9) * state.mods.rateMul;
  }
},

rock:{
  short:'RK', name:'ãƒ­ãƒƒã‚¯', lv:0, awaken:false, cd:0, baseRate:1.0,
  update(dt){
    if(this.lv<=0) return;
    this.cd -= dt; if(this.cd>0) return;

    const activeRocks = state.bullets.filter(b=>b.type==='rock').length;
    if(activeRocks>0) return;

    let dir = state.input.lastDir;
    if(Math.hypot(dir.x,dir.y) < 0.1){
      const t = nearestEnemy(state.player.x,state.player.y);
      if(t){ const a = Math.atan2(t.y-state.player.y, t.x-state.player.x); dir = {x:Math.cos(a), y:Math.sin(a)}; }
      else { dir={x:1,y:0}; }
    }

    const sizeBase = (24 + (this.lv-1)*7) * state.mods.sizeMul;
    const speed    = 190;
    const baseDmg  = (25 + 10*(this.lv-1)) * state.mods.dmgMul * 0.55; // 0.6 â†’ 0.55 ã«æ¸›å°‘
    const bossMul  = 1.1;

const addRock=(ang)=>{
  const sz  = sizeBase * (this.awaken ? 2.0 : 1.0);
  state.bullets.push({
    type:'rock',
    x:state.player.x, y:state.player.y,
    vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed,
    r:sz,
    dmg:baseDmg,
    life:3.4,                 // 3.2â†’3.4ï¼ˆå°‘ã—é•·ãè»¢ãŒã‚‹ï¼‰
    pierce:true,
    bossMul,                  // å½“ãŸã‚Šå´ã§å‚ç…§
    spin: Math.random()*Math.PI*2   // â˜… åˆæœŸè‡ªè»¢è§’ï¼ˆ0ã§ã‚‚OKï¼‰
  });
};

    const base = Math.atan2(dir.y,dir.x);
    if(this.awaken){
      const spread = Math.PI * 2 / 3;
      addRock(base); addRock(base + spread); addRock(base - spread);
    }else{
      addRock(base);
    }
    playShotSound('rock'); // åŠ¹æœéŸ³
    this.cd = Math.max(0.9, this.baseRate * (1 - 0.10*(this.lv-1))) * (this.awaken? 1.25:1);
  }
},

orbit:{
  short:'OR', name:'ã‚ªãƒ¼ãƒ“ãƒƒãƒˆ',
  lv:0, awaken:false, count:0,
  baseR:72,          // 72 â†’ 84ï¼ˆåºç›¤ã§ã‚‚å±Šãã‚„ã™ãï¼‰
  dmg:9,             // 7 â†’ 9ï¼ˆæ¥è§¦DPSã®å…ƒï¼‰
  ang:0,
  // è¿½åŠ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  hitRBase:14,       // ç‰ã®å½“ãŸã‚ŠåŠå¾„ã®åŸºæº–ï¼ˆæç”»ã‚‚ã“ã‚Œã«åˆã‚ã›ã‚‹ï¼‰
  dpsBase:10,        // æ¥è§¦DPSã®åŸºæº–ï¼ˆãƒ¬ãƒ™ãƒ«ã§ä¼¸ã°ã™ï¼‰
  kbBase:220,        // ãƒãƒƒã‚¯ãƒãƒƒã‚¯åŸºæº–ï¼ˆ/ç§’ï¼‰
  update(dt){
    if(this.lv<=0) return;
    this.ang += dt*(this.awaken? 3.6:1.8); // å›è»¢ã¡ã‚‡ã„é€Ÿã‚
  }
},
    
blade:{
  short:'BD', name:'ãƒ–ãƒ¬ãƒ¼ãƒ‰', lv:0, awaken:false, cd:0,
  baseRate: 1.10,
  baseDmg:  52,
  span:     Math.PI * 0.5,  // å°‘ã—ç‹­ã
  baseR:    50,
  expandLv: [60, 90, 120, 180],  // åŠå¾„æ‹¡å¤§UP

update(dt){
  if (this.lv <= 0) return;
  this.cd -= dt; if (this.cd > 0) return;

  let dir = state.input.lastDir;
  if (Math.hypot(dir.x, dir.y) < 0.1){
    const t = nearestEnemy(state.player.x, state.player.y);
    if (t){
      const a = Math.atan2(t.y - state.player.y, t.x - state.player.x);
      dir = { x: Math.cos(a), y: Math.sin(a) };
    } else {
      dir = { x: 1, y: 0 };
    }
  }
  const baseAng = Math.atan2(dir.y, dir.x);

  const count = this.awaken ? 12 : Math.min(this.lv * 2, 6);
  
  const lvIdx = this.awaken ? 3 : Math.min(this.lv - 1, 2);
  const expandDist = this.expandLv[lvIdx];
  const scale = this.awaken ? 1.3 : 1.0;
  const angleOffset = this.awaken ? 0.015 : [0.04, 0.03, 0.025][lvIdx];  // è§’åº¦ãšã‚Œã•ã‚‰ã«ç¸®å°
  const interval = this.awaken ? 0.06 : [0.20, 0.15, 0.10][lvIdx];  // é–“éš”èª¿æ•´
  
  const dmgBase = this.baseDmg * (1 + 0.25 * (this.lv - 1));
  const dmg = Math.round(dmgBase * state.mods.dmgMul);

  for (let i = 0; i < count; i++){
    const reverse = i % 2 === 1;
    const angOff = angleOffset * (i - (count - 1) / 2);
    
    schedule(() => {
      const a = baseAng + angOff;
      
      const maxR = (this.baseR + expandDist) * scale * state.mods.sizeMul;
      dealSlashDamage(
        state.player.x, state.player.y,
        a, this.span,
        0, maxR,
        dmg
      );

      addEffect('slashNew', {
        x: state.player.x, y: state.player.y,
        ang: a, span: this.span,
        baseR: this.baseR * scale * state.mods.sizeMul,
        expandDist: expandDist * scale * state.mods.sizeMul,
        reverse: reverse,
        life: 0.25,
        life0: 0.25
      });
      
      addEffect('slashRay', {
        x: state.player.x, y: state.player.y,
        ang: a,
        length: 60 * scale * state.mods.sizeMul,
        life: 0.15,
        life0: 0.15
      });
    }, i * interval);
  }

  playShotSound('blade');

  // CTå›ºå®š1.1ç§’ï¼ˆé€£æ’ƒãŒé•·ããªã‚‹åˆ†ã€å®Ÿè³ªCTãŒçŸ­ããªã‚‹ï¼‰
  this.cd = 1.1 * state.mods.rateMul;
}

},
    
    
ghost:{
  short:'GH', name:'ã‚´ãƒ¼ã‚¹ãƒˆ', lv:0, awaken:false,
  cd:0, baseRate:1.10, ang:0,   // â† angã‚’æŒãŸã›ã¦å›è»¢ç®¡ç†
  update(dt){
    if(this.lv<=0) return;

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’1å›ã ã‘æ¸›ç®—
    this.cd -= dt;

    // ã‚´ãƒ¼ã‚¹ãƒˆæ•° & å›è»¢
    const count = this.awaken ? 6 : this.lv; // Lv1=1, Lv2=2, Lv3=3 / è¦šé†’=6
    this.ang += dt * (this.awaken ? 1.6 : 1.0);

    // ç™ºå°„ãƒˆãƒªã‚¬
    if(this.cd <= 0){
      // â–¶ ç™ºå°„é–“éš”ï¼šçŸ­ç¸®ï¼†ãƒ¬ãƒ™ãƒ«ã§ã•ã‚‰ã«çŸ­ç¸®ã€è¦šé†’ã§å°‘ã—æ—©ã‚
      this.cd = Math.max(0.42, this.baseRate * (1 - 0.18*(this.lv-1))) * (this.awaken ? 0.85 : 1.0) * state.mods.rateMul;

      for(let k=0;k<count;k++){
        const a = this.ang + k * (Math.PI*2/count);
        const r = 40 + 6*(this.lv-1);
        const gx = state.player.x + Math.cos(a)*r;
        const gy = state.player.y + Math.sin(a)*r;

        const t = nearestEnemy(gx, gy);
        if(!t) continue;

        const base = Math.atan2(t.y-gy, t.x-gx);
        const spread = 0.3; // 3ç™ºã®æ‹¡æ•£
        for(const off of [0, -spread, spread]){
          state.bullets.push({
            type:'ghost',             // â† ã‚´ãƒ¼ã‚¹ãƒˆå°‚ç”¨ã‚¿ã‚¤ãƒ—ï¼ˆç´«è‰²ï¼‰
            x:gx, y:gy,
            vx:Math.cos(base+off)*360,
            vy:Math.sin(base+off)*360,
            r:6*state.mods.sizeMul,   // â† å°‘ã—å¤§ãã‚
            dmg:(2.5 + 3*(this.lv-1)) * (this.awaken ? 1.1 : 1.0) * state.mods.dmgMul,
            life:3.0,
            pierce:1                  // â† è²«é€šå›æ•°1ã«æ¸›å°‘ï¼ˆå¼·ã™ãã‚’é˜²æ­¢ï¼‰
          });
        }
      }
      playShotSound('ghost'); // åŠ¹æœéŸ³
    }
    // ã‚´ãƒ¼ã‚¹ãƒˆã®è¦‹ãŸç›®ã¯ draw() å´ã§OKï¼ˆåŠé€æ˜ã®éœŠä½“ãªã©ï¼‰
  }
},

poison:{
  short:'æ¯’', name:'ãƒã‚¤ã‚ºãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰',
  lv:0, awaken:false, cd:0,
  baseCd:2.0, baseR:80, dps:14, lifeSec:5,
  update(dt){
    if(this.lv<=0) return;

    this.cd -= dt;
    if(this.cd<=0){
      // é€šå¸¸ï¼šè¶³å…ƒã«1æšã€5ç§’ç¶­æŒ
      state.effects.push({
        type:'poisonField',
        x: state.player.x, y: state.player.y,
        r: (this.baseR + (this.lv-1)*24) * state.mods.sizeMul,
        dps: this.dps * state.mods.dmgMul,
        life: this.lifeSec, life0: this.lifeSec
      });

      // è¦šé†’ï¼šè‡ªåˆ†ã®å‘¨å›²ã«3æšã‚’åŒæ™‚å±•é–‹ï¼ˆå›ºå®šï¼‰
      if(this.awaken){
        const baseR = (this.baseR + (this.lv-1)*24) * 0.9 * state.mods.sizeMul;
        const orbit = 110;
        for(let k=0;k<3;k++){
          const a = state.t + k * (Math.PI*2/3);
          state.effects.push({
            type:'poisonField',
            x: state.player.x + Math.cos(a)*orbit,
            y: state.player.y + Math.sin(a)*orbit,
            r: baseR,
            dps: this.dps * 0.9 * state.mods.dmgMul,
            life: this.lifeSec, life0: this.lifeSec
          });
        }
      }

      playShotSound('poison'); // åŠ¹æœéŸ³
      this.cd = this.baseCd * state.mods.rateMul;
    }
  }
},


    
    
    nova:{ short:'NV', name:'ãƒãƒ´ã‚¡', lv:0, awaken:false, cd:0, baseRate:3.2, baseDmg:28, baseR:96, auraT:0,
      update(dt){
        if(this.lv<=0) return;
        this.cd -= dt; if(this.cd<=0){
          // æ—¢å­˜ã®è·é›¢å¼ã«å€ç‡ã§ä¸Šä¹—ã›ï¼ˆè¦šé†’ã§ã•ã‚‰ã«åºƒãï¼‰
const lv = Math.max(1,this.lv);
const baseR = (this.baseR + 22*(lv-1)) * state.mods.sizeMul;
const R = baseR * (1.35 + 0.12*(lv-1)) * (this.awaken ? 1.20 : 1.00);
          const dmg = (this.baseDmg + 10*(this.lv-1)) * state.mods.dmgMul;
          addEffect('nova',{x:state.player.x,y:state.player.y,r:R, life:.25});
          let hits = 0;
          for(const e of state.enemies){
            // â˜…ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯ç„¡åŠ¹
            if(e.type === 'spinner' && e.spinPhase === 'highspin') continue;
            
            const d = Math.hypot(e.x-state.player.x, e.y-state.player.y);
            if(d<R) { e.hp -= dmg; e.hitFlash = Math.max(e.hitFlash, 0.12);
            hits++;

                // === ãƒãƒ´ã‚¡ãƒ»ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ— ===
  const base = 0.5; // 0.08 â†’ 0.5ç§’ã«å»¶é•·ï¼ˆç´„6å€ï¼‰
  const resist = (e.type==='final') ? 0.35 : 
                 (e.type==='big'||e.type==='mid') ? 0.6 : 
                 1.0;
  e.stun = Math.max(e.stun||0, base * resist);
             }
          }
          
          
          // â€» ãƒãƒ´ã‚¡ã®å›å¾©åŠ¹æœã¯å‰Šé™¤ï¼ˆãƒãƒ©ãƒ³ã‚¹èª¿æ•´ï¼‰

          playShotSound('nova'); // åŠ¹æœéŸ³
          
          
          
          this.cd = Math.max(1.3, this.baseRate * (1 - 0.22*(this.lv-1))) * 0.32;
                  }
        if(this.awaken){
  this.auraT += dt;
  const R2 = (110 + 20*(this.lv-1)) * state.mods.sizeMul;
  addEffect('aura',{x:state.player.x,y:state.player.y,r:R2, life:.06});

  let auraHits = 0;
for (const e of state.enemies){
  // â˜…ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯ç„¡åŠ¹
  if(e.type === 'spinner' && e.spinPhase === 'highspin') continue;
  
  const d = Math.hypot(e.x - state.player.x, e.y - state.player.y);
  if (d < R2){
    e.hp -= (27 + 4.5*(this.lv-1)) * state.mods.dmgMul * dt; // â˜…18â†’27ã€3â†’4.5ï¼ˆ1.5å€ï¼‰
    e.hitFlash = Math.max(e.hitFlash, 0.05);
    auraHits++;
  }
}





}
      }
    },
    
    rubber:{
      short:'RB', name:'ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆ', lv:0, awaken:false, cd:0,
      baseRate:2.0, baseDmg:12, ballSpeed:540, // ãƒ€ãƒ¡ãƒ¼ã‚¸ 18 â†’ 12 ã«æ¸›å°‘
      update(dt){
        if(this.lv<=0) return;
        this.cd -= dt; if(this.cd>0) return;

        // ãƒ¬ãƒ™ãƒ«ã”ã¨ã®çƒæ•°: Lv1=1, Lv2=2, Lv3=3, è¦šé†’=8
        const count = this.awaken ? 8 : this.lv;
        const power = this.baseDmg * (this.awaken? 1.3:1);
        
        for(let i=0; i<count; i++){
          const ang = Math.random()*Math.PI*2;
          const speed = this.ballSpeed;
          
          state.bullets.push({
            type:'rubber',
            x: state.player.x, y: state.player.y,
            vx: Math.cos(ang)*speed,
            vy: Math.sin(ang)*speed,
            r: 8*state.mods.sizeMul,
            dmg: power * state.mods.dmgMul,
            life: this.awaken ? 8.0 : 6.0, // 3.0/4.0 â†’ 6.0/8.0ï¼ˆ2å€ï¼‰
            bounces: 0, // åå°„å›æ•°
            maxBounces: this.awaken ? 25 : 15
          });
        }

        playShotSound('blaster'); // åŠ¹æœéŸ³ï¼ˆåå°„éŸ³ï¼‰
        this.cd = Math.max(1.0, this.baseRate * (1 - 0.15*(this.lv-1)))
                  * (this.awaken? 0.75:1)
                  * state.mods.rateMul;
      }
    },
    
    laser:{
      short:'LZ', name:'ãƒ¬ãƒ¼ã‚¶ãƒ¼', lv:0, awaken:false, cd:0,
      baseRate: 1.2,    // ç™ºå°„é–“éš”ï¼ˆ0.8â†’1.2ï¼‰
      baseDmg: 32,      // â˜…åŸºæœ¬ãƒ€ãƒ¡ãƒ¼ã‚¸
      baseWidth: 8,     // åŸºæœ¬å¤ªã•ï¼ˆ6â†’8ï¼‰
      range: 800,       // å°„ç¨‹
      // â˜…è¦šé†’æ™‚ã®ç¶™ç¶šãƒ¬ãƒ¼ã‚¶ãƒ¼ç”¨
      beamActive: false,
      beamTimer: 0,
      beamAngle: 0,
      beamDmg: 0,
      beamWidth: 0,
      beamRange: 0,
      update(dt){
        if(this.lv<=0) return;
        
        // â˜…è¦šé†’æ™‚ï¼šç¶™ç¶šãƒ¬ãƒ¼ã‚¶ãƒ¼å‡¦ç†ï¼ˆè¿½å°¾ãªã—ã€å›ºå®šæ–¹å‘ï¼‰
        if(this.awaken && this.beamActive){
          this.beamTimer -= dt;
          
          // ãƒ“ãƒ¼ãƒ ç¶™ç¶šä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆç¶šã‘ã‚‹ï¼ˆè¿½å°¾ãªã—ï¼‰
          const endX = state.player.x + Math.cos(this.beamAngle) * this.beamRange;
          const endY = state.player.y + Math.sin(this.beamAngle) * this.beamRange;
          
          // ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
          for(const e of state.enemies){
            if(e.invincible) continue;
            const dx = endX - state.player.x;
            const dy = endY - state.player.y;
            const len = Math.hypot(dx, dy);
            const t = Math.max(0, Math.min(1, 
              ((e.x - state.player.x) * dx + (e.y - state.player.y) * dy) / (len * len)
            ));
            const closestX = state.player.x + t * dx;
            const closestY = state.player.y + t * dy;
            const distToLaser = Math.hypot(e.x - closestX, e.y - closestY);
            const hitRadius = (e.size || 15) / 2 + this.beamWidth / 2;
            if(distToLaser < hitRadius){
              e.hp -= this.beamDmg * dt; // â˜…æ¯ç§’ãƒ€ãƒ¡ãƒ¼ã‚¸
              e.hitFlash = Math.max(e.hitFlash, 0.08);
            }
          }
          
          // ç¶™ç¶šãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆé »åº¦ã‚’ä¸‹ã’ã¦è»½é‡åŒ–ï¼‰
          if (!this._lastEffectTime || (performance.now() - this._lastEffectTime) > 50) {
            addEffect('playerLaser', {
              x: state.player.x, y: state.player.y,
              angle: this.beamAngle, length: this.beamRange, width: this.beamWidth,
              life: 0.08, awaken: true
            });
            this._lastEffectTime = performance.now();
          }
          
          if(this.beamTimer <= 0){
            this.beamActive = false;
            this.cd = 0.8; // â˜…0.8ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
          }
          return;
        }
        
        this.cd -= dt; if(this.cd>0) return;
        
        // è¿‘ãã®æ•µã‚’è‡ªå‹•ã§ç‹™ã†
        const target = nearestEnemy(state.player.x, state.player.y);
        if(!target) return;
        
        const angle = Math.atan2(target.y - state.player.y, target.x - state.player.x);
        
        // ãƒ¬ãƒ™ãƒ«ã§å¨åŠ›ã¨å¤ªã•ãŒå¢—åŠ 
        const awakenMul = this.awaken ? 2.5 : 1;
        const dmg = (this.baseDmg + 25 * (this.lv - 1)) * awakenMul * state.mods.dmgMul;
        const width = (this.baseWidth + 4 * (this.lv - 1)) * awakenMul * state.mods.sizeMul;
        const range = this.range * (this.awaken ? 1.2 : 1);
        
        // â˜…è¦šé†’æ™‚ã¯ç¶™ç¶šãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚’ç™ºå°„
        if(this.awaken){
          this.beamActive = true;
          this.beamTimer = 0.8; // 0.8ç§’é–“ç¶™ç¶š
          this.beamAngle = angle;
          this.beamDmg = dmg * 2.5; // â˜…æ¯ç§’ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆè²«é€šã‚ã‚‹ã®ã§æ§ãˆã‚ï¼‰
          this.beamWidth = width;
          this.beamRange = range;
          playShotSound('laser');
          return;
        }
        
        // é€šå¸¸æ™‚ï¼šå˜ç™ºãƒ€ãƒ¡ãƒ¼ã‚¸
        const endX = state.player.x + Math.cos(angle) * range;
        const endY = state.player.y + Math.sin(angle) * range;
        
        // è²«é€šãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆãƒ©ã‚¤ãƒ³ä¸Šã®å…¨æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
        for(const e of state.enemies){
          if(e.invincible) continue;
          
          // æ•µã¨ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ©ã‚¤ãƒ³ã®è·é›¢ã‚’è¨ˆç®—
          const dx = endX - state.player.x;
          const dy = endY - state.player.y;
          const len = Math.hypot(dx, dy);
          const t = Math.max(0, Math.min(1, 
            ((e.x - state.player.x) * dx + (e.y - state.player.y) * dy) / (len * len)
          ));
          const closestX = state.player.x + t * dx;
          const closestY = state.player.y + t * dy;
          const distToLaser = Math.hypot(e.x - closestX, e.y - closestY);
          
          // å½“ãŸã‚Šåˆ¤å®šï¼ˆæ•µã®ã‚µã‚¤ã‚º + ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®å¹…ï¼‰
          const hitRadius = (e.size || 15) / 2 + width / 2;
          if(distToLaser < hitRadius){
            e.hp -= dmg;
            e.hitFlash = Math.max(e.hitFlash, 0.15);
          }
        }
        
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆé€šå¸¸æ™‚ï¼‰
        addEffect('playerLaser', {
          x: state.player.x,
          y: state.player.y,
          angle: angle,
          length: range,
          width: width,
          life: 0.12,
          awaken: false
        });
        
        playShotSound('lightning'); // åŠ¹æœéŸ³
        
        // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆãƒ¬ãƒ™ãƒ«ã§çŸ­ç¸®ï¼‰- é€šå¸¸æ™‚ã®ã¿
        this.cd = Math.max(0.5, this.baseRate * (1 - 0.10 * (this.lv - 1)))
                  * state.mods.rateMul;
      }
    }
  };
  state.weapons = weapons;


function strikeLightning(hit, mult){
  // ãƒ€ãƒ¡ãƒ¼ã‚¸
  hit.hp -= weapons.lightning.baseDmg * mult * state.mods.dmgMul;
  hit.hitFlash = Math.max(hit.hitFlash, 0.18);

  // è¦‹ãŸç›®ï¼ˆãƒ’ãƒƒãƒˆåœ°ç‚¹ã¸è½é›·ï¼‰
  const path = buildZigPath(hit.x, hit.y, 8);
  addEffect('zig', { path, life:.22, thick: 6 * state.mods.sizeMul });
  addEffect('flash', { life:.02 }); 
  spark(hit.x, hit.y, 18);

  // â–¼ ãƒã‚§ãƒ¼ãƒ³
  const CHAIN_MAX     = 3;      // è¿½åŠ ãƒ’ãƒƒãƒˆæ•°ï¼ˆå…ƒãƒ’ãƒƒãƒˆï¼‹æœ€å¤§3å›ï¼‰
  const CHAIN_RADIUS  = 180;    // æ¬¡ã®è·³èºã®æ¢ç´¢åŠå¾„
  const FALLOFF       = 0.7;    // ãƒ€ãƒ¡ãƒ¼ã‚¸æ¸›è¡°ï¼ˆ70%ãšã¤ï¼‰
  const SEEN = new Set();       // åŒä¸€æ•µã«å¤šé‡ãƒ’ãƒƒãƒˆã—ãªã„

  SEEN.add(hit);

  let cur = hit;
  let power = mult * FALLOFF;

  for (let i = 0; i < CHAIN_MAX; i++){
    // å€™è£œã‚’æ¢ã™
    let next = null;
    let bestD2 = CHAIN_RADIUS * CHAIN_RADIUS;
    for (const e of state.enemies){
      if (e === cur || SEEN.has(e) || e.hp <= 0) continue;
      const d2 = dist2(cur.x, cur.y, e.x, e.y);
      if (d2 < bestD2){ bestD2 = d2; next = e; }
    }
    if (!next) break;

    // ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆæ¸›è¡°ï¼‰
    next.hp -= weapons.lightning.baseDmg * power * state.mods.dmgMul;
    next.hitFlash = Math.max(next.hitFlash, 0.16);

    // è¦‹ãŸç›®ï¼ˆã‚«ãƒ¼ãƒ–ã—ãŸç¨²å¦»ï¼‰
    const path2 = [
      [cur.x, cur.y],
      [ (cur.x + next.x)/2 + rnd(-22,22), (cur.y + next.y)/2 + rnd(-22,22) ],
      [next.x, next.y]
    ];
    addEffect('zig', { path: path2, life:.18, thick: 5 * state.mods.sizeMul });

    SEEN.add(next);
    cur = next;
    power *= FALLOFF;  // ã•ã‚‰ã«æ¸›è¡°
    if (power < 0.25) break; // ã•ã™ãŒã«å¼±ããªã‚Šã™ããŸã‚‰çµ‚äº†
  }
}


  function nearestEnemy(x,y){
    let best=null, bestD=1e9;
    for(const e of state.enemies){
      const d=dist2(x,y,e.x,e.y);
      if(d<bestD){ bestD=d; best=e; }
    }
    return best;
  }
  
  function pickMultiple(arr, n){
    const copy = arr.slice(); const out=[];
    for(let i=0;i<n && copy.length;i++){ out.push(copy.splice((Math.random()*copy.length)|0,1)[0]); }
    return out;
  }

// æ‰‡å½¢ [inner..outer] Ã— [ang Â± span/2] ã«ã„ã‚‹æ•µã¸ä¸€æ‹¬ãƒ€ãƒ¡ï¼†è»½ã„ãƒãƒƒã‚¯ãƒãƒƒã‚¯
function dealSlashDamage(cx, cy, ang, span, inner, outer, dmg){
  for(let j=state.enemies.length-1;j>=0;j--){
    const e = state.enemies[j];
    // â˜…ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯ç„¡åŠ¹
    if(e.type === 'spinner' && e.spinPhase === 'highspin') continue;
    
    const dx = e.x - cx, dy = e.y - cy;
    const d  = Math.hypot(dx,dy);
    if (d < inner || d > outer) continue;
    let a = Math.atan2(dy,dx) - ang;
    // -PI..PI ã«æ­£è¦åŒ–
    if (a >  Math.PI) a -= Math.PI*2;
    if (a < -Math.PI) a += Math.PI*2;
    if (Math.abs(a) <= span*0.5){
      e.hp -= dmg;
      e.hitFlash = Math.max(e.hitFlash || 0, 0.12);
      
      // çŸ­ã„ã‚¹ã‚¿ãƒ³è¿½åŠ 
      const base = 0.225; // 0.15 â†’ 0.225ç§’ï¼ˆ1.5å€ï¼‰
      const resist = (e.type==='final') ? 0.3 : 
                     (e.type==='big'||e.type==='mid') ? 0.5 : 
                     1.0;
      e.stun = Math.max(e.stun||0, base * resist);
      
      if (e.hp <= 0){ safeKillEnemy(j); } // å®‰å…¨ãªæ—¢å­˜æ­»äº¡å‡¦ç†
    }
  }
}


  function buildZigPath(x2,y2,segments){
    const x1 = x2; const y1 = -30;
    const pts=[[x1,y1]];
    for(let i=1;i<=segments;i++){
      const t=i/segments;
      const nx = x1 + (x2-x1)*t + rnd(-18,18);
      const ny = y1 + (y2-y1)*t + rnd(-8,18);
      pts.push([nx,ny]);
    }
    return pts;
  }


// ===== ä¸Šé™ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆUå®šç¾©ã®å‰ã«ç½®ãï¼‰=====
const CAPS = {
  speedMax: 340,   // player.speed ä¸Šé™ï¼ˆåˆæœŸ170ã€Ã—1.15^5ï¼‰
  hpMax: 220,      // æœ€å¤§HPä¸Šé™ï¼ˆåˆæœŸ110ã€Ã—1.15^5ï¼‰
  dmgMulMax: 1.5,  // ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡ä¸Šé™ï¼ˆåˆæœŸ1.0ã€Ã—1.08^5ï¼‰
  rateMulMin: 0.60,// æ”»æ’ƒé–“éš”å€ç‡ã®ä¸‹é™ï¼ˆå°ã•ã„ã»ã©é€Ÿã„ã€åˆæœŸ1.0ã€Ã—0.90^5ï¼‰
  sizeMulMax: 2.2  // ã‚µã‚¤ã‚ºå€ç‡ä¸Šé™ï¼ˆåˆæœŸ1.0ï¼‰
};


// ===== Uï¼ˆä¸Šé™ä»˜ãã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰å®šç¾©ï¼‰=====
const U = {
  weaponAdd: (key) => {
    // æ­¦å™¨ã”ã¨ã®èª¬æ˜æ–‡
    const weaponDescs = {
      blaster: 'åŸºæœ¬æ­¦å™¨ã€‚å¼·åŒ–ã§å¼¾æ•°ã‚¢ãƒƒãƒ—ã€‚',
      shotgun: 'è¿‘è·é›¢ã§æ‹¡æ•£å¼¾ã€‚å¯†é›†ã—ãŸæ•µã«æœ‰åŠ¹ã€‚',
      homing: 'æ•µã‚’è‡ªå‹•è¿½å°¾ã€‚ç¢ºå®Ÿã«ãƒ’ãƒƒãƒˆã€‚',
      lightning: 'è¤‡æ•°ã®æ•µã‚’åŒæ™‚æ”»æ’ƒã€‚é€£é–ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
      rock: 'å¤§ããªå²©ã‚’æŠ•ã’ã‚‹ã€‚è²«é€šã—ã¦è¤‡æ•°ãƒ’ãƒƒãƒˆã€‚',
      orbit: 'å‘¨å›²ã‚’å¸¸æ™‚å›è»¢ã€‚æ¥è§¦ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‹æ•µã®å¼¾ã‚’é˜²ãã€‚',
      blade: 'å‰æ–¹åºƒç¯„å›²ã‚’æ–¬æ’ƒã€‚é«˜å¨åŠ›ã®è¿‘æ¥æ”»æ’ƒã€‚',
      ghost: 'å‘¨å›²ã®éœŠä½“ãŒ3æ–¹å‘ã«å°„æ’ƒã€‚',
      poison: 'æ¯’ã®æ²¼ã‚’ç”Ÿæˆã€‚ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‹æ•µã‚’éˆè¶³åŒ–ã€‚',
      nova: 'å‘¨å›²ã®æ•µã«ã‚¹ã‚¿ãƒ³ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚å¼·åŒ–ã§ç¯„å›²æ‹¡å¤§ã€‚',
      rubber: 'ãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘ã«è·³å¼¾ã€‚å£ã§åå°„ã€‚',
      laser: 'æ•µã‚’è²«é€šã™ã‚‹ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ“ãƒ¼ãƒ ã€‚ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§å¨åŠ›ã‚¢ãƒƒãƒ—ã€‚'
    };
    
    return {
      id: `add:${key}`,
      name: `æ–°æ­¦å™¨: ${weapons[key].name}`,
      desc: weaponDescs[key] || 'å…¥æ‰‹ï¼ˆæœ€å¤§Lv3ã¾ã§å¼·åŒ–å¯èƒ½ï¼‰',
      can: () => weapons[key].lv === 0,
      apply: () => { weapons[key].lv = 1; state.owned.add(key); }
    };
  },

  weaponUp: (key) => {
    // æ­¦å™¨å¼·åŒ–æ™‚ã®è©³ç´°èª¬æ˜
    const weaponUpDescs = {
      blaster: 'Lv2ã§2é€£å°„ã€Lv3ã§3é€£å°„ã«å¼·åŒ–ã€‚',
      shotgun: 'å¼¾æ•°ã¨é›†å¼¾ç‡ãŒå‘ä¸Šã€‚',
      homing: 'è¿½å°¾å¼¾ã®æ•°ãŒå¢—åŠ ã€‚',
      lightning: 'åŒæ™‚æ”»æ’ƒæ•°ãŒå¢—åŠ ã€‚Lv3ã§3ä½“åŒæ™‚ã€‚',
      rock: 'ã‚µã‚¤ã‚ºã¨å¨åŠ›ãŒå¤§å¹…ã‚¢ãƒƒãƒ—ã€‚',
      orbit: 'å›è»¢é€Ÿåº¦ã¨å¨åŠ›ãŒå‘ä¸Šã€‚é˜²å¾¡ç¯„å›²ã‚‚æ‹¡å¤§ã€‚',
      blade: 'ç¯„å›²ã¨å¨åŠ›ãŒå¤§å¹…å¼·åŒ–ã€‚',
      ghost: 'éœŠä½“ã®æ•°ãŒå¢—åŠ ã€‚Lv3ã§3ä½“ã€‚',
      poison: 'æ¯’æ²¼ã®ç¯„å›²ã¨æŒç¶šæ™‚é–“ãŒå»¶é•·ã€‚éˆè¶³åŠ¹æœUPã€‚',
      nova: 'ç¯„å›²ãŒå¤§ããæ‹¡å¤§ã€‚ã‚¹ã‚¿ãƒ³æ™‚é–“å»¶é•·ã€‚',
      rubber: 'è·³å¼¾ã®æ•°ãŒå¢—åŠ ã€‚',
      laser: 'å¨åŠ›ã¨å¤ªã•ãŒå¤§å¹…ã‚¢ãƒƒãƒ—ã€‚'
    };
    
    return {
      id: `up:${key}`,
      name: `${weapons[key].name}å¼·åŒ–`,
      desc: weaponUpDescs[key] || 'æ­¦å™¨ãƒ¬ãƒ™ãƒ«+1ï¼ˆæœ€å¤§Lv3ï¼‰',
      can: () => weapons[key].lv > 0 && weapons[key].lv < 3,
      apply: () => { weapons[key].lv++; }
    };
  },

  weaponAwaken: (key) => {
    // è¦šé†’æ™‚ã®ç‰¹åˆ¥åŠ¹æœèª¬æ˜
    const awakenDescs = {
      blaster: 'è¶…é«˜é€Ÿé€£å°„ï¼‹å°„ç¨‹å»¶é•·ï¼',
      shotgun: 'å…¨æ–¹ä½24ç™ºã®å¼¾å¹•è¿½åŠ ï¼',
      homing: 'è¿½å°¾å¼¾ãŒ1.5å€ã«å¢—åŠ ï¼‹çˆ†ç™ºç¯„å›²2å€ï¼',
      lightning: 'åŒæ™‚7ä½“æ”»æ’ƒï¼‹ç™ºå°„é€Ÿåº¦ã‚¢ãƒƒãƒ—ï¼',
      rock: '3æ–¹å‘åŒæ™‚ç™ºå°„ï¼‹ã‚µã‚¤ã‚º2å€ï¼',
      orbit: 'å›è»¢é€Ÿåº¦å€å¢—ï¼‹ç¯„å›²æ‹¡å¤§ï¼å®Œå…¨é˜²å¾¡å£ã«ã€‚',
      blade: 'ç¯„å›²ãƒ»å¨åŠ›ãƒ»é€Ÿåº¦ã™ã¹ã¦å¼·åŒ–ï¼',
      ghost: 'éœŠä½“ãŒ6ä½“ã«å¢—åŠ ï¼‹å°„æ’ƒé€Ÿåº¦ã‚¢ãƒƒãƒ—ï¼',
      poison: 'æ¯’æ²¼ãŒ3æšåŒæ™‚å±•é–‹ï¼åºƒç¯„å›²ã‚’éˆè¶³åœ°å¸¯ã«ã€‚',
      nova: 'å¸¸æ™‚ã‚ªãƒ¼ãƒ©ã§ç¶™ç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ï¼',
      rubber: 'è·³å¼¾8ç™ºï¼‹åå°„å›æ•°25å›ï¼',
      laser: 'é«˜å¨åŠ›ã®æ¥µå¤ªãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼'
    };
    
    return {
      id: `aw:${key}`,
      name: `${weapons[key].name} è¦šé†’`,
      desc: awakenDescs[key] || 'ç‰¹åˆ¥ãªæ€§èƒ½ã‚’è§£æ”¾ï¼',
      can: () => weapons[key].lv === 3 && !weapons[key].awaken,
      apply: () => { weapons[key].awaken = true; }
    };
  },

  // ---- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç³»ï¼ˆä¸Šé™ä»˜ãï¼‰ ----
  speed: {
    id: 'speed+',
    name: 'ç§»å‹•é€Ÿåº¦ã‚¢ãƒƒãƒ—',
    get desc() {
      const current = state.player.speed;
      const max = CAPS.speedMax;
      const pct = Math.floor((current / max) * 100);
      return `+15%ç§»å‹•é€Ÿåº¦ [${Math.floor(current)}/${max}] (${pct}%)`;
    },
    can: () => state.player.speed < CAPS.speedMax - 1,
    apply: () => {
      const before = state.player.speed;
      state.player.speed = Math.min(CAPS.speedMax, state.player.speed * 1.15);
      if (state.player.speed === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  maxhp: {
    id: 'maxhp+',
    name: 'æœ€å¤§HPã‚¢ãƒƒãƒ—',
    get desc() {
      const current = state.player.maxHp;
      const max = CAPS.hpMax;
      const pct = Math.floor((current / max) * 100);
      return `+15%æœ€å¤§HP [${Math.floor(current)}/${max}] (${pct}%)`;
    },
    can: () => state.player.maxHp < CAPS.hpMax - 1,
    apply: () => {
      const before = state.player.maxHp;
      state.player.maxHp = Math.min(CAPS.hpMax, Math.round(state.player.maxHp * 1.15));
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + Math.round(state.player.maxHp * 0.15));
      if (state.player.maxHp === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  regen: {
    id: 'regen',
    name: 'è‡ªç„¶å›å¾©',
    desc: () => {
      const lv = state.regenLv || 0;
      if (lv === 0) return 'Lv1: æ¯ç§’ æœ€å¤§HPã®0.4% å›å¾©';
      if (lv === 1) return 'Lv2: æ¯ç§’ æœ€å¤§HPã®0.8% å›å¾©';
      if (lv === 2) return 'Lv3: æ¯ç§’ æœ€å¤§HPã®1.2% å›å¾©';
      return 'æœ€å¤§ãƒ¬ãƒ™ãƒ«';
    },
    can: () => (state.regenLv || 0) < 3,
    apply: () => {
      state.regenLv = (state.regenLv || 0) + 1;
      const lv = state.regenLv;
      addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: `ãƒªã‚¸ã‚§ãƒ Lv${lv}` });
    }
  },

  defense: {
    id: 'defense+',
    name: 'è€ä¹…åŠ›ã‚¢ãƒƒãƒ—',
    desc: () => {
      const lv = state.defenseLv || 0;
      const reduction = lv * 6;
      if (lv === 0) return 'Lv1: å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’6%è»½æ¸›';
      if (lv === 1) return 'Lv2: å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’12%è»½æ¸›ï¼ˆç¾åœ¨6%ï¼‰';
      if (lv === 2) return 'Lv3: å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’18%è»½æ¸›ï¼ˆç¾åœ¨12%ï¼‰';
      if (lv === 3) return 'Lv4: å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’24%è»½æ¸›ï¼ˆç¾åœ¨18%ï¼‰';
      if (lv === 4) return 'Lv5: å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’30%è»½æ¸›ï¼ˆç¾åœ¨24%ï¼‰';
      return 'æœ€å¤§ãƒ¬ãƒ™ãƒ«ï¼ˆ30%è»½æ¸›ï¼‰';
    },
    can: () => (state.defenseLv || 0) < 5,
    apply: () => {
      state.defenseLv = (state.defenseLv || 0) + 1;
      const lv = state.defenseLv;
      state.mods.damageMul = 1 - (lv * 0.06); // 6%ãšã¤è»½æ¸›
      addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: `è€ä¹…åŠ› Lv${lv}` });
    }
  },

  pickup: {
    id: 'pickup+',
    name: 'å¸å¼•ç¯„å›²ã‚¢ãƒƒãƒ—',
    desc: 'çµŒé¨“å€¤å¸å¼•ç¯„å›²ã‚¢ãƒƒãƒ—ï¼ˆLv3ã§å…¨åŸŸï¼‰',
    can: () => state.pickupLv < 3,
    apply: () => { state.pickupLv++; }
  },

  atkRate: {
    id: 'rate+',
    name: 'æ”»æ’ƒé€Ÿåº¦ã‚¢ãƒƒãƒ—',
    get desc() {
      const current = state.mods.rateMul;
      const max = CAPS.rateMulMin;
      const pct = Math.floor((1 - current) / (1 - max) * 100);
      return `ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ -10% [${current.toFixed(2)}â†’${max}] (${pct}%)`;
    },
    can: () => state.mods.rateMul > CAPS.rateMulMin + 1e-6,
    apply: () => {
      state.mods.rateMul = Math.max(CAPS.rateMulMin, state.mods.rateMul * 0.90);
      if (state.mods.rateMul === CAPS.rateMulMin) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'æœ€é€Ÿ!' });
      }
    }
  },

  atkDmg: {
    id: 'dmg+',
    name: 'ä¸ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¢ãƒƒãƒ—',
    get desc() {
      const current = state.mods.dmgMul;
      const max = CAPS.dmgMulMax;
      const pct = Math.floor((current / max) * 100);
      return `ãƒ€ãƒ¡ãƒ¼ã‚¸ +8% [Ã—${current.toFixed(2)}/${max}] (${pct}%)`;
    },
    can: () => state.mods.dmgMul < CAPS.dmgMulMax - 1e-6,
    apply: () => {
      const before = state.mods.dmgMul;
      state.mods.dmgMul = Math.min(CAPS.dmgMulMax, state.mods.dmgMul * 1.08);
      if (state.mods.dmgMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },

  sizeUp: {
    id: 'size+',
    name: 'å¼¾ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—',
    desc: 'å¼¾ãƒ»ç¯„å›² +10%ï¼ˆä¸Šé™ã‚ã‚Šï¼‰',
    can: () => state.mods.sizeMul < CAPS.sizeMulMax - 1e-6,
    apply: () => {
      const before = state.mods.sizeMul;
      state.mods.sizeMul = Math.min(CAPS.sizeMulMax, state.mods.sizeMul * 1.10);
      if (state.mods.sizeMul === before) {
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.1, text: 'ä¸Šé™!' });
      }
    }
  },
  
  doubleItem: {
  id:'doubleItem',
  name:'ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ç‡ï¼’å€',
  desc:'å›å¾©/æ ¸/ç£çŸ³/å®ç®±ãªã©ã®å‡ºç¾ç‡ãŒï¼’å€ã«ãªã‚‹',
  can: ()=> !state.mods.doubleItem,
  apply: ()=> { state.mods.doubleItem = true; }
},
};

// ===== ã“ã“ã‹ã‚‰é¸æŠè‚¢ãƒªã‚¹ãƒˆ =====
const ALL_UPGRADES = [
  U.weaponAdd('shotgun'),   U.weaponUp('shotgun'),   U.weaponAwaken('shotgun'),
  U.weaponAdd('orbit'),     U.weaponUp('orbit'),     U.weaponAwaken('orbit'),
  U.weaponAdd('lightning'), U.weaponUp('lightning'), U.weaponAwaken('lightning'),
  U.weaponAdd('nova'),      U.weaponUp('nova'),      U.weaponAwaken('nova'),
  U.weaponAdd('rock'),      U.weaponUp('rock'),      U.weaponAwaken('rock'),
  U.weaponAdd('homing'),    U.weaponUp('homing'),    U.weaponAwaken('homing'),
  U.weaponAdd('ghost'),     U.weaponUp('ghost'),     U.weaponAwaken('ghost'),
  U.weaponAdd('poison'), U.weaponUp('poison'), U.weaponAwaken('poison'),
    U.weaponAdd('blade'), U.weaponUp('blade'), U.weaponAwaken('blade'),
  U.weaponAdd('rubber'), U.weaponUp('rubber'), U.weaponAwaken('rubber'),
  U.weaponAdd('laser'), U.weaponUp('laser'), U.weaponAwaken('laser'),
  U.weaponUp('blaster'),    U.weaponAwaken('blaster'), // æ—¢å­˜æ­¦å™¨ã®å¼·åŒ–/è¦šé†’
  U.speed, U.maxhp, U.regen, U.defense, U.pickup, U.atkRate, U.atkDmg, U.sizeUp ,U.doubleItem
];

// --- tiny per-frame scheduler (global & safe) ---
if (typeof window.schedule !== 'function') {
  window.schedule = function(fn, delaySec) {
    (state._q || (state._q = [])).push({ fn, t: Math.max(0, delaySec || 0) });
  };
}

// ==== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ====

// å®‰å…¨ã«è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚‹å°ãƒ˜ãƒ«ãƒ‘
// â€» ä»¥ä¸‹ã¯ç¾åœ¨æœªä½¿ç”¨ï¼ˆå°†æ¥ä½¿ã†ã‹ã‚‚ã—ã‚Œãªã„ã®ã§æ®‹ã™ï¼‰
// function hideById(id){ const el=document.getElementById(id); if(el) el.style.display='none'; }
// function showById(id, display='block'){ const el=document.getElementById(id); if(el) el.style.display=display; }


// --- remove legacy HUDs & stub old notifiers ---
{
  const kill = id => { const el = document.getElementById(id); if (el) el.remove(); };
  kill('bossmsg');
  kill('gather');

  // ã‚‚ã—å¤ã„é–¢æ•°ãŒã©ã“ã‹ã§å‘¼ã°ã‚Œã¦ã‚‚ç„¡å®³åŒ–ã—ã¦ãŠã
  window.flashBossMessage ??= function(){};
  window.showStartToast   ??= function(){};
  window.showToast        ??= function(){};
  window.notify           ??= function(){};
}

function loop(now){

  if (state.player && state.player.hp <= 0 && !state.gameover){
    triggerGameOver();
  }
  if (!state.started) { requestAnimationFrame(loop); return; }

  // dt ã¯ã“ã®1å›ã ã‘è¨ˆç®—ã—ã€state.last ã‚‚ã“ã“ã§1å›ã ã‘æ›´æ–°
let dt = Math.min((now - state.last) / 1000, 0.05);
  state.last = now;
  
  // ---- tiny per-frame scheduler (pausable) ----
state._q ||= [];
for (let i = state._q.length - 1; i >= 0; i--) {
  const t = state._q[i];
  if (!state.paused) t.t -= dt;     // ãƒãƒ¼ã‚ºä¸­ã¯é€²ã‚ãªã„
  if (t.t <= 0) { try { t.fn(); } catch (_) {} state._q.splice(i, 1); }
}



try {
// === Debug: Skip to FINAL BOSS (once, unified) ===
if (state._debugSkipToFinal && !state._didSkipFinal){
  // ã„ã£ãŸã‚“æƒé™¤
  if (Array.isArray(state.enemies))      state.enemies.length = 0;
  if (Array.isArray(state.enemyBullets)) state.enemyBullets.length = 0;
  if (Array.isArray(state.items))        state.items.length = 0;

  // 9:58 ã«å¯„ã›ã‚‹ï¼ˆ10:00å‡ºç¾å‰æï¼‰
  const target = 600 - 2;
  const tNow = Math.max(0, Math.floor(state.timeSec || 0));
  if (tNow < target){
    state.timeSec = target;
    if (typeof state.elapsedMs === 'number') state.elapsedMs = target * 1000;
    if (typeof state.elapsed   === 'number') state.elapsed   = target * 1000;
  }

  // ã‚¿ã‚¤ãƒ ãƒœãƒ¼ãƒŠã‚¹ç”¨ã®åˆæœŸåŒ–
  state.bossBonus = 0;
  state._finalBonusAwarded = false;
  state.finalSpawnAt = state.timeSec || 0;

  // â˜…æœ€çµ‚ãƒœã‚¹ã¯æ­£è¦ã®ã‚¹ãƒãƒ¼ãƒ³é–¢æ•°ã§å‡ºã™
  if (typeof spawnFinalBoss === 'function') spawnFinalBoss();
  state.finalSpawned = true; // â˜…ã“ã‚ŒãŒãªã„ã¨2ä½“å‡ºã‚‹ï¼

  state.paused = false;
  state._didSkipFinal = true;
}



// === GameOverã¯å®Œå…¨åœæ­¢ï¼ˆæç”»ã ã‘ã—ã¦æŠœã‘ã‚‹ï¼‰
if (state.gameover){
  draw();
  requestAnimationFrame(loop);
  return;
}

// åˆæˆ pause ã‚’å…ˆã«åæ˜ ï¼ˆæ‰‹å‹•ãƒãƒ¼ã‚ºï¼ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼å®ç®±ï¼ã‚¹ã‚¿ãƒ¼ãƒˆãƒœãƒ¼ãƒŠã‚¹ï¼ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼‰
const lvlOpen   = (levelupEl && levelupEl.style.display === 'flex');
const chestOpen = (chestEl  && chestEl.style.display  === 'flex');
const startBonusOpen = !!document.getElementById('startBonusModal');
const pauseMenuOpen = !!document.getElementById('pauseMenuModal');
state.paused = !!(lvlOpen || chestOpen || startBonusOpen || pauseMenuOpen || state.manualPaused);

// ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤/æ‰‹å‹•ã„ãšã‚Œã‹ã§åœæ­¢ã—ã¦ã„ãŸã‚‰ã“ã“ã§æŠœã‘ã‚‹
if (state.paused){
  draw();
  requestAnimationFrame(loop);
  return;
}


// === GameOverã¯å®Œå…¨åœæ­¢ï¼ˆæç”»ã ã‘ã—ã¦æŠœã‘ã‚‹ï¼‰
if (state.gameover){
  draw(); requestAnimationFrame(loop); return;
}

if (state.paused){
  draw(); requestAnimationFrame(loop); return;
}

    state.t += dt; 
    state.timeSec += dt;
    const B = worldBounds(); // ãã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿéš›ã«è¦‹ãˆã¦ã„ã‚‹ãƒ¯ãƒ¼ãƒ«ãƒ‰å¢ƒç•Œ

    
    // Final Boss spawn
    if (!state.finalSpawned && state.timeSec >= 600) {
      spawnFinalBoss();
      state.finalSpawned = true;
    }
    
    state.difficulty = 1 + Math.floor(state.timeSec/20);

    // Boss timers
    if(state.player.level>=3){
      state.bossTimer -= dt; 
      state.bigBossTimer -= dt;
      if(state.bossTimer<=0){
        spawnMidBoss();
        state.bossTimer = (state.timeSec>=360 ? 40 + Math.random()*15 : 60 + Math.random()*20);
      }
      if(state.bigBossTimer<=0){
        spawnBigBoss();
        state.bigBossTimer = (state.timeSec>=360 ? 100 + Math.random()*25 : 140 + Math.random()*30);
      }
    }

// === movement inputï¼ˆæµ®éŠã‚¹ãƒ†ã‚£ãƒƒã‚¯æœ€å„ªå…ˆ â†’ ãªã‘ã‚Œã°ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰/æ—¢å­˜å…¥åŠ›ï¼‰ ===
let vx = 0, vy = 0;

if (state.touchJoy && state.touchJoy.active) {
  // ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯
  vx = state.touchJoy.dx;
  vy = state.touchJoy.dy;
} else {
  // æ—¢å­˜ã®å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå›ºå®šã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãŒç„¡ãã¦ã‚‚0æ‰±ã„ï¼‰
  if (state.input) {
    if (typeof state.input.vx === 'number') vx += state.input.vx;
    if (typeof state.input.vy === 'number') vy += state.input.vy;
  }
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
  if (typeof keyboardVec === 'function') {
    const kv = keyboardVec(); vx += kv.x; vy += kv.y;
  }
}

// æ­£è¦åŒ– & æœ€çµ‚å‘ã
const pm = Math.hypot(vx, vy) || 0;
if (pm > 0) { vx /= pm; vy /= pm; state.input.lastDir = { x:vx, y:vy }; }

// â˜… é€²è¡Œæ–¹å‘ã‚’è§’åº¦ã§ä¿æŒï¼ˆç§»å‹•ä¸­ã®ã¿æ›´æ–°ï¼‰
if (state.player && pm > 0) {
  state.player.aimAngle = Math.atan2(vy, vx);  // -Ï€..Ï€
}



    // regen (3ãƒ¬ãƒ™ãƒ«åˆ¶)
    if (state.regenLv > 0) {
      const lv = state.regenLv;
      let healRate = 0;
      if (lv === 1) healRate = 0.004;      // Lv1: 0.4%/sec (å…ƒã®åŠåˆ†)
      else if (lv === 2) healRate = 0.008; // Lv2: 0.8%/sec (å…ƒã¨åŒã˜)
      else if (lv === 3) healRate = 0.012; // Lv3: 1.2%/sec (å…ƒã®1.5å€)
      
      const healPerSec = state.player.maxHp * healRate;
      state.player.hp = Math.min(state.player.maxHp, state.player.hp + healPerSec * dt);
    }

    // move player
{
  const b = worldBounds(state.player.r);
  let newX = state.player.x + vx*state.player.speed*dt;
  let newY = state.player.y + vy*state.player.speed*dt;
  
  // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®š
  const playerRadius = state.player.r;
  for (const obs of state.obstacles) {
    const halfSize = obs.size / 2;
    
    // å††ã¨å››è§’ã®è¡çªåˆ¤å®šï¼ˆAABBï¼‰
    const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
    const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
    
    const distX = newX - closestX;
    const distY = newY - closestY;
    const distSq = distX * distX + distY * distY;
    
    if (distSq < playerRadius * playerRadius) {
      // è¡çªã—ã¦ã„ã‚‹å ´åˆã€æŠ¼ã—æˆ»ã™
      const dist = Math.sqrt(distSq);
      if (dist > 0) {
        const pushX = (distX / dist) * (playerRadius - dist);
        const pushY = (distY / dist) * (playerRadius - dist);
        newX += pushX;
        newY += pushY;
      }
    }
  }
  
  state.player.x = clamp(newX, b.minX, b.maxX);
  state.player.y = clamp(newY, b.minY, b.maxY);
}

    // invincible timer
    if (state.player.iTime > 0) {
      state.player.iTime = Math.max(0, state.player.iTime - dt);
    }

    // knockback
    if (Math.abs(state.player.kbx) + Math.abs(state.player.kby) > 0.1) {
{
  const b = worldBounds(state.player.r);
  state.player.x = clamp(state.player.x + state.player.kbx * dt, b.minX, b.maxX);
  state.player.y = clamp(state.player.y + state.player.kby * dt, b.minY, b.maxY);
}
      const drag = 8.0;
      state.player.kbx += -state.player.kbx * drag * dt;
      state.player.kby += -state.player.kby * drag * dt;
    } else {
      state.player.kbx = state.player.kby = 0;
    }

// spawn enemies
state.spawnTimer -= dt;

// åºç›¤ã¯ã‚†ã£ãã‚Šã€ã ã‚“ã ã‚“çŸ­ãã€‚ä¸‹é™ã¯0.38s
let spawnRate = Math.max(0.38, 1.20 - state.timeSec * 0.004);
// å¾ŒåŠ(6åˆ†ã€œ)ã¯å°‘ã—åŠ é€Ÿ
if (state.timeSec >= 360) spawnRate = Math.max(0.34, spawnRate * 0.85);
// ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ã§ã¯æ•µã®æ•°ã‚’1.5å€ï¼ˆç”Ÿæˆé–“éš”ã‚’2/3ã«çŸ­ç¸®ï¼‰
if (state.mode.hardcore) spawnRate *= 0.67;

if (state.spawnTimer <= 0) {
  // ã„ã¾ã®é›‘é­šæ•°ã¨ä¸Šé™
  const cap   = currentTrashCap(state.timeSec);
  const alive = countTrash();
  const room  = Math.max(0, cap - alive);

  if (room > 0) {
    // ãƒãƒƒãƒæ•°ã¯ç·©ã‚„ã‹ã«å¢—ãˆã‚‹ï¼ˆæœ€å¤§3ä½“/ã‚µã‚¤ã‚¯ãƒ«ï¼‰
    // 0ã€œ220s: 1ä½“, 220ã€œ440s: 2ä½“, 440sã€œ: 3ä½“
    const batchBase = 1 + Math.min(2, Math.floor(state.timeSec / 220));
    const batch = Math.min(batchBase, room); // ä¸Šé™ã¾ã§ã«æŠ‘ãˆã‚‹

    for (let n = 0; n < batch; n++) spawnEnemy();
  }

  state.spawnTimer = spawnRate;
  spawnItemRandom();
}

    // weapons update
    for(const k in state.weapons){ state.weapons[k].update(dt); }

// === ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ ===
for(let i=state.bullets.length-1;i>=0;i--){
  const b=state.bullets[i];
  
  // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ã¯æ•µã‚’è¿½å°¾ï¼ˆéšœå®³ç‰©å›é¿ä»˜ãï¼‰
  if(b.type==='homing'){
    const t = nearestEnemy(b.x,b.y);
    if(t){
      let targetX = t.x;
      let targetY = t.y;
      
      // éšœå®³ç‰©ã¨ã®äº¤å·®ãƒã‚§ãƒƒã‚¯
      let needAvoid = false;
      let avoidDir = { x: 0, y: 0 };
      
      for (const obs of state.obstacles) {
        const halfSize = obs.size / 2;
        const toObsX = obs.x - b.x;
        const toObsY = obs.y - b.y;
        const distToObs = Math.hypot(toObsX, toObsY);
        
        // éšœå®³ç‰©ãŒè¿‘ã„ï¼ˆ100pxä»¥å†…ï¼‰ã‹ã¤é€²è·¯ä¸Šã«ã‚ã‚‹å ´åˆ
        if (distToObs < 100) {
          const toTargetX = targetX - b.x;
          const toTargetY = targetY - b.y;
          const toTargetLen = Math.hypot(toTargetX, toTargetY) || 1;
          
          // é€²è¡Œæ–¹å‘ã®æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«
          const dirX = toTargetX / toTargetLen;
          const dirY = toTargetY / toTargetLen;
          
          // éšœå®³ç‰©ã¸ã®æ–¹å‘ã¨ã®å†…ç©
          const dot = (toObsX * dirX + toObsY * dirY);
          
          // é€²è·¯ä¸Šã«ã‚ã‚‹å ´åˆï¼ˆå†…ç©ãŒæ­£ã§è·é›¢ãŒè¿‘ã„ï¼‰
          if (dot > 0 && distToObs < 80) {
            needAvoid = true;
            
            // éšœå®³ç‰©ã‚’é¿ã‘ã‚‹æ–¹å‘ï¼ˆæ³•ç·šã®å‚ç›´æ–¹å‘ï¼‰
            const perpX = -toObsY / distToObs;
            const perpY = toObsX / distToObs;
            
            // ã©ã¡ã‚‰ã«é¿ã‘ã‚‹ã‹ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¿‘ã„æ–¹å‘ï¼‰
            const checkX1 = b.x + perpX * 50;
            const checkY1 = b.y + perpY * 50;
            const checkX2 = b.x - perpX * 50;
            const checkY2 = b.y - perpY * 50;
            
            const dist1 = Math.hypot(targetX - checkX1, targetY - checkY1);
            const dist2 = Math.hypot(targetX - checkX2, targetY - checkY2);
            
            if (dist1 < dist2) {
              avoidDir.x = perpX;
              avoidDir.y = perpY;
            } else {
              avoidDir.x = -perpX;
              avoidDir.y = -perpY;
            }
            break;
          }
        }
      }
      
      // å›é¿æ–¹å‘ã¨è¿½å°¾æ–¹å‘ã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰
      if (needAvoid) {
        const dx = avoidDir.x * 0.7 + (targetX - b.x) * 0.3;
        const dy = avoidDir.y * 0.7 + (targetY - b.y) * 0.3;
        targetX = b.x + dx * 10;
        targetY = b.y + dy * 10;
      }
      
      const dx = targetX - b.x;
      const dy = targetY - b.y;
      const ang = Math.atan2(dy, dx);
      const speed = Math.hypot(b.vx,b.vy);
      const cur = Math.atan2(b.vy,b.vx);
      const diff = ((ang-cur+Math.PI*3)%(Math.PI*2))-Math.PI;
      const maxTurn = b.turn * dt;
      const newAng = cur + clamp(diff, -maxTurn, maxTurn);
      b.vx = Math.cos(newAng)* speed;
      b.vy = Math.sin(newAng)* speed;
    }
  }

  // ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆ: å£åå°„
  if(b.type==='rubber'){
    const margin = 20;
    let bounced = false;
    
    if(b.x < B.minX + margin || b.x > B.maxX - margin){
      b.vx = -b.vx;
      b.x = clamp(b.x, B.minX + margin, B.maxX - margin);
      bounced = true;
    }
    if(b.y < B.minY + margin || b.y > B.maxY - margin){
      b.vy = -b.vy;
      b.y = clamp(b.y, B.minY + margin, B.maxY - margin);
      bounced = true;
    }
    
    if(bounced){
      b.bounces = (b.bounces || 0) + 1;
      if(b.bounces >= b.maxBounces){
        state.bullets.splice(i, 1);
        continue;
      }
    }
  }

if (b.type === 'rock') {
  const spinRate = 1.4;     // â˜… è‡ªè»¢é€Ÿåº¦(rad/ç§’)ã€‚ã‚†ã£ãã‚Š=0.8ã€œ1.6ã€é€Ÿã‚=3ã€œ6
  b.spin += spinRate * dt;
}

  // ç§»å‹•ã¨å¯¿å‘½å‡¦ç†
  b.x += b.vx*dt; b.y += b.vy*dt; b.life -= dt;
  
  // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®šï¼ˆç‰©ç†å¼¾ã®ã¿ï¼‰
  const physicalBullets = ['bullet', 'rubber', 'rock', 'poison', 'homing', 'ghost'];
  if (physicalBullets.includes(b.type)) {
    for (const obs of state.obstacles) {
      const halfSize = obs.size / 2;
      const closestX = clamp(b.x, obs.x - halfSize, obs.x + halfSize);
      const closestY = clamp(b.y, obs.y - halfSize, obs.y + halfSize);
      const distX = b.x - closestX;
      const distY = b.y - closestY;
      const distSq = distX * distX + distY * distY;
      
      if (distSq < b.r * b.r) {
        // éšœå®³ç‰©ã«å½“ãŸã£ãŸ
        if (b.type === 'homing') {
          // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ã¯å£ã«æ²¿ã£ã¦è¿‚å›
          const dist = Math.sqrt(distSq) || 1;
          const nx = distX / dist;
          const ny = distY / dist;
          
          // æ³•ç·šæ–¹å‘ã«æŠ¼ã—å‡ºã™
          const overlap = b.r - dist;
          b.x += nx * (overlap + 2);
          b.y += ny * (overlap + 2);
          
          // é€Ÿåº¦ã‚’å£ã«æ²¿ã†æ–¹å‘ã«å¤‰æ›´
          const speed = Math.hypot(b.vx, b.vy);
          const dot = b.vx * nx + b.vy * ny;
          
          // å£ã«æ²¿ã†æˆåˆ†ã‚’æ®‹ã™
          let slideX = b.vx - dot * nx;
          let slideY = b.vy - dot * ny;
          const slideLen = Math.hypot(slideX, slideY) || 1;
          
          // é€Ÿåº¦ã‚’ç¶­æŒã—ã¦å£ã«æ²¿ã†æ–¹å‘ã¸
          b.vx = (slideX / slideLen) * speed;
          b.vy = (slideY / slideLen) * speed;
          
        } else if (b.type === 'rubber') {
          // ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆã¯éšœå®³ç‰©ã§ã‚‚åå°„
          const dx = b.x - obs.x;
          const dy = b.y - obs.y;
          const len = Math.hypot(dx, dy) || 1;
          const nx = dx / len;
          const ny = dy / len;
          
          const dot = b.vx * nx + b.vy * ny;
          b.vx = b.vx - 2 * dot * nx;
          b.vy = b.vy - 2 * dot * ny;
          
          // éšœå®³ç‰©ã‹ã‚‰æŠ¼ã—å‡ºã™
          const overlap = b.r - Math.sqrt(distSq);
          b.x += nx * overlap;
          b.y += ny * overlap;
          
          b.bounces = (b.bounces || 0) + 1;
          if(b.bounces >= b.maxBounces){
            state.bullets.splice(i, 1);
            continue;
          }
        } else {
          // ãã®ä»–ã®ç‰©ç†å¼¾ã¯æ¶ˆæ»…
          state.bullets.splice(i, 1);
          continue;
        }
        break;
      }
    }
  }
  
 if (
  b.x < B.minX - 60 || b.x > B.maxX + 60 ||
  b.y < B.minY - 60 || b.y > B.maxY + 60 ||
  b.life <= 0
){
  state.bullets.splice(i,1);
  continue;
}

// â˜…ãƒ©ã‚¹ãƒœã‚¹ã®ã‚·ãƒ¼ãƒ«ãƒ‰ä¸‰è§’ã¨ã®è¡çªåˆ¤å®š
let hitShield = false;
for(const e of state.enemies){
  if(e.type === 'final' && e.isTriangle && e.shieldCount > 0){
    for(let k = 0; k < e.shieldCount; k++){
      const shieldAng = e.shieldAngle + (k * Math.PI * 2 / e.shieldCount);
      const shieldX = e.x + Math.cos(shieldAng) * e.shieldRadius;
      const shieldY = e.y + Math.sin(shieldAng) * e.shieldRadius;
      const shieldSize = 28;
      
      const dx = b.x - shieldX;
      const dy = b.y - shieldY;
      if(dx*dx + dy*dy < (b.r + shieldSize) * (b.r + shieldSize)){
        hitShield = true;
        // åå°„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        spark(b.x, b.y, 4);
        break;
      }
    }
    if(hitShield) break;
  }
}
if(hitShield){
  state.bullets.splice(i, 1);
  continue;
}


 // æ•µã¨ã®å½“ãŸã‚Šåˆ¤å®š
let rockHitThisFrame = false; // rock ã¯è¤‡æ•°ä½“ã«å½“ã¦ã‚‹ãŸã‚ã®ãƒ•ãƒ©ã‚°
for(let j=state.enemies.length-1;j>=0;j--){
  const e=state.enemies[j];
  const r = (e.type==='big'? e.size*0.55
           : e.type==='mid'? e.size*0.6
           : e.type==='minion'? e.size*0.7
           : e.size*0.7);

  if(dist2(b.x,b.y,e.x,e.y) < (b.r + r)**2){
    // ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯å¼¾ã‚’å¼¾ã
    if(e.type === 'spinner' && e.spinPhase === 'highspin'){
      // åå°„æ–¹å‘ã‚’è¨ˆç®—
      const dx = b.x - e.x;
      const dy = b.y - e.y;
      const len = Math.hypot(dx, dy) || 1;
      const nx = dx / len;
      const ny = dy / len;
      
      // å¼¾ã®é€Ÿåº¦ã‚’åå°„
      const dot = b.vx * nx + b.vy * ny;
      b.vx = b.vx - 2 * dot * nx;
      b.vy = b.vy - 2 * dot * ny;
      
      // å¼¾ã‚’å°‘ã—å¤–ã«æŠ¼ã—å‡ºã™
      b.x = e.x + nx * (r + b.r + 2);
      b.y = e.y + ny * (r + b.r + 2);
      
      // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      addEffect('spark', { x: b.x, y: b.y, life: 0.2 });
      
      continue; // ãƒ€ãƒ¡ãƒ¼ã‚¸ãªã—
    }
    
    // --- ãƒ’ãƒƒãƒˆ ---
    let dmg = b.dmg;
    if(b.type === 'rock'){
      // ãƒœã‚¹ç¨®ã¸ãƒœãƒ¼ãƒŠã‚¹
      if (e.type==='mid' || e.type==='big' || e.type==='final') {
        dmg *= (b.bossMul || 1.0);
      }
    }
    
    // ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ã¯ç„¡æ•µï¼ˆå¼¾ãŒå½“ãŸã£ã¦ã‚‚ç„¡è¦–ï¼‰
    // â˜…å›è»¢çªé€²ä¸­ã®ãƒ©ã‚¹ãƒœã‚¹ã‚‚ç„¡æ•µ
    if(e.invincible || e.chargeInvincible){
      continue;
    }
    
    e.hp -= dmg;
    e.hitFlash = Math.max(e.hitFlash, 0.12);
    
// â˜… å³æ­»ãƒã‚§ãƒƒã‚¯ï¼šãƒ’ãƒƒãƒˆç›´å¾Œã«ç¢ºå®šãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆfinalã¯æ—¢å­˜ãƒ«ãƒ¼ãƒˆã«ä»»ã›ã‚‹ï¼‰
if (e.hp <= 0) {
  if (e.type === 'final') {
    // ãƒ©ã‚¹ãƒœã‚¹ã¯å¾“æ¥ã®å‡¦ç†ã«ä»»ã›ã‚‹ï¼ˆæ¼”å‡ºã‚„é·ç§»ãŒã‚ã‚‹ãŸã‚ï¼‰
  } else if (e.type === 'mid' || e.type === 'big') {
    // ä¸­/å¤§å‹ãƒœã‚¹ã¯å®ç®±ãƒ‰ãƒ­ãƒƒãƒ—
    if (e.type === 'big') {
      // bigï¼ˆå¤§å‹ãƒœã‚¹ï¼‰
      const pos = adjustDropPosition(e.x, e.y, 16);
      state.items.push({ kind:'chest', x: pos.x, y: pos.y, r: 16, t: 0, picks: 2 });
    } else {
      // midï¼ˆä¸­ãƒœã‚¹ï¼‰
      const pos = adjustDropPosition(e.x, e.y, 14);
      state.items.push({ kind:'chest', x: pos.x, y: pos.y, r: 14, t: 0, picks: 1 });
    }
    if (typeof addEffect === 'function') addEffect('pop', {x:e.x, y:e.y});
    state.killScore = (state.killScore||0) + 1;
    state.enemies.splice(j, 1);
    break;
  } else {
    // é€šå¸¸ã‚¶ã‚³ã¯å®‰å…¨å³æ­»é–¢æ•°ã«å¯„ã›ã‚‹ï¼ˆXPãƒ‰ãƒ­ãƒƒãƒ—ä¿è¨¼ï¼‰
    if (typeof safeKillEnemy === 'function') {
      safeKillEnemy(j);
    } else if (typeof dropGem === 'function') {
      dropGem(e.x, e.y, 1);
      state.enemies.splice(j, 1);
    } else {
      (state.gems||(state.gems=[])).push({x:e.x, y:e.y, r:6, val:1});
      state.enemies.splice(j, 1);
    }
    state.killScore = (state.killScore||0) + 1;
    break;
  }
}

    
    spark(b.x,b.y, b.type==='rock'? 5 : 4);

    if(b.type==='rubber'){
      // ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆ: æ•µã§åå°„
      const dx = e.x - b.x;
      const dy = e.y - b.y;
      const len = Math.hypot(dx, dy) || 1;
      const nx = dx / len;
      const ny = dy / len;
      
      // åå°„ãƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—
      const dot = b.vx * nx + b.vy * ny;
      b.vx = b.vx - 2 * dot * nx;
      b.vy = b.vy - 2 * dot * ny;
      
      b.bounces = (b.bounces || 0) + 1;
      if(b.bounces >= b.maxBounces){
        state.bullets.splice(i, 1);
      }
      break; // æ¬¡ã®æ•µã¸
      
    } else if(b.type==='homing'){
      const R = (b.boomR || 60) * state.mods.sizeMul; // boomRã‚’ä½¿ç”¨
      addEffect('nova',{x:b.x,y:b.y,r:R, life:.26});
      for(const e2 of state.enemies){
        const d = Math.hypot(e2.x-b.x, e2.y-b.y);
        const dmgMul = b.boomMul || 1.0;
        if(d<R) { e2.hp -= b.dmg * dmgMul; e2.hitFlash = Math.max(e2.hitFlash, 0.12); }
      }
      state.bullets.splice(i,1);
      break; // homing ã¯æ¶ˆæ»…

    } else if(b.type==='bullet'){
      state.bullets.splice(i,1);
      break; // é€šå¸¸å¼¾ã¯1ä½“ã§çµ‚äº†

    } else if(b.type==='ghost'){
      if(b.pierce > 0){ b.pierce--; } else { state.bullets.splice(i,1); }
      break; // ã‚´ãƒ¼ã‚¹ãƒˆã‚‚1ä½“ã§æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã¸

      } else if (b.type === 'slash') {
        // æ–¬æ’ƒï¼šå¯¿å‘½ã§æ¶ˆãˆã‚‹ã€‚1ä½“ã«ã¤ã1å›ã ã‘ãƒ€ãƒ¡ãƒ¼ã‚¸
        if (!b._hit) b._hit = new Set();
        if (!b._hit.has(e)) {
          e.hp -= b.dmg;
          e.hitFlash = Math.max(e.hitFlash||0, 0.12);

          // ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—ã¯å‰Šé™¤ï¼ˆãƒãƒƒã‚¯ãƒãƒƒã‚¯ã«è¦‹ãˆã‚‹ãŸã‚ï¼‰

          b._hit.add(e);
          // ï¼ˆæ–¬æ’ƒã¯è²«é€šæ‰±ã„ãªã®ã§å¼¾ã¯æ¶ˆã•ãªã„ï¼‰
if (e.hp <= 0) {
  safeKillEnemy(j);
}
        }


    } else if(b.type==='rock'){
      // rock ã¯æ¶ˆã•ãšã«æ¬¡ã®æ•µåˆ¤å®šã‚‚ç¶šè¡Œï¼ˆåŒãƒ•ãƒ¬ãƒ¼ãƒ ã§è¤‡æ•°ä½“ã«å½“ãŸã‚‹ï¼‰
      rockHitThisFrame = true;
      // break ã—ãªã„
    }
  }
}
// rock ã§ã‚‚ç”»é¢å¤–/å¯¿å‘½ã§ã¯é€šå¸¸é€šã‚Šæ¶ˆãˆã‚‹ï¼ˆæ—¢å­˜å‡¦ç†ã®ã¾ã¾ï¼‰

// === Orbit contact damage (no knockback) ===
if (state.weapons.orbit.lv > 0){
  const w = state.weapons.orbit;
  const count = w.awaken ? 8 : (3 + w.lv);
  const ring = w.baseR + 14*(w.lv-1) + (w.awaken? 12:0);
  const orbR = (w.hitRBase + (w.awaken? 4:0)) * state.mods.sizeMul; // å½“ãŸã‚ŠåŠå¾„
  const dps = (w.dpsBase + 4*(w.lv-1)) * (w.awaken? 1.4:1.0) * state.mods.dmgMul;

  for (const e of state.enemies){
    // â˜…ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯ç„¡åŠ¹
    if(e.type === 'spinner' && e.spinPhase === 'highspin') continue;
    
    for (let k=0; k<count; k++){
      const ang = w.ang + k*(Math.PI*2/count);
      const ox = state.player.x + Math.cos(ang)*ring;
      const oy = state.player.y + Math.sin(ang)*ring;
      const dx = e.x - ox, dy = e.y - oy;
      if (dx*dx + dy*dy <= orbR*orbR){
        // æ¥è§¦DPSï¼ˆãƒãƒƒã‚¯ãƒãƒƒã‚¯ãªã—ï¼‰
        e.hp -= dps * dt;
        e.hitFlash = Math.max(e.hitFlash, 0.05);
      }
    }
  }
}
}


// === æ•µå¼¾ ===
for (let i = state.enemyBullets.length - 1; i >= 0; i--) {
  const b = state.enemyBullets[i];

  // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã®è¿½å°¾å‡¦ç†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç”Ÿãã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
  if(b.type === 'homing' && state.player && state.player.hp > 0){
    const dx = state.player.x - b.x;
    const dy = state.player.y - b.y;
    const targetAngle = Math.atan2(dy, dx);
    const currentAngle = Math.atan2(b.vy, b.vx);
    
    // è§’åº¦å·®ã‚’è¨ˆç®—ï¼ˆ-PI ~ PIï¼‰
    let angleDiff = targetAngle - currentAngle;
    while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    
    // å¾ã€…ã«å‘ãã‚’å¤‰ãˆã‚‹
    const turnRate = (b.turnSpeed || 2.5) * dt;
    const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);
    
    const speed = Math.hypot(b.vx, b.vy);
    b.vx = Math.cos(newAngle) * speed;
    b.vy = Math.sin(newAngle) * speed;
  }
  
  // â˜…ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒï¼ˆãƒ©ã‚¹ãƒœã‚¹ç”¨ï¼‰ã®è¿½å°¾å‡¦ç†
  if(b.type === 'homingOrb' && state.player && state.player.hp > 0){
    const dx = state.player.x - b.x;
    const dy = state.player.y - b.y;
    const targetAngle = Math.atan2(dy, dx);
    const currentAngle = Math.atan2(b.vy, b.vx);
    
    let angleDiff = targetAngle - currentAngle;
    while(angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while(angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    
    // ã‚†ã£ãã‚Šæ›²ãŒã‚‹
    const turnRate = 1.2 * dt;
    const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);
    
    b.vx = Math.cos(newAngle) * b.speed;
    b.vy = Math.sin(newAngle) * b.speed;
  }

  // ä½ç½®æ›´æ–°
  b.x += b.vx * dt;
  b.y += b.vy * dt;
  b.life -= dt;
  
  // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®šï¼ˆæ•µã®å¼¾ã¯å…¨ã¦ç‰©ç†å¼¾ã¨ã—ã¦æ‰±ã†ï¼‰
  let hitObstacle = false;
  for (const obs of state.obstacles) {
    const halfSize = obs.size / 2;
    const closestX = clamp(b.x, obs.x - halfSize, obs.x + halfSize);
    const closestY = clamp(b.y, obs.y - halfSize, obs.y + halfSize);
    const distX = b.x - closestX;
    const distY = b.y - closestY;
    const distSq = distX * distX + distY * distY;
    
    if (distSq < b.r * b.r) {
      // miniTriangleã¨reflectLaserã¯åå°„ã™ã‚‹
      if((b.type === 'miniTriangle' || b.type === 'reflectLaser') && b.bounces < b.maxBounces){
        const dist = Math.sqrt(distSq) || 1;
        const nx = distX / dist;
        const ny = distY / dist;
        const dot = b.vx * nx + b.vy * ny;
        b.vx = b.vx - 2 * dot * nx;
        b.vy = b.vy - 2 * dot * ny;
        b.x = closestX + nx * (b.r + 2);
        b.y = closestY + ny * (b.r + 2);
        b.rotation = Math.atan2(b.vy, b.vx);
        b.bounces++;
      } else if(b.type === 'ghostBullet' || b.type === 'homingOrb'){
        // ã‚´ãƒ¼ã‚¹ãƒˆå¼¾ã¨ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒã¯å£ã‚’è²«é€š
      } else {
        hitObstacle = true;
      }
      break;
    }
  }
  
  if (hitObstacle) {
    state.enemyBullets.splice(i, 1);
    continue;
  }

  // ç”»é¢å¤–ãƒ»å¯¿å‘½åˆ‡ã‚Œ â†’ é™¤å»
  if (
    b.life <= 0 ||
    b.x < B.minX - 40 || b.x > B.maxX + 40 ||
    b.y < B.minY - 40 || b.y > B.maxY + 40
  ) {
    state.enemyBullets.splice(i, 1);
    continue;
  }

  // Orbit ãŒå¼¾ã‚’ç›¸æ®ºï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯é™¤ãï¼‰
  let canceled = false;
  // â˜…ignoreOrbitãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å¼¾ã¯ã‚ªãƒ¼ãƒ“ãƒƒãƒˆã§æ¶ˆãˆãªã„
  if (b.type !== 'laser' && !b.ignoreOrbit && state.weapons.orbit.lv > 0) {
    const count = state.weapons.orbit.awaken ? 8 : (3 + state.weapons.orbit.lv);
    for (let k = 0; k < count && !canceled; k++) {
      const ang = state.weapons.orbit.ang + k * (Math.PI * 2 / count);
      const rad = state.weapons.orbit.baseR + 14 * (state.weapons.orbit.lv - 1) + (state.weapons.orbit.awaken ? 12 : 0);
      const ox = state.player.x + Math.cos(ang) * rad;
      const oy = state.player.y + Math.sin(ang) * rad;
      const or = (state.weapons.orbit.awaken ? 18 : 14) * state.mods.sizeMul;
      if (dist2(b.x, b.y, ox, oy) < (b.r + or) ** 2) {
        state.enemyBullets.splice(i, 1);
        spark(b.x, b.y, 8);
        canceled = true;
      }
    }
    if (canceled) continue;
  }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘½ä¸­
  if(b.type === 'laser'){
    // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ã¯é•·æ–¹å½¢ã®å½“ãŸã‚Šåˆ¤å®š
    const length = Math.abs(b.vx || 0);
    const thick = (b.r || 8) * 2;
    const lx = b.vx > 0 ? b.x : b.x - length;
    
    if(state.player.x >= lx - state.player.r && 
       state.player.x <= lx + length + state.player.r &&
       state.player.y >= b.y - thick/2 - state.player.r &&
       state.player.y <= b.y + thick/2 + state.player.r){
      playerHit(b.dmg, b.x, b.y);
      spark(b.x, b.y, 12);
      if (state.player.hp <= 0 && !state.gameover) {
        triggerGameOver();
        break;
      }
    }
  } else if (dist2(b.x, b.y, state.player.x, state.player.y) < (b.r + state.player.r) ** 2) {
    state.enemyBullets.splice(i, 1);
    playerHit(b.dmg, b.x, b.y);
    spark(b.x, b.y, 6);
    if (state.player.hp <= 0 && !state.gameover) {
      triggerGameOver();
      break; // ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ®‹ã‚Šå¼¾å‡¦ç†ã‚’çµ‚äº†
    }
  }
}


    // === æ•µãƒ»ãƒœã‚¹ ===
    for(let i=state.enemies.length-1;i>=0;i--){
      const e=state.enemies[i];
      e.hitFlash = Math.max(0, e.hitFlash - dt*2.5);
      
      // æ•µãƒãƒƒã‚¯ãƒãƒƒã‚¯é€Ÿåº¦ã®é©ç”¨ï¼ˆæ¸›è¡°ã¤ãï¼‰
if (e.kbx || e.kby){
  e.x += e.kbx * dt;
  e.y += e.kby * dt;
  const drag = 6.0;
  e.kbx += -e.kbx * drag * dt;
  e.kby += -e.kby * drag * dt;
  if (Math.abs(e.kbx) + Math.abs(e.kby) < 1){
    e.kbx = 0; e.kby = 0;
  }
}
      
// --- ã‚¹ã‚¿ãƒ³æ¸›è¡° ---
e.stun = Math.max(0, (e.stun||0) - dt);

// --- ãƒã‚¤ã‚ºãƒ³æ¸›é€Ÿã®å–å¾—ï¼ˆãã®æ•µãŒâ€œä»Šâ€æ¯’ã«è§¦ã‚Œã¦ã„ã‚‹ãªã‚‰é…ãã™ã‚‹ï¼‰---
let slowMul = 1;                 // 1=ç­‰é€Ÿï¼ˆé…ãã™ã‚‹ã»ã©å°ã•ãï¼‰
const SLOW_IN_FIELD = 0.40;      // 0.55 â†’ 0.40ï¼ˆ60%æ¸›é€Ÿã«å¼·åŒ–ï¼‰
for(const ef of state.effects){
  if(ef.type !== 'poisonField') continue;
  const dx = e.x - ef.x, dy = e.y - ef.y;
  if(dx*dx + dy*dy <= ef.r*ef.r){
    slowMul = Math.min(slowMul, SLOW_IN_FIELD);
    break; // 1æšè¦‹ã¤ã‘ãŸã‚‰ååˆ†ï¼ˆ2æšã§ã‚‚â€œç§»å‹•â€ã¯æœ€å¤§æ¸›é€Ÿã®ã¿ã«ã™ã‚‹ï¼‰
  }
}

// --- ã¾ã¨ã‚ã¦ç§»å‹•å€ç‡ï¼ˆã‚¹ã‚¿ãƒ³ä¸­ã¯ã•ã‚‰ã«é‡ãï¼‰---
const stunMul = (e.stun > 0) ? 0.18 : 1.0;  // ã‚¹ã‚¿ãƒ³ä¸­ã¯18%ã®é€Ÿåº¦ã ã‘å‹•ã‘ã‚‹ï¼å®Ÿè³ªã»ã¼åœæ­¢
const moveMul = slowMul * stunMul;

// --- ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼ˆkbx/kbyï¼‰ã‚’ä½ç½®ã«åæ˜ ï¼†æ¸›è¡° ---
e.kbx = e.kbx || 0;
e.kby = e.kby || 0;
if (Math.abs(e.kbx) + Math.abs(e.kby) > 0.1){
  e.x += e.kbx * dt;
  e.y += e.kby * dt;
  const drag = 7.5;              // ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã®æ¸›è¡°
  e.kbx += -e.kbx * drag * dt;
  e.kby += -e.kby * drag * dt;
} else {
  e.kbx = e.kby = 0;
}

      

  // ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ã®æ•µã®è‡ªå‹•å›å¾©ã¯å‰Šé™¤ï¼ˆé›£æ˜“åº¦èª¿æ•´ï¼‰


      // === ã‚¹ãƒ”ãƒŠãƒ¼ï¼ˆå›è»¢ä¸‰è§’ï¼‰ ===
      if(e.type==='spinner'){
        // ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†
        e.spinTimer += dt;
        
        if(e.spinPhase === 'normal'){
          // é€šå¸¸å›è»¢
          e.rotation += e.rotationSpeed * dt;
          
          if(e.spinTimer >= e.normalDuration){
            // é«˜é€Ÿå›è»¢ã¸
            e.spinPhase = 'highspin';
            e.spinTimer = 0;
          }
        } else {
          // é«˜é€Ÿå›è»¢ï¼ˆç„¡æ•µï¼‹å¼¾ã‚’å¼¾ãï¼‰
          e.rotation += e.highSpinSpeed * dt;
          
          if(e.spinTimer >= e.highSpinDuration){
            // é€šå¸¸å›è»¢ã¸
            e.spinPhase = 'normal';
            e.spinTimer = 0;
          }
        }
        
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        let newX = e.x + Math.cos(a)*e.speed*dt*moveMul;
        let newY = e.y + Math.sin(a)*e.speed*dt*moveMul;
        
        // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®šï¼ˆminion ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
        const enemyRadius = e.size / 2;
        let hitObstacle = false;
        let slideDir = { x: 0, y: 0 };
        
        for (const obs of state.obstacles) {
          const halfSize = obs.size / 2;
          const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
          const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
          const distX = newX - closestX;
          const distY = newY - closestY;
          const distSq = distX * distX + distY * distY;
          
          if (distSq < enemyRadius * enemyRadius) {
            hitObstacle = true;
            const dist = Math.sqrt(distSq) || 1;
            const nx = distX / dist;
            const ny = distY / dist;
            const moveX = Math.cos(a);
            const moveY = Math.sin(a);
            const dot = moveX * nx + moveY * ny;
            slideDir.x = moveX - dot * nx;
            slideDir.y = moveY - dot * ny;
            const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
            slideDir.x /= slideLen;
            slideDir.y /= slideLen;
            break;
          }
        }
        
        if (hitObstacle) {
          e.x += slideDir.x * e.speed * dt * moveMul;
          e.y += slideDir.y * e.speed * dt * moveMul;
        } else {
          e.x = newX;
          e.y = newY;
        }
        
        // â˜…ä½é »åº¦ã§é€šå¸¸å¼¾ã‚’ç™ºå°„
        if(e.shootCd !== undefined){
          e.shootCd -= dt;
          if(e.shootCd <= 0){
            const a = Math.atan2(state.player.y - e.y, state.player.x - e.x);
            state.enemyBullets.push({
              x: e.x, y: e.y,
              vx: Math.cos(a) * 150,
              vy: Math.sin(a) * 150,
              r: 6, dmg: 10, life: 4,
              type: 'normal'
            });
            e.shootCd = e.shootInterval;
          }
        }

      // === ãƒ€ãƒƒã‚·ãƒ£ãƒ¼ï¼ˆçªé€²ä¸‰è§’ï¼‰ ===
      }else if(e.type==='dasher'){
        e.phaseTimer -= dt;
        
        if(e.phase === 'aim'){
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç‹™ã†ï¼ˆå¸¸ã«å‘ãã‚’æ›´æ–°ï¼‰
          const a = Math.atan2(state.player.y - e.y, state.player.x - e.x);
          e.rotation = a + Math.PI / 2;  // å…ˆç«¯ã‚’é€²è¡Œæ–¹å‘ã«å‘ã‘ã‚‹ï¼ˆ+90åº¦ï¼‰
          
          if(e.phaseTimer <= 0){
            // ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹ - ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã‚’è¨˜éŒ²
            e.phase = 'dash';
            e.targetX = state.player.x;
            e.targetY = state.player.y;
            const dx = e.targetX - e.x;
            const dy = e.targetY - e.y;
            const len = Math.hypot(dx, dy) || 1;
            e.dashDir.x = dx / len;
            e.dashDir.y = dy / len;
          }
        }else if(e.phase === 'dash'){
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã¸è¶…é«˜é€Ÿãƒ€ãƒƒã‚·ãƒ¥
          let newX = e.x + e.dashDir.x * e.dashSpeed * dt * moveMul;
          let newY = e.y + e.dashDir.y * e.dashSpeed * dt * moveMul;
          
          // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®š
          let hitObstacle = false;
          const enemyRadius = e.size / 2;
          for (const obs of state.obstacles) {
            const halfSize = obs.size / 2;
            const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
            const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
            const distX = newX - closestX;
            const distY = newY - closestY;
            const distSq = distX * distX + distY * distY;
            
            if (distSq < enemyRadius * enemyRadius) {
              hitObstacle = true;
              break;
            }
          }
          
          if(hitObstacle){
            // å£ã«å½“ãŸã£ãŸã‚‰åœæ­¢
            e.phase = 'stop';
            e.phaseTimer = 1.0;
          } else {
            e.x = newX;
            e.y = newY;
            
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã«åˆ°é”ã—ãŸã‹ç¢ºèª
            const distToTarget = Math.hypot(e.targetX - e.x, e.targetY - e.y);
            if(distToTarget < 20){
              // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åˆ°é”
              e.phase = 'stop';
              e.phaseTimer = 1.0;
            }
          }
        }else if(e.phase === 'stop'){
          // åœæ­¢ä¸­
          if(e.phaseTimer <= 0){
            // å†ã³ç‹™ã†
            e.phase = 'aim';
            e.phaseTimer = 0.8;
          }
        }

      // === ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ï¼ˆç‹™æ’ƒä¸‰è§’ï¼‰ ===
      }else if(e.type==='sniper'){
        e.phaseTimer -= dt;
        
        if(e.phase === 'move'){
          // ç”»é¢å†…ã«ç§»å‹•
          const dx = e.stopX - e.x;
          const dy = e.stopY - e.y;
          const dist = Math.hypot(dx, dy);
          
          if(dist < 5){
            // åœæ­¢ä½ç½®ã«åˆ°é” â†’ ç‹™ã„ãƒ•ã‚§ãƒ¼ã‚ºã¸
            e.x = e.stopX;
            e.y = e.stopY;
            e.phase = 'aim';
            e.phaseTimer = e.aimTime;
          } else {
            // ç§»å‹•
            const speed = e.moveSpeed * moveMul;
            e.x += (dx / dist) * speed * dt;
            e.y += (dy / dist) * speed * dt;
          }
          
        }else if(e.phase === 'aim'){
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½å°¾ï¼ˆäºˆå‚™ç·šã‚’è¡¨ç¤ºï¼‰
          e.targetAngle = Math.atan2(state.player.y - e.y, state.player.x - e.x);
          
          if(e.phaseTimer <= 0){
            // ç…§æº–å›ºå®šï¼ï¼ˆã“ã“ã‹ã‚‰å‹•ã„ã¦ã‚‚è¿½å°¾ã—ãªã„ï¼‰
            e.phase = 'lock';
            e.phaseTimer = e.lockTime;
            e.lockedAngle = e.targetAngle;  // è§’åº¦ã‚’å›ºå®š
          }
          
        }else if(e.phase === 'lock'){
          // ç…§æº–å›ºå®šä¸­ï¼ˆå›é¿ãƒãƒ£ãƒ³ã‚¹ï¼ï¼‰
          // targetAngleã¯æ›´æ–°ã—ãªã„ = å‹•ã‘ã°é¿ã‘ã‚‰ã‚Œã‚‹
          
          if(e.phaseTimer <= 0){
            // ç™ºå°„ï¼
            e.phase = 'fire';
            e.phaseTimer = 0.1;
            
            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šï¼ˆå›ºå®šè§’åº¦ã‚’ä½¿ç”¨ï¼‰
            const laserLength = 2000;
            const laserEndX = e.x + Math.cos(e.lockedAngle) * laserLength;
            const laserEndY = e.y + Math.sin(e.lockedAngle) * laserLength;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®ç·šåˆ†è·é›¢åˆ¤å®š
            const px = state.player.x, py = state.player.y;
            const dx = laserEndX - e.x, dy = laserEndY - e.y;
            const len = Math.hypot(dx, dy);
            const t = Math.max(0, Math.min(1, ((px - e.x) * dx + (py - e.y) * dy) / (len * len)));
            const closestX = e.x + t * dx;
            const closestY = e.y + t * dy;
            const distToLaser = Math.hypot(px - closestX, py - closestY);
            
            if(distToLaser < state.player.r + e.laserWidth){
              // ãƒ’ãƒƒãƒˆ
              const finalDmg = Math.round(e.laserDamage * state.mods.damageMul);
              if(state.player.iTime <= 0 && !state._debugInvincible){
                state.player.hp -= finalDmg;
                state.player.iTime = 0.5;
                addEffect('flash', { life: 0.05 });
                addEffect('text', { x: px, y: py - 20, life: 0.8, text: `-${finalDmg}` });
              }
            }
            
            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå›ºå®šè§’åº¦ã‚’ä½¿ç”¨ï¼‰
            addEffect('sniperLaser', { 
              x: e.x, y: e.y, 
              angle: e.lockedAngle, 
              length: laserLength,
              width: e.laserWidth * 3,
              life: 0.15 
            });
          }
          
        }else if(e.phase === 'fire'){
          if(e.phaseTimer <= 0){
            e.phase = 'cooldown';
            e.phaseTimer = e.cooldownTime;
          }
        }else if(e.phase === 'cooldown'){
          if(e.phaseTimer <= 0){
            e.phase = 'aim';
            e.phaseTimer = e.aimTime;
          }
        }

      // === ã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ï¼ˆæŸ±å‘¨å›ï¼‹å°„æ’ƒï¼‰ ===
      }else if(e.type==='orbiter'){
        // æŸ±ã®å‘¨ã‚Šã‚’å›è»¢
        e.orbitAngle += e.orbitSpeed * dt;
        e.x = e.centerX + Math.cos(e.orbitAngle) * e.orbitRadius;
        e.y = e.centerY + Math.sin(e.orbitAngle) * e.orbitRadius;
        
        // å°„æ’ƒã‚¿ã‚¤ãƒãƒ¼
        e.shootTimer += dt;
        if(e.shootTimer >= e.shootInterval){
          e.shootTimer = 0;
          
          // â˜…å°ã•ãªä¸‰è§’å¼¾ã‚’ã€Œæ•µã‚­ãƒ£ãƒ©ã€ã¨ã—ã¦ç™ºå°„ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ï¼‰
          const angle = Math.atan2(state.player.y - e.y, state.player.x - e.x);
          const spread = 0.3;
          
          for(const off of [-spread, 0, spread]){
            state.enemies.push({
              x: e.x, y: e.y,
              vx: Math.cos(angle + off) * 150,
              vy: Math.sin(angle + off) * 150,
              size: 12,
              hp: 16,              // â˜…HP2å€ï¼ˆ8â†’16ï¼‰
              maxHp: 16,
              dmg: 10,             // â˜…ãƒ€ãƒ¡ãƒ¼ã‚¸10ï¼ˆ8â†’10ï¼‰
              type: 'miniTriangle',
              noXpDrop: true,      // â˜…çµŒé¨“å€¤ãƒ‰ãƒ­ãƒƒãƒ—ãªã—
              bounces: 0,
              maxBounces: 3,
              rotation: angle + off,
              life: 5.0,
              hitFlash: 0, kbx: 0, kby: 0
            });
          }
        }
        
      // === miniTriangleæ•µï¼ˆã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ã®åå°„å¼¾ã€æ•µã‚­ãƒ£ãƒ©ã¨ã—ã¦å‡¦ç†ï¼‰ ===
      }else if(e.type==='miniTriangle'){
        // ç§»å‹•
        e.x += e.vx * dt * moveMul;
        e.y += e.vy * dt * moveMul;
        e.rotation = Math.atan2(e.vy, e.vx);
        
        // å¯¿å‘½ã‚«ã‚¦ãƒ³ãƒˆ
        e.life -= dt;
        if(e.life <= 0){
          state.enemies.splice(i, 1);
          continue;
        }
        
        // å£ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰å¢ƒç•Œï¼‰ã§ã®åå°„
        const margin = 20;
        if(e.x < B.minX + margin || e.x > B.maxX - margin){
          e.vx = -e.vx;
          e.x = clamp(e.x, B.minX + margin, B.maxX - margin);
          e.bounces++;
        }
        if(e.y < B.minY + margin || e.y > B.maxY - margin){
          e.vy = -e.vy;
          e.y = clamp(e.y, B.minY + margin, B.maxY - margin);
          e.bounces++;
        }
        
        // éšœå®³ç‰©ã§ã®åå°„
        for (const obs of state.obstacles) {
          const halfSize = obs.size / 2;
          const closestX = clamp(e.x, obs.x - halfSize, obs.x + halfSize);
          const closestY = clamp(e.y, obs.y - halfSize, obs.y + halfSize);
          const distX = e.x - closestX;
          const distY = e.y - closestY;
          const distSq = distX * distX + distY * distY;
          const enemyR = e.size / 2;
          
          if(distSq < enemyR * enemyR){
            const dist = Math.sqrt(distSq) || 1;
            const nx = distX / dist;
            const ny = distY / dist;
            const dot = e.vx * nx + e.vy * ny;
            e.vx = e.vx - 2 * dot * nx;
            e.vy = e.vy - 2 * dot * ny;
            e.x = closestX + nx * (enemyR + 2);
            e.y = closestY + ny * (enemyR + 2);
            e.bounces++;
            break;
          }
        }
        
        // åå°„å›æ•°è¶…éã§æ¶ˆæ»…
        if(e.bounces >= e.maxBounces){
          state.enemies.splice(i, 1);
          continue;
        }
        
      // === ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ï¼ˆå›è»¢ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼‰ ===
      }else if(e.type==='pillarTrap'){
        // å›è»¢
        e.rotation += e.rotationSpeed * dt;
        
        // å¯¿å‘½ã‚«ã‚¦ãƒ³ãƒˆ
        e.timer -= dt;
        if(e.timer <= 0){
          // æ¶ˆæ»…
          state.enemies.splice(state.enemies.indexOf(e), 1);
        } else {
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®šï¼ˆ4æ–¹å‘ï¼‰- ä¸€æ’ƒ30ãƒ€ãƒ¡ãƒ¼ã‚¸ + ãƒãƒƒã‚¯ãƒãƒƒã‚¯
          for(let i = 0; i < 4; i++){
            const angle = e.rotation + (i * Math.PI / 2);
            const endX = e.x + Math.cos(angle) * e.laserLength;
            const endY = e.y + Math.sin(angle) * e.laserLength;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®è·é›¢åˆ¤å®š
            const px = state.player.x, py = state.player.y;
            const dx = endX - e.x, dy = endY - e.y;
            const len = Math.hypot(dx, dy);
            const t = Math.max(0, Math.min(1, ((px - e.x) * dx + (py - e.y) * dy) / (len * len)));
            const closestX = e.x + t * dx;
            const closestY = e.y + t * dy;
            const distToLaser = Math.hypot(px - closestX, py - closestY);
            
            if(distToLaser < state.player.r + 8){
              if(state.player.iTime <= 0 && !state._debugInvincible){
                state.player.hp -= 30 * state.mods.damageMul;
                state.player.iTime = 0.5; // ç„¡æ•µæ™‚é–“
                
                // â˜…å¤§ãããƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å¼¾ãé£›ã°ã™ï¼‰
                const kbAngle = Math.atan2(py - closestY, px - closestX);
                const kbPower = 400; // å¼·ã„ãƒãƒƒã‚¯ãƒãƒƒã‚¯
                state.player.kbx = Math.cos(kbAngle) * kbPower;
                state.player.kby = Math.sin(kbAngle) * kbPower;
              }
            }
          }
        }

      }else if(e.type==='minion'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        const baseSpeed = (state.currentStage === 'stage2') ? 90 : 75; // ã‚¹ãƒ†ãƒ¼ã‚¸2ã§é€Ÿåº¦UP
        let newX = e.x + Math.cos(a)*baseSpeed*dt*moveMul;
        let newY = e.y + Math.sin(a)*baseSpeed*dt*moveMul;
        
        // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®š
        const enemyRadius = e.size / 2;
        let hitObstacle = false;
        let slideDir = { x: 0, y: 0 };
        
        for (const obs of state.obstacles) {
          const halfSize = obs.size / 2;
          const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
          const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
          const distX = newX - closestX;
          const distY = newY - closestY;
          const distSq = distX * distX + distY * distY;
          
          if (distSq < enemyRadius * enemyRadius) {
            hitObstacle = true;
            
            // éšœå®³ç‰©ã®æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
            const dist = Math.sqrt(distSq) || 1;
            const nx = distX / dist;
            const ny = distY / dist;
            
            // ç§»å‹•æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const moveX = Math.cos(a);
            const moveY = Math.sin(a);
            
            // æ³•ç·šæ–¹å‘ã®æˆåˆ†ã‚’é™¤å»ï¼ˆå£ã«æ²¿ã†æ–¹å‘ã‚’è¨ˆç®—ï¼‰
            const dot = moveX * nx + moveY * ny;
            slideDir.x = moveX - dot * nx;
            slideDir.y = moveY - dot * ny;
            
            // æ­£è¦åŒ–
            const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
            slideDir.x /= slideLen;
            slideDir.y /= slideLen;
            
            break;
          }
        }
        
        if (hitObstacle) {
          // å£ã«æ²¿ã£ã¦ç§»å‹•
          e.x += slideDir.x * baseSpeed * dt * moveMul;
          e.y += slideDir.y * baseSpeed * dt * moveMul;
        } else {
          // é€šå¸¸ç§»å‹•
          e.x = newX;
          e.y = newY;
        }
        
        // è¿‘æ¥çˆ†ç™ºå‡¦ç†
        const distToPlayer = Math.hypot(state.player.x - e.x, state.player.y - e.y);
        
        if (distToPlayer < e.nearThreshold) {
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã„ â†’ ç‚¹æ»…é–‹å§‹
          e.blinkTimer += dt;
          
          if (e.blinkTimer >= 1.0) {
            // 1ç§’çµŒé â†’ çˆ†ç™ºï¼
            addEffect('explosion', { x: e.x, y: e.y, r: e.explodeRadius, life: 0.3 });
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
            const distToExplosion = Math.hypot(state.player.x - e.x, state.player.y - e.y);
            if (distToExplosion < e.explodeRadius && state.player.iTime <= 0 && !state._debugInvincible) {
              const dmg = e.explodeDamage * state.mods.damageMul;
              state.player.hp -= dmg;
              state.player.iTime = 0.5; // â˜…ç„¡æ•µæ™‚é–“è¿½åŠ 
              addEffect('text', { x: state.player.x, y: state.player.y - 20, life: 0.8, text: `-${Math.floor(dmg)}` });
              addEffect('flash', { life: 0.05 });
              
              // ãƒãƒƒã‚¯ãƒãƒƒã‚¯
              const kbAng = Math.atan2(state.player.y - e.y, state.player.x - e.x);
              state.player.kbx = Math.cos(kbAng) * 180;
              state.player.kby = Math.sin(kbAng) * 180;
            }
            
            // æ•µè‡ªèº«ã‚‚æ¶ˆæ»…
            state.enemies.splice(state.enemies.indexOf(e), 1);
          }
        } else {
          // é›¢ã‚Œã¦ã„ã‚‹ â†’ ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
          e.blinkTimer = 0;
        }

      }else if(e.type==='shooter'){
        if(e.phase==='move'){
          const step = e.moveSpeed * dt * moveMul;
          let newX = e.x + e.dir.x * step;
          let newY = e.y + e.dir.y * step;
          
          // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®š
          const enemyRadius = e.size / 2;
          let collided = false;
          for (const obs of state.obstacles) {
            const halfSize = obs.size / 2;
            const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
            const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
            const distX = newX - closestX;
            const distY = newY - closestY;
            const distSq = distX * distX + distY * distY;
            
            if (distSq < enemyRadius * enemyRadius) {
              collided = true;
              break;
            }
          }
          
          if (!collided) {
            e.x = newX;
            e.y = newY;
            e.moved += step;
          } else {
            // éšœå®³ç‰©ã«å½“ãŸã£ãŸã‚‰stopãƒ•ã‚§ãƒ¼ã‚ºã¸
            e.phase = 'stop';
          }
          
          if(e.moved >= e.moveDist){ e.phase='stop'; }
        }else{
          e.cd -= dt;
          if(e.cd<=0){
            const angS = Math.atan2(state.player.y-e.y, state.player.x-e.x);
            state.enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(angS)*200, vy:Math.sin(angS)*200, r:4, dmg: (state.mode.hardcore ? 10*1.5 : 10), life:60 }); // 1.3 â†’ 1.5
            e.cd = state.mode.hardcore ? rnd(0.95, 1.05) : rnd(1.9, 2.1); // ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã§åŠåˆ†ã®é–“éš”
          }
        }

      }else if(e.type==='mid'){
        const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
        
        // ã‚¹ãƒ†ãƒ¼ã‚¸2ã®ä¸‰è§’ä¸­ãƒœã‚¹
        if(e.isTriangle){
          e.rotation = a + Math.PI/2;
          
          // â˜…ãƒ“ãƒ¼ãƒ ãƒãƒ£ãƒ¼ã‚¸ä¸­ã¯ç§»å‹•ã—ãªã„
          if(!e.beamCharging){
            // â˜…å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰ç§»å‹•
            const moveX = Math.cos(a);
            const moveY = Math.sin(a);
            let newX = e.x + moveX*e.speed*dt*moveMul;
            let newY = e.y + moveY*e.speed*dt*moveMul;
            const enemyRadius = e.size / 2;
            
            let hitObstacle = false;
            let slideDir = { x: 0, y: 0 };
            
            for (const obs of state.obstacles) {
              const halfSize = obs.size / 2;
              const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
              const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
              const distX = newX - closestX;
              const distY = newY - closestY;
              const distSq = distX * distX + distY * distY;
              
              if (distSq < enemyRadius * enemyRadius) {
                hitObstacle = true;
                const dist = Math.sqrt(distSq) || 1;
                const nx = distX / dist;
                const ny = distY / dist;
                
                // æ³•ç·šæ–¹å‘ã®æˆåˆ†ã‚’é™¤å»ï¼ˆå£ã«æ²¿ã†æ–¹å‘ã‚’è¨ˆç®—ï¼‰
                const dot = moveX * nx + moveY * ny;
                slideDir.x = moveX - dot * nx;
                slideDir.y = moveY - dot * ny;
                
                // æ­£è¦åŒ–
                const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
                slideDir.x /= slideLen;
                slideDir.y /= slideLen;
                break;
              }
            }
            
            if (hitObstacle) {
              // å£ã«æ²¿ã£ã¦ç§»å‹•
              e.x += slideDir.x * e.speed * dt * moveMul;
              e.y += slideDir.y * e.speed * dt * moveMul;
            } else {
              e.x = newX;
              e.y = newY;
            }
            
            // é€£ç¶šå¼¾ç™ºå°„ï¼ˆç§»å‹•ä¸­ã®ã¿ï¼‰
            e.burstCd -= dt;
            if(e.burstCd <= 0){
              if(e.burstCount < e.burstMax){
                const bulletAng = a + rnd(-0.2, 0.2);
                state.enemyBullets.push({ x:e.x, y:e.y, vx:Math.cos(bulletAng)*200, vy:Math.sin(bulletAng)*200, r:6, dmg:10, life:3 });
                e.burstCount++;
                e.burstCd = 0.15;
              } else {
                e.burstCount = 0;
                e.burstCd = e.burstInterval;
              }
            }
          }
          
          // å£è²«é€šãƒ“ãƒ¼ãƒ ï¼ˆãƒãƒ£ãƒ¼ã‚¸æ™‚é–“çŸ­ç¸®ã€ã‚ˆã‚Šå¼·åŠ›ã«ï¼‰
          e.beamCd -= dt;
          if(e.beamCd <= 0 && !e.beamCharging){
            e.beamCharging = true;
            e.beamChargeTime = 1.2; // â˜…2.0â†’1.2ã«çŸ­ç¸®
            e.beamAngle = a;
          }
          if(e.beamCharging){
            e.beamChargeTime -= dt;
            // â˜…äºˆå‚™ç·šã‚‚ç”»é¢ç«¯ã¾ã§å±Šãã‚ˆã†ã«
            addEffect('bossBeamWarn', { x:e.x, y:e.y, angle:e.beamAngle, length:1500, life:dt*1.1 });
            if(e.beamChargeTime <= 0){
              // ãƒ“ãƒ¼ãƒ ç™ºå°„ï¼ˆé«˜å¨åŠ›ã€ç”»é¢ç«¯ã¾ã§å±Šãï¼‰
              for(let t=0; t<1500; t+=20){ // â˜…800â†’1500
                const bx = e.x + Math.cos(e.beamAngle)*t;
                const by = e.y + Math.sin(e.beamAngle)*t;
                const d = Math.hypot(state.player.x-bx, state.player.y-by);
                if(d < state.player.r + 15 && state.player.iTime <= 0 && !state._debugInvincible){ // â˜…å½“ãŸã‚Šåˆ¤å®šã‚‚å¤ªã
                  state.player.hp -= 40;
                  state.player.iTime = 0.5;
                  break;
                }
              }
              addEffect('bossBeam', { x:e.x, y:e.y, angle:e.beamAngle, length:1500, width:35, life:0.5 }); // â˜…å¤ªã•20â†’35ã€é•·ã•800â†’1500ã€æŒç¶š0.25â†’0.5
              e.beamCharging = false;
              e.beamCd = e.beamInterval;
            }
          }
        } else {
          // é€šå¸¸ã‚¹ãƒ†ãƒ¼ã‚¸ã®ä¸­ãƒœã‚¹ - â˜…å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰ç§»å‹•
          const moveX = Math.cos(a);
          const moveY = Math.sin(a);
          const spd = e.speed * 0.9;
          let newX = e.x + moveX*spd*dt*moveMul;
          let newY = e.y + moveY*spd*dt*moveMul;
          const enemyRadius = e.size / 2;
          
          let hitObstacle = false;
          let slideDir = { x: 0, y: 0 };
          
          for (const obs of state.obstacles) {
            const halfSize = obs.size / 2;
            const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
            const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
            const distX = newX - closestX;
            const distY = newY - closestY;
            const distSq = distX * distX + distY * distY;
            
            if (distSq < enemyRadius * enemyRadius) {
              hitObstacle = true;
              const dist = Math.sqrt(distSq) || 1;
              const nx = distX / dist;
              const ny = distY / dist;
              const dot = moveX * nx + moveY * ny;
              slideDir.x = moveX - dot * nx;
              slideDir.y = moveY - dot * ny;
              const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
              slideDir.x /= slideLen;
              slideDir.y /= slideLen;
              break;
            }
          }
          
          if (hitObstacle) {
            e.x += slideDir.x * spd * dt * moveMul;
            e.y += slideDir.y * spd * dt * moveMul;
          } else {
            e.x = newX;
            e.y = newY;
          }
          
          e.cd -= dt;
          if(e.cd<=0){
            const n = 8;
            for(let k=0;k<n;k++){
              const ang = (Math.PI*2*k)/n;
              state.enemyBullets.push({ x:e.x,y:e.y, vx:Math.cos(ang)*120, vy:Math.sin(ang)*120, r:4, dmg:(state.mode.hardcore ? 18 : 12), life:3 });
            }
            e.cd = 7.0;
          }
        }

      }else if(e.type==='big' || e.type==='final'){
        const ang = Math.atan2(state.player.y - e.y, state.player.x - e.x);
        
        // ã‚¹ãƒ†ãƒ¼ã‚¸2ã®ä¸‰è§’å¤§ãƒœã‚¹
        if(e.type === 'big' && e.isTriangle){
          e.rotation = ang + Math.PI/2;
          e.cd -= dt;
          e.laserCd -= dt;
          if(e.dashCd !== undefined) e.dashCd -= dt;
          
          // é€šå¸¸ç§»å‹• - â˜…å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰å¯¾å¿œ
          if(e.dashPhase === 'idle'){
            const moveX = Math.cos(ang);
            const moveY = Math.sin(ang);
            let newX = e.x + moveX*e.speed*dt*moveMul;
            let newY = e.y + moveY*e.speed*dt*moveMul;
            const enemyRadius = e.size / 2;
            
            let hitObstacle = false;
            let slideDir = { x: 0, y: 0 };
            
            for (const obs of state.obstacles) {
              const halfSize = obs.size / 2;
              const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
              const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
              const distX = newX - closestX;
              const distY = newY - closestY;
              const distSq = distX * distX + distY * distY;
              
              if (distSq < enemyRadius * enemyRadius) {
                hitObstacle = true;
                const dist = Math.sqrt(distSq) || 1;
                const nx = distX / dist;
                const ny = distY / dist;
                const dot = moveX * nx + moveY * ny;
                slideDir.x = moveX - dot * nx;
                slideDir.y = moveY - dot * ny;
                const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
                slideDir.x /= slideLen;
                slideDir.y /= slideLen;
                break;
              }
            }
            
            if (hitObstacle) {
              e.x += slideDir.x * e.speed * dt * moveMul;
              e.y += slideDir.y * e.speed * dt * moveMul;
            } else {
              e.x = newX;
              e.y = newY;
            }
          }
          
          // å£åå°„ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼ˆé€²è¡Œæ–¹å‘ã«3ç™ºæ”¾å°„çŠ¶ï¼‰- â˜…ã‚¹ãƒ”ãƒ¼ãƒ‰1.2å€
          if(e.laserCd <= 0){
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã‚’åŸºæº–ã«Â±20åº¦ã®ç¯„å›²ã§3ç™º
            const baseAng = ang; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®è§’åº¦
            const spreadAngle = Math.PI / 9; // 20åº¦
            for(let i=0; i<3; i++){
              const offset = (i - 1) * spreadAngle; // -20Â°, 0Â°, +20Â°
              const laserAng = baseAng + offset;
              state.enemyBullets.push({
                x:e.x, y:e.y, vx:Math.cos(laserAng)*480, vy:Math.sin(laserAng)*480, // â˜…400â†’480ï¼ˆ1.2å€ï¼‰
                r:5, dmg:15, life:8, type:'reflectLaser', bounces:0, maxBounces:8, rotation:laserAng
              });
            }
            e.laserCd = 2.5; // 2.5ç§’é–“éš”
          }
          
          // çªé€²æ”»æ’ƒï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™æ–¹å¼ã«å¤‰æ›´ï¼‰
          if(e.dashPhase === 'idle' && e.dashCd <= 0){
            e.dashPhase = 'warn';
            e.dashWarnTime = 0.8; // çŸ­ã„äºˆå‘Š
            // â˜…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã‚’è¨˜éŒ²
            e.dashTargetX = state.player.x;
            e.dashTargetY = state.player.y;
            e.dashAngle = Math.atan2(e.dashTargetY - e.y, e.dashTargetX - e.x);
          }
          if(e.dashPhase === 'warn'){
            e.dashWarnTime -= dt;
            addEffect('dashWarn', { x:e.x, y:e.y, angle:e.dashAngle, length:600, life:dt*1.1 });
            if(e.dashWarnTime <= 0){ e.dashPhase = 'dash'; }
          }
          if(e.dashPhase === 'dash'){
            // â˜…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã«å‘ã‹ã£ã¦çªé€²
            const dashSpeed = 1000;
            e.x += Math.cos(e.dashAngle) * dashSpeed * dt;
            e.y += Math.sin(e.dashAngle) * dashSpeed * dt;
            
            // â˜…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã«åˆ°é”ã—ãŸã‹ç¢ºèª
            const distToTarget = Math.hypot(e.dashTargetX - e.x, e.dashTargetY - e.y);
            
            const d = Math.hypot(state.player.x - e.x, state.player.y - e.y);
            if(d < state.player.r + e.size/2 && state.player.iTime <= 0 && !state._debugInvincible){
              state.player.hp -= 35;
              state.player.iTime = 0.8;
            }
            // â˜…ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã«åˆ°é”ã—ãŸã‚‰çµ‚äº†
            if(distToTarget < 30){ e.dashPhase = 'idle'; e.dashCd = 5.0; }
          }
          
        // ã‚¹ãƒ†ãƒ¼ã‚¸2ã®ã‚´ãƒ¼ã‚¹ãƒˆãƒ©ã‚¹ãƒœã‚¹ï¼ˆæ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
        } else if(e.type === 'final' && e.isTriangle){
          e.rotation += 0.3 * dt;
          if(e.orbCd !== undefined) e.orbCd -= dt;
          if(e.bombCd !== undefined) e.bombCd -= dt;
          if(e.pillarCd !== undefined) e.pillarCd -= dt;
          
          // â˜…ã‚·ãƒ¼ãƒ«ãƒ‰ä¸‰è§’ã®å›è»¢ã‚’æ›´æ–°
          if(e.shieldAngle !== undefined){
            e.shieldAngle += e.shieldSpeed * dt;
          }
          
          // æŸ±é£›ã°ã—ãƒ•ã‚§ãƒ¼ã‚ºä¸­ã¯é™æ­¢
          if(e.pillarPhase !== 'charge' && e.pillarPhase !== 'fire'){
            // ã‚´ãƒ¼ã‚¹ãƒˆç§»å‹•ï¼ˆå£è²«é€šï¼‰
            e.x += Math.cos(ang) * e.speed * dt * moveMul;
            e.y += Math.sin(ang) * e.speed * dt * moveMul;
          }
          
          // â˜…æ”»æ’ƒ1ï¼šãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒï¼ˆ3ç™ºã€ãƒãƒ©ãƒãƒ©ã®æ–¹å‘ï¼‰
          if(e.orbCd <= 0 && e.pillarPhase === 'idle' && e.chargePhase === 'idle'){
            for(let i=0; i<3; i++){
              const orbAng = Math.random() * Math.PI * 2; // â˜…å®Œå…¨ãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘
              const speed = 130; // â˜…ã‚¹ãƒ”ãƒ¼ãƒ‰130
              state.enemyBullets.push({ 
                x: e.x, y: e.y, 
                vx: Math.cos(orbAng) * speed, vy: Math.sin(orbAng) * speed,
                r: 25, dmg: 30, life: 5.5, // â˜…ãƒ€ãƒ¡ãƒ¼ã‚¸30
                type: 'homingOrb', 
                speed: speed,
                glowing: true,
                ignoreOrbit: true // â˜…ã‚ªãƒ¼ãƒ“ãƒƒãƒˆã§æ¶ˆãˆãªã„
              });
            }
            e.orbCd = e.orbInterval;
          }
          
          // â˜…æ”»æ’ƒ2ï¼š15ç®‡æ‰€ãƒ©ãƒ³ãƒ€ãƒ çˆ†æ’ƒï¼ˆé‡ãªã‚‰ãªã„ã‚ˆã†åˆ†æ•£é…ç½®ï¼‰
          if(e.bombPhase === 'idle' && e.bombCd <= 0 && e.pillarPhase === 'idle' && e.chargePhase === 'idle'){
            e.bombPhase = 'warn';
            e.bombWarnTime = 2.0;
            e.bombTargets = [];
            const B = worldBounds();
            const bombRadius = 86; // çˆ†æ’ƒã®åŠå¾„
            const minDist = bombRadius * 2.2; // æœ€å°é–“éš”
            
            // ã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã®åˆ†æ•£é…ç½®
            const cols = 5;
            const rows = 3;
            const cellW = (B.maxX - B.minX - 100) / cols;
            const cellH = (B.maxY - B.minY - 100) / rows;
            
            for(let row = 0; row < rows; row++){
              for(let col = 0; col < cols; col++){
                // å„ã‚»ãƒ«å†…ã§ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®
                const baseX = B.minX + 50 + col * cellW;
                const baseY = B.minY + 50 + row * cellH;
                e.bombTargets.push({ 
                  x: baseX + rnd(cellW * 0.2, cellW * 0.8), 
                  y: baseY + rnd(cellH * 0.2, cellH * 0.8) 
                });
              }
            }
          }
          if(e.bombPhase === 'warn'){
            e.bombWarnTime -= dt;
            for(const t of e.bombTargets) addEffect('bombWarn', { x:t.x, y:t.y, r:86, life:dt*1.1 }); // â˜…ã•ã‚‰ã«1.2å€
            if(e.bombWarnTime <= 0){
              for(const t of e.bombTargets){
                const d = Math.hypot(state.player.x - t.x, state.player.y - t.y);
                if(d < state.player.r + 86 && state.player.iTime <= 0 && !state._debugInvincible){ state.player.hp -= 50; state.player.iTime = 0.8; } // â˜…ãƒ€ãƒ¡ãƒ¼ã‚¸50
                addEffect('explosion', { x:t.x, y:t.y, r:115, life:0.4 }); // â˜…ã•ã‚‰ã«1.2å€
              }
              e.bombPhase = 'idle';
              e.bombCd = e.bombInterval;
            }
          }
          
          // â˜…æ”»æ’ƒ3ï¼šæŸ±é£›ã°ã—
          if(e.pillarPhase === 'idle' && e.pillarCd <= 0 && state.obstacles.length > 0 && e.chargePhase === 'idle'){
            e.pillarPhase = 'charge';
            e.pillarChargeTime = 1.5;
            // æŸ±ã‚’å…‰ã‚‰ã›ã‚‹ãƒ•ãƒ©ã‚°ã¨æ–¹å‘ã‚’äº‹å‰è¨ˆç®—
            for(const obs of state.obstacles){
              obs.glowing = true;
              obs.originalX = obs.x;
              obs.originalY = obs.y;
              // â˜…äº‹å‰ã«æ–¹å‘ã‚’æ±ºå®šï¼ˆäºˆå‘Šç”¨ï¼‰
              const dx = state.player.x - obs.x;
              const dy = state.player.y - obs.y;
              if(Math.abs(dx) > Math.abs(dy)){
                obs.flyDir = { x: dx > 0 ? 1 : -1, y: 0 };
              } else {
                obs.flyDir = { x: 0, y: dy > 0 ? 1 : -1 };
              }
            }
          }
          if(e.pillarPhase === 'charge'){
            e.pillarChargeTime -= dt;
            // æŸ±ã‚’ç™½ãå…‰ã‚‰ã›ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ + â˜…æ–¹å‘äºˆå‘Šã®çŸ¢å°
            for(const obs of state.obstacles){
              addEffect('pillarGlow', { x: obs.x, y: obs.y, size: obs.size, life: dt * 1.1 });
              // â˜…æ–¹å‘ã‚’ç¤ºã™çŸ¢å°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
              if(obs.flyDir){
                const arrowLen = 80;
                const arrowX = obs.x + obs.flyDir.x * arrowLen;
                const arrowY = obs.y + obs.flyDir.y * arrowLen;
                addEffect('pillarArrow', { 
                  x: obs.x, y: obs.y, 
                  targetX: arrowX, targetY: arrowY,
                  dirX: obs.flyDir.x, dirY: obs.flyDir.y,
                  life: dt * 1.1 
                });
              }
            }
            if(e.pillarChargeTime <= 0){
              e.pillarPhase = 'fire';
              for(const obs of state.obstacles){
                obs.flying = true;
              }
            }
          }
          if(e.pillarPhase === 'fire'){
            const B = worldBounds();
            let allOut = true;
            for(const obs of state.obstacles){
              if(obs.flying){
                obs.x += obs.flyDir.x * 600 * dt;
                obs.y += obs.flyDir.y * 600 * dt;
                // ç”»é¢å†…ãƒã‚§ãƒƒã‚¯
                if(obs.x > B.minX - 100 && obs.x < B.maxX + 100 && 
                   obs.y > B.minY - 100 && obs.y < B.maxY + 100){
                  allOut = false;
                }
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®å½“ãŸã‚Šåˆ¤å®š
                const halfSize = obs.size / 2;
                if(state.player.x > obs.x - halfSize - state.player.r && 
                   state.player.x < obs.x + halfSize + state.player.r &&
                   state.player.y > obs.y - halfSize - state.player.r && 
                   state.player.y < obs.y + halfSize + state.player.r){
                  if(state.player.iTime <= 0 && !state._debugInvincible){
                    state.player.hp -= 40; // â˜…ãƒ€ãƒ¡ãƒ¼ã‚¸40
                    state.player.iTime = 0.5;
                  }
                }
              }
            }
            // å…¨ã¦ã®æŸ±ãŒç”»é¢å¤–ã«å‡ºãŸã‚‰å¾©æ´»
            if(allOut){
              for(const obs of state.obstacles){
                obs.x = obs.originalX;
                obs.y = obs.originalY;
                obs.flying = false;
                obs.glowing = false;
              }
              e.pillarPhase = 'idle';
              e.pillarCd = e.pillarInterval;
            }
          }
          
          // â˜…æ”»æ’ƒ4ï¼šå›è»¢å¼¾å¹•ï¼ˆä¸­ãƒœã‚¹ã¨åŒã˜çƒã‚’å¤§é‡ã«ã°ã‚‰æ’’ãï¼‰
          if(e.spinCd !== undefined) e.spinCd -= dt;
          if(e.spinPhase === 'idle' && e.spinCd <= 0 && e.pillarPhase === 'idle' && e.chargePhase === 'idle'){
            e.spinPhase = 'spinning';
            e.spinAngle = 0;
            e.spinDuration = 2.0; // 2ç§’é–“å›è»¢
          }
          if(e.spinPhase === 'spinning'){
            e.spinDuration -= dt;
            e.spinAngle += 8 * dt; // é«˜é€Ÿå›è»¢
            // ä¸€å®šé–“éš”ã§å¼¾ã‚’ç™ºå°„ï¼ˆ0.1ç§’ã”ã¨ï¼‰
            if(!e.spinLastShot) e.spinLastShot = 0;
            e.spinLastShot += dt;
            if(e.spinLastShot >= 0.08){
              e.spinLastShot = 0;
              // 4æ–¹å‘ã«åŒæ™‚ç™ºå°„
              for(let i = 0; i < 4; i++){
                const bulletAng = e.spinAngle + (i * Math.PI / 2);
                state.enemyBullets.push({
                  x: e.x, y: e.y,
                  vx: Math.cos(bulletAng) * 200,
                  vy: Math.sin(bulletAng) * 200,
                  r: 6, dmg: 12, life: 4,
                  type: 'normal'
                });
              }
            }
            if(e.spinDuration <= 0){
              e.spinPhase = 'idle';
              e.spinCd = e.spinInterval;
            }
          }
          
          // â˜…æ”»æ’ƒ5ï¼šå›è»¢çªé€²æ”»æ’ƒ
          if(e.chargeCd !== undefined) e.chargeCd -= dt;
          if(e.chargePhase === 'idle' && e.chargeCd <= 0 && e.pillarPhase === 'idle' && e.spinPhase === 'idle'){
            e.chargePhase = 'blink';
            e.chargeBlinkTime = 2.0; // 2ç§’ç‚¹æ»…ï¼ˆã‚ã‹ã‚Šã‚„ã™ã„äºˆå‘Šï¼‰
          }
          if(e.chargePhase === 'blink'){
            e.chargeBlinkTime -= dt;
            // æœ€åˆã®1ç§’ï¼šå‹•ãã‚’æ­¢ã‚ã¦ç‚¹æ»…
            if(e.chargeBlinkTime > 1.0){
              e.alpha = 0.3 + Math.abs(Math.sin(e.chargeBlinkTime * 12)) * 0.7;
              // è­¦å‘Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
              if(Math.floor(e.chargeBlinkTime * 12) % 2 === 0){
                addEffect('chargeWarn', { x: e.x, y: e.y, r: e.size, life: 0.08 });
              }
            } 
            // æ®‹ã‚Š1ç§’ï¼šé«˜é€Ÿå›è»¢ã—ãªãŒã‚‰ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼†ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—
            else {
              const fadeProgress = 1.0 - e.chargeBlinkTime; // 0â†’1
              e.alpha = 1.0 - fadeProgress; // 1â†’0ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
              e.rotation += 20 * dt; // è¶…é«˜é€Ÿå›è»¢
              e.chargeScaleMul = 1.0 + fadeProgress * 0.5; // 1.0â†’1.5ã«ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—
            }
            
            if(e.chargeBlinkTime <= 0){
              // ç”»é¢å¤–ã«æ¶ˆãˆã‚‹
              e.chargePhase = 'hide';
              e.chargeHideTime = 0.8; // å°‘ã—å¾…ã¤
              e.chargeScaleMul = 1.0; // ã‚µã‚¤ã‚ºãƒªã‚»ãƒƒãƒˆ
              // ç”»é¢å¤–ã«ç§»å‹•ï¼ˆè¦‹ãˆãªã„ä½ç½®ï¼‰
              const B = worldBounds();
              const side = Math.floor(Math.random() * 4);
              if(side === 0){ e.chargeStartX = rnd(B.minX, B.maxX); e.chargeStartY = B.minY - 300; }
              else if(side === 1){ e.chargeStartX = B.maxX + 300; e.chargeStartY = rnd(B.minY, B.maxY); }
              else if(side === 2){ e.chargeStartX = rnd(B.minX, B.maxX); e.chargeStartY = B.maxY + 300; }
              else { e.chargeStartX = B.minX - 300; e.chargeStartY = rnd(B.minY, B.maxY); }
              e.x = e.chargeStartX;
              e.y = e.chargeStartY;
              e.alpha = 0; // å®Œå…¨ã«æ¶ˆãˆã‚‹
            }
          }
          if(e.chargePhase === 'hide'){
            e.chargeHideTime -= dt;
            if(e.chargeHideTime <= 0){
              // ç”»é¢å¤–ã‹ã‚‰å‡ºç¾ã—ã¦çªé€²é–‹å§‹
              e.chargePhase = 'rush';
              e.chargeInvincible = true; // çªé€²ä¸­ã¯ç„¡æ•µ
              e.alpha = 0.9;
              // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®ã«å‘ã‹ã£ã¦çªé€²
              const tdx = state.player.x - e.x;
              const tdy = state.player.y - e.y;
              const tdist = Math.hypot(tdx, tdy) || 1;
              e.chargeDir = { x: tdx / tdist, y: tdy / tdist };
              // ç”»é¢å†…ã®åå¯¾å´ã‚’ç›®æ¨™ã«ï¼ˆç”»é¢å†…ã§æ­¢ã¾ã‚‹ï¼‰
              const B = worldBounds();
              const margin = 100;
              e.chargeTargetPos = {
                x: clamp(e.x + e.chargeDir.x * 1200, B.minX + margin, B.maxX - margin),
                y: clamp(e.y + e.chargeDir.y * 1200, B.minY + margin, B.maxY - margin)
              };
            }
          }
          if(e.chargePhase === 'rush'){
            // é«˜é€Ÿå›è»¢ã—ãªãŒã‚‰çªé€²
            e.rotation += 15 * dt; // è¶…é«˜é€Ÿå›è»¢
            const rushSpeed = 700; // ã‚¹ãƒ”ãƒ¼ãƒ‰700
            e.x += e.chargeDir.x * rushSpeed * dt;
            e.y += e.chargeDir.y * rushSpeed * dt;
            // ç™½ãå…‰ã‚‰ã›ã¦ç„¡æ•µã‚’ã‚ã‹ã‚Šã‚„ã™ã
            e.chargeGlow = true;
            // ãƒãƒªã‚¢ã‚‚é«˜é€Ÿå›è»¢ï¼ˆæ¥è§¦é¢ç©ã‚’å¢—ã‚„ã™ï¼‰
            if(e.shieldAngle !== undefined){
              e.shieldAngle += 12 * dt; // é€šå¸¸ã®ç´„6å€é€Ÿã§å›è»¢
            }
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸
            const pdist = Math.hypot(state.player.x - e.x, state.player.y - e.y);
            if(pdist < e.size / 2 + state.player.r && state.player.iTime <= 0 && !state._debugInvincible){
              state.player.hp -= 60; // â˜…ãƒ€ãƒ¡ãƒ¼ã‚¸60
              state.player.iTime = 1.0;
            }
            // ç›®æ¨™åœ°ç‚¹ã«åˆ°é”ã—ãŸã‚‰çµ‚äº†
            const rx = e.chargeTargetPos.x - e.x;
            const ry = e.chargeTargetPos.y - e.y;
            const remainDist = Math.hypot(rx, ry);
            if(remainDist < 50 || rx * e.chargeDir.x + ry * e.chargeDir.y <= 0){
              // ç”»é¢å†…ã§æ­¢ã¾ã‚‹
              e.x = e.chargeTargetPos.x;
              e.y = e.chargeTargetPos.y;
              e.chargePhase = 'idle';
              e.chargeCd = e.chargeInterval;
              e.chargeInvincible = false;
              e.chargeGlow = false;
              e.alpha = 0.85;
            }
          }
          
        // é€šå¸¸ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãƒœã‚¹
        } else {
          e.cd -= dt;
          e.dashCD -= dt;

          if(e.type === 'final'){
        // --- å…±é€šï¼šã‚†ã‚‹ãè¿½å°¾ - â˜…å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰å¯¾å¿œ ---
        const moveX = Math.cos(ang);
        const moveY = Math.sin(ang);
        const spd = e.speed * 0.45;
        let newX = e.x + moveX * spd * dt * moveMul;
        let newY = e.y + moveY * spd * dt * moveMul;
        
        // éšœå®³ç‰©ã¨ã®è¡çªåˆ¤å®š
        const enemyRadius = e.size / 2;
        let hitObstacle = false;
        let slideDir = { x: 0, y: 0 };
        
        for (const obs of state.obstacles) {
          const halfSize = obs.size / 2;
          const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
          const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
          const distX = newX - closestX;
          const distY = newY - closestY;
          const distSq = distX * distX + distY * distY;
          
          if (distSq < enemyRadius * enemyRadius) {
            hitObstacle = true;
            const dist = Math.sqrt(distSq) || 1;
            const nx = distX / dist;
            const ny = distY / dist;
            const dot = moveX * nx + moveY * ny;
            slideDir.x = moveX - dot * nx;
            slideDir.y = moveY - dot * ny;
            const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
            slideDir.x /= slideLen;
            slideDir.y /= slideLen;
            break;
          }
        }
        
        if (hitObstacle) {
          e.x += slideDir.x * spd * dt * moveMul;
          e.y += slideDir.y * spd * dt * moveMul;
        } else {
          e.x = newX;
          e.y = newY;
        }

// åˆæœŸåŒ–ä¿è­·
if(e.shootCD === undefined) e.shootCD = 0;
if(e.patternCD === undefined) e.patternCD = 3.5; // åˆæœŸã‚‚çŸ­ã‚

if(e.phase === 'shoot'){
  // é€šå¸¸æ‹¡æ•£å°„æ’ƒï¼ˆé »åº¦UP/ã‚„ã‚„æ¿ƒã„ï¼‰
  e.shootCD -= dt;
  if(e.shootCD <= 0){
    for(let k=-4;k<=4;k++){
      const a2 = ang + k * 0.11;
      state.enemyBullets.push({
        x:e.x, y:e.y,
        vx:Math.cos(a2)*180, vy:Math.sin(a2)*180, // å°‘ã—é€Ÿã
        r:4, dmg: (state.mode.hardcore ? 18*1.5 : 18), life:3.8 // 1.3 â†’ 1.5
      });
    }
    e.shootCD = 1.8; // â˜… 2.6â†’1.8
  }

  // ãƒ€ãƒƒã‚·ãƒ¥ï¼ˆé »åº¦UPï¼‰
  if(e.dashCD <= 0){
    e.phase = 'tele';
    e.tele  = 0.7; // 0.9â†’0.7
    e.target = { x: state.player.x, y: state.player.y };
    const dx = e.target.x - e.x, dy = e.target.y - e.y;
    const m = Math.hypot(dx,dy) || 1;
    e.dashDir = { x: dx/m, y: dy/m };
  }

  // ç‰¹æ®Šè¡Œå‹•ï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼ or å¤§çˆ†ç™ºï¼‰é »åº¦UP
  e.patternCD -= dt;
  if(e.patternCD <= 0){
    const r = Math.random();
    if(r < 0.55){
      e.phase = 'charge_laser';
      e.laserAimT = 0.8; // â˜… 1.0â†’0.8
      e.laserAng  = Math.atan2(state.player.y - e.y, state.player.x - e.x);
    }else{
      e.phase   = 'charge_boom';
      e.chargeT = 0.9;   // 1.0â†’0.9
      e.didBoomDamage = false;
    }
    e.patternCD = rnd(3.0, 5.0); // â˜… 6â€“8 â†’ 3â€“5
  }

}else if(e.phase === 'tele'){
  e.tele -= dt;
  addEffect('aim', { x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06 });
  if(e.tele <= 0){ e.phase = 'dash'; }

}else if(e.phase === 'dash'){
  const dashSpeed = 1200;
  // â˜…åº§æ¨™ãƒ­ãƒƒã‚¯ã‚ªãƒ³æ–¹å¼ï¼šteleãƒ•ã‚§ãƒ¼ã‚ºã§è¨˜éŒ²ã—ãŸtargetã«å‘ã‹ã£ã¦çªé€²ï¼ˆè¿½å°¾ã—ãªã„ï¼‰
  e.x += e.dashDir.x * dashSpeed * dt;
  e.y += e.dashDir.y * dashSpeed * dt;
  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™ã«åˆ°é”ã—ãŸã‹ç¢ºèª
  const rx = e.target.x - e.x, ry = e.target.y - e.y;
  if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
    e.cd = 1.6;          // 2.0â†’1.6
    e.dashCD = 4.8;      // 6.0â†’4.8
    e.phase = 'shoot';
  }

}else if(e.phase === 'charge_laser'){
  e.laserAimT -= dt;
  const L = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;

  // ç›®ç«‹ã¤â€œåŠé€æ˜ã®å¤ªã„äºˆå‚™ç·šâ€
  addEffect('laserGhost', { x1:e.x, y1:e.y, x2, y2, w:56, life:.06 });

  if(e.laserAimT <= 0){
    e.phase = 'laser';
    e.laserDur = 1.6;
  }

}else if(e.phase === 'laser'){
  e.laserDur -= dt;
  const L  = Math.max(W, H)/DPR + 200;
  const x2 = e.x + Math.cos(e.laserAng)*L;
  const y2 = e.y + Math.sin(e.laserAng)*L;

  const beamW = 56; // æç”»ã¨åˆã‚ã›ã‚‹
  addEffect('laserBeam', { x1:e.x, y1:e.y, x2, y2, w:beamW, life:.06 });

  // å½“ãŸã‚Šåˆ¤å®šï¼šãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯é€£ç¶šHITï¼ˆç„¡æ•µæ™‚é–“ã‚’ç„¡è¦–ã—ã¦å‰Šã‚‹ï¼‰
  const d    = pointLineDist(state.player.x, state.player.y, e.x, e.y, x2, y2);
  const hitR = beamW * 1.00;                // 
  const DPS  = state.mode.hardcore ? 75 : 50; // ä½“æ„Ÿå¼·åŒ–

  if (d < hitR){
    const finalDPS = DPS * state.mods.damageMul; // è€ä¹…åŠ›ã«ã‚ˆã‚‹è»½æ¸›
    if (!state._debugInvincible) {
      state.player.hp -= finalDPS * dt;            // ç›´æ¥HPã‚’å‰Šã‚‹ï¼ˆãƒãƒƒã‚¯ãƒãƒƒã‚¯ãªã—ï¼‰
      if (state.player.hp <= 0) { gameOver(); return; }
    }
  }

  if (e.laserDur <= 0){ e.cd = 1.8; e.phase = 'shoot'; }
}

else if(e.phase === 'charge_boom'){
  // äºˆå‚™å‹•ä½œï¼šå°ã•ã‚ã®ç™½ãƒ‘ãƒ«ã‚¹ï¼ˆçŸ­ã‚ï¼‰
  e.chargeT -= dt;
  const r0 = 60, r1 = 120;
  addEffect('whitePulse', { x:e.x, y:e.y, r0, r1, life:.06 });
  if(e.chargeT <= 0){
    // æœ¬ç•ªï¼šæ™‚é–“å·®ã§2æœ¬ã®â€œæ³¢ãƒªãƒ³ã‚°â€
    e.phase = 'boom';
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé¿ã‘ã‚„ã™ãã€ã§ã‚‚2é€£ï¼‰
    const dur  = 5.0;   // â˜… æ‹¡å¤§ã‚’ã‚†ã£ãã‚Š
    const r0   = 80;

    // â† ã“ã“ã‚’ã‚ºãƒ¼ãƒ å¯¾å¿œã«ï¼šãƒœã‚¹ä½ç½®ã‹ã‚‰ç”»é¢å†…ã§æœ€ã‚‚é ã„è§’ã¾ã§å±ŠãåŠå¾„
    const B  = worldBounds();                       // {minX,maxX,minY,maxY}
    const dx = Math.max(e.x - B.minX, B.maxX - e.x);
    const dy = Math.max(e.y - B.minY, B.maxY - e.y);
    const r1 = Math.hypot(dx, dy) + 40;             // ä½™è£•åˆ†+40

    // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãƒªãƒ³ã‚°ï¼ˆå¤§ããªéš™é–“ï¼‰
    const segCount   = 10;      // ãƒªãƒ³ã‚°åˆ†å‰²æ•°ï¼ˆå¤šã™ããªã„ï¼‰
    const gapFrac    = 0.50;    // â˜… 1ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä¸­ã®â€œéš™é–“ç‡â€ã‚’ã‚¬ãƒƒãƒ„ãƒª
    const thickness  = 22;      // è¦‹ãŸç›®ï¼†å½“ãŸã‚Šå¹…
    const wavAmp     = 10;      // æ³¢ã®æŒ¯å¹…ï¼ˆpxï¼‰
    const wavFreq    = 6;       // è§’åº¦æ–¹å‘ã®æ³¢ã®å±±å€‹æ•°
    const rot0       = Math.random()*Math.PI*2;

    // 2æœ¬ç”¨æ„ï¼ˆtimeOffsetã§æ™‚é–“å·®ï¼‰
    e.boomWaves = [
      { t: dur, dur, r0, r1, did:false, segCount, gapFrac, rot:rot0,                    w:thickness, wavAmp, wavFreq, timeOffset:0.0 },
      { t: dur, dur, r0, r1, did:false, segCount, gapFrac, rot:rot0 + Math.PI/segCount, w:thickness, wavAmp, wavFreq, timeOffset:1.00 }
    ];
    
        e.boomClock = 0; // æç”»å´ã®æ³¢ã‚¢ãƒ‹ãƒ¡ä½ç›¸ç”¨
  }

}else if(e.phase === 'boom'){
  e.boomClock += dt;

  // 2æœ¬ã®ãƒªãƒ³ã‚°ã‚’æ›´æ–°
  let allDone = true;
  for(const wv of e.boomWaves){
    // æ™‚é–“å·®ã‚¹ã‚¿ãƒ¼ãƒˆ
    if (wv.timeOffset > 0){
      wv.timeOffset -= dt;
      allDone = false;
      continue;
    }

    wv.t -= dt;
    const p = 1 - Math.max(0, wv.t) / wv.dur; // 0..1
    const R = wv.r0 + (wv.r1 - wv.r0) * p;

    // è¦‹ãŸç›®ï¼šã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‹æ³¢å½¢ã®ãƒªãƒ³ã‚°
    addEffect('boomWaveSeg', {
      x:e.x, y:e.y, r:R, w:wv.w, life:.06,
      segCount: wv.segCount, gapFrac: wv.gapFrac,
      rot: wv.rot, wavAmp: wv.wavAmp, wavFreq: wv.wavFreq,
      phase: e.boomClock        // æ³¢ã‚¢ãƒ‹ãƒ¡ä½ç›¸
    });

    // å½“ãŸã‚Šåˆ¤å®šï¼šåšã¿ä»˜ããƒªãƒ³ã‚°ï¼†éš™é–“å…é™¤
    const dx = state.player.x - e.x, dy = state.player.y - e.y;
    const d  = Math.hypot(dx, dy);
    const th = wv.w * 0.5;              // å½“ãŸã‚Šã®åŠåš
    if (!wv.did && d >= R - th && d <= R + th){
      // è§’åº¦ã‹ã‚‰â€œéš™é–“â€ã‹ã©ã†ã‹ã‚’åˆ¤å®š
      const ang = Math.atan2(dy, dx);   // -PI..PI
      if (!angleInGap(ang, wv)){        // éš™é–“ã§ãªã‘ã‚Œã°ãƒ’ãƒƒãƒˆ
        if (state.player.iTime <= 0) playerHit(60, e.x, e.y);
        wv.did = true;
      }
    }

    if (wv.t > 0) allDone = false;
  }

  if(allDone){
    e.cd = 2.4;
    e.phase = 'shoot';
  }
 }
 } 
 else {
  // === æ—¢å­˜ big ã®å‡¦ç† - â˜…å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰å¯¾å¿œ ===
  
            if(e.phase==='shoot'){
            // å£æ²¿ã„ã‚¹ãƒ©ã‚¤ãƒ‰ç§»å‹•
            const moveX = Math.cos(ang);
            const moveY = Math.sin(ang);
            const spd = e.speed * 0.6;
            let newX = e.x + moveX*spd*dt*moveMul;
            let newY = e.y + moveY*spd*dt*moveMul;
            const enemyRadius = e.size / 2;
            
            let hitObstacle = false;
            let slideDir = { x: 0, y: 0 };
            
            for (const obs of state.obstacles) {
              const halfSize = obs.size / 2;
              const closestX = clamp(newX, obs.x - halfSize, obs.x + halfSize);
              const closestY = clamp(newY, obs.y - halfSize, obs.y + halfSize);
              const distX = newX - closestX;
              const distY = newY - closestY;
              const distSq = distX * distX + distY * distY;
              
              if (distSq < enemyRadius * enemyRadius) {
                hitObstacle = true;
                const dist = Math.sqrt(distSq) || 1;
                const nx = distX / dist;
                const ny = distY / dist;
                const dot = moveX * nx + moveY * ny;
                slideDir.x = moveX - dot * nx;
                slideDir.y = moveY - dot * ny;
                const slideLen = Math.hypot(slideDir.x, slideDir.y) || 1;
                slideDir.x /= slideLen;
                slideDir.y /= slideLen;
                break;
              }
            }
            
            if (hitObstacle) {
              e.x += slideDir.x * spd * dt * moveMul;
              e.y += slideDir.y * spd * dt * moveMul;
            } else {
              e.x = newX;
              e.y = newY;
            }
            
            if(e.cd<=0)
            {
              for(let k=-3;k<=3;k++){
                const a2 = ang + k*0.12;
                state.enemyBullets.push({
                  x:e.x, y:e.y,
                  vx:Math.cos(a2)*160, vy:Math.sin(a2)*160,
                  r:4, dmg:(state.mode.hardcore ? 14*1.5 : 14), life:3.5 // 1.3 â†’ 1.5
                });
              }
              e.cd = 3.0;
            }
            if(e.dashCD<=0){
              e.phase='tele'; 
              e.tele=0.9;
              e.target = { x: state.player.x, y: state.player.y };
              const dx = e.target.x - e.x, dy = e.target.y - e.y;
              const m = Math.hypot(dx,dy)||1;
              e.dashDir = { x: dx/m, y: dy/m };
            }

          } else if(e.phase==='tele'){
            e.tele -= dt;
            addEffect('aim',{x1:e.x, y1:e.y, x2:e.target.x, y2:e.target.y, life:.06});
            if(e.tele<=0){ 
              e.phase='dash'; 
              e.tele=0; 
            }

          } else if(e.phase==='dash'){
            const dashSpeed = 980;
            e.x += e.dashDir.x * dashSpeed * dt;
            e.y += e.dashDir.y * dashSpeed * dt;
            const rx = e.target.x - e.x, ry = e.target.y - e.y;
            if(rx*e.dashDir.x + ry*e.dashDir.y <= 0){
              e.cd = 2.0; 
              e.dashCD = 6.5; 
              e.phase='shoot';
            }
          }
        }
        }
      
      // === Warperï¼ˆãƒ¯ãƒ¼ãƒ—ã™ã‚‹æ•µï¼‰ã®å‡¦ç† ===
      } else if(e.type==='bom'){
        // BOMæ•µã®å‡¦ç†
        if(e.phase==='float'){
          // ãµã‚‰ãµã‚‰ç§»å‹•
          const dx = e.targetX - e.x;
          const dy = e.targetY - e.y;
          const dist = Math.hypot(dx, dy);
          
          if(dist > 5){
            e.x += (dx / dist) * e.floatSpeed * dt * moveMul;
            e.y += (dy / dist) * e.floatSpeed * dt * moveMul;
          }
          
          e.phaseTimer -= dt;
          if(e.phaseTimer <= 0){
            e.phase = 'stop';
            e.phaseTimer = e.warningTime;
            e.warningRadius = 0;
          }
        }else if(e.phase==='stop'){
          // åœæ­¢ã—ã¦äºˆå‘Š
          e.phaseTimer -= dt;
          e.warningRadius = e.explodeRadius * (1 - e.phaseTimer / e.warningTime);
          
          if(e.phaseTimer <= 0){
            e.phase = 'explode';
          }
        }else if(e.phase==='explode'){
          // çˆ†ç™º
          const R = e.explodeRadius;
          addEffect('flash', { life: 0.06 });
          addEffect('megaNova', { x: e.x, y: e.y, r: R * 1.5, life: 0.5 });
          
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®ãƒ€ãƒ¡ãƒ¼ã‚¸
          const distToPlayer = Math.hypot(e.x - state.player.x, e.y - state.player.y);
          if(distToPlayer < R && state.player.iTime <= 0 && !state._debugInvincible){
            const finalDmg = Math.round(e.explodeDamage * state.mods.damageMul); // è€ä¹…åŠ›ã«ã‚ˆã‚‹è»½æ¸›
            state.player.hp -= finalDmg;
            state.player.iTime = 0.8; // â˜…ç„¡æ•µæ™‚é–“è¿½åŠ 
            addEffect('flash', { life: 0.05 });
          }
          
          // è¿‘ãã®æ•µã«ã‚‚ãƒ€ãƒ¡ãƒ¼ã‚¸
          for(const e2 of state.enemies){
            if(e2 === e) continue;
            const d = Math.hypot(e2.x - e.x, e2.y - e.y);
            if(d < R){
              e2.hp -= 50;
              e2.hitFlash = Math.max(e2.hitFlash, 0.12);
            }
          }
          
          // BOMè‡ªèº«ã‚’å‰Šé™¤
          state.enemies.splice(i, 1);
          continue;
        }
        
      } else if(e.type==='warper'){
        // å‡ºç¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã®æ¸›è¡°ï¼ˆæ›´æ–°ãƒ«ãƒ¼ãƒ—ã§å‡¦ç†ï¼‰
        if(e.spawnFlash > 0){
          e.spawnFlash -= dt * 2;
          if(e.spawnFlash < 0) e.spawnFlash = 0;
        }
        
        if(e.phase==='visible'){
          // å¯è¦–çŠ¶æ…‹ï¼šç§»å‹•ã›ãšã€ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã‚’æ’ƒã¤
          
          // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ç™ºå°„
          e.cd -= dt;
          if(e.cd<=0){
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã†ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾
            const a = Math.atan2(state.player.y-e.y, state.player.x-e.x);
            const speed = 150;
            state.enemyBullets.push({
              x:e.x, y:e.y,
              vx:Math.cos(a)*speed, 
              vy:Math.sin(a)*speed,
              r:7, // 5 â†’ 7 (å¤§ãã)
              dmg: (state.mode.hardcore ? 16*1.5 : 16), // 1.3 â†’ 1.5
              life:3.5, // 5 â†’ 3.5 ã«çŸ­ç¸®
              type:'homing', // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã¨ã—ã¦è­˜åˆ¥
              turnSpeed: 2.5 // æ—‹å›é€Ÿåº¦
            });
            e.cd = rnd(1.5, 2.2); // ç™ºå°„é–“éš”ã‚’é•·ãï¼ˆ0.8-1.2 â†’ 1.5-2.2ï¼‰
          }
          
          // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹åˆ¤å®š
          e.phaseTimer -= dt;
          if(e.phaseTimer <= 0.8){
            e.fadeTimer += dt;
          }
          
          // ãƒ¯ãƒ¼ãƒ—ï¼ˆæ¶ˆãˆã‚‹ï¼‰
          if(e.phaseTimer <= 0){
            e.phase = 'invisible';
            e.phaseTimer = 0.3; // æ¶ˆãˆã¦ã„ã‚‹æ™‚é–“ã‚’çŸ­ãï¼ˆ0.3ç§’ï¼‰
            e.fadeTimer = 0;
          }
          
        }else if(e.phase==='invisible'){
          // ä¸å¯è¦–çŠ¶æ…‹ï¼šã™ãå†å‡ºç¾
          e.phaseTimer -= dt;
          if(e.phaseTimer <= 0){
            // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ãƒ¯ãƒ¼ãƒ—
            const B = worldBounds();
            e.x = rnd(B.minX + 80, B.maxX - 80);
            e.y = rnd(B.minY + 80, B.maxY - 80);
            
            e.phase = 'visible';
            e.phaseTimer = rnd(4.0, 5.0); // 2.5-3.5 â†’ 4.0-5.0
            e.fadeTimer = 0;
            e.spawnFlash = 0.5; // ç™½ãƒ•ãƒ©ãƒƒã‚·ãƒ¥å†è¨­å®š
            
            // å†å‡ºç¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå¼·åŒ–
            addEffect('flash', { life: 0.1 });
            addEffect('nova', { x: e.x, y: e.y, r: 80, life: 0.3 });
            // è¿½åŠ ã®ç™½ãƒªãƒ³ã‚°
            for(let i=0; i<3; i++){
              setTimeout(() => {
                addEffect('nova', { x: e.x, y: e.y, r: 50 + i*15, life: 0.15 });
              }, i * 50);
            }
          }
        }
        
      // === Laserï¼ˆãƒ¬ãƒ¼ã‚¶ãƒ¼æ•µï¼‰ã®å‡¦ç† ===
      } else if(e.type==='laser'){
        if(e.phase==='move'){
          // ç”»é¢ç«¯ã‚’ç¸¦ã«ç§»å‹•
          const dy = e.yTarget - e.y;
          if(Math.abs(dy) > 5){
            e.y += Math.sign(dy) * e.moveSpeed * dt * moveMul;
          }else{
            e.phase = 'charge';
            e.phaseTimer = 1.0; // ãƒãƒ£ãƒ¼ã‚¸æ™‚é–“ 0.6 â†’ 1.0ï¼ˆçŒ¶äºˆã‚’å¢—ã‚„ã™ï¼‰
          }
          
        }else if(e.phase==='charge'){
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒãƒ£ãƒ¼ã‚¸ä¸­ï¼ˆäºˆå‘Šç·šè¡¨ç¤ºï¼‰
          e.phaseTimer -= dt;
          const B = worldBounds();
          const x2 = e.side === 'left' ? B.maxX + 100 : B.minX - 100;
          addEffect('aim', {x1:e.x, y1:e.y, x2:x2, y2:e.y, life:.06});
          
          if(e.phaseTimer <= 0){
            e.phase = 'shoot';
            e.phaseTimer = 0.8; // ãƒ¬ãƒ¼ã‚¶ãƒ¼æŒç¶šæ™‚é–“
            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚’ç”Ÿæˆ
            const laserDmg = state.mode.hardcore ? 25*1.5 : 25; // 1.3 â†’ 1.5
            const laserLength = Math.abs(x2 - e.x);
            state.enemyBullets.push({
              x: e.x, y: e.y,
              vx: e.side === 'left' ? laserLength : -laserLength,
              vy: 0,
              r: 8, // å¤ªã„ãƒ¬ãƒ¼ã‚¶ãƒ¼
              dmg: laserDmg,
              life: 0.8,
              type: 'laser' // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ã¨ã—ã¦è­˜åˆ¥
            });
          }
          
        }else if(e.phase==='shoot'){
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„ä¸­
          e.phaseTimer -= dt;
          if(e.phaseTimer <= 0){
            e.phase = 'cooldown';
            e.phaseTimer = 1.2; // æ¬¡ã®æ”»æ’ƒã¾ã§ã®å¾…æ©Ÿ
          }
          
        }else if(e.phase==='cooldown'){
          // å¾…æ©Ÿå¾Œã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é«˜ã•ã¸ç§»å‹•
          e.phaseTimer -= dt;
          if(e.phaseTimer <= 0){
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ã®é«˜ã•ã‚’ç›®æ¨™ã«ã™ã‚‹
            e.yTarget = state.player.y;
            e.phase = 'move';
          }
        }
      }

// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¥è§¦åˆ¤å®š
let touchDmg =
  (e.type === 'big' || e.type === 'final')
    ? (e.phase === 'dash'
        ? (e.type === 'final' ? 65 : 50)
        : (e.type === 'final' ? 40 : 32))
    : (e.type === 'mid')
      ? 24
      : (e.type === 'warper')
        ? 20
        : (e.type === 'laser')
          ? 16
          : (e.type === 'miniTriangle')
            ? (e.dmg || 8)  // â˜…miniTriangleæ•µã®ãƒ€ãƒ¡ãƒ¼ã‚¸
            : 18;

if (state.mode.hardcore) touchDmg *= 1.5; // 1.3 â†’ 1.5ã«æˆ»ã™


      if (dist2(e.x, e.y, state.player.x, state.player.y) < (state.player.r + e.size * 0.6) ** 2) {
        if (state.player.iTime <= 0) {
          playerHit(touchDmg, e.x, e.y, e);
          
          // â˜…miniTriangleæ•µã¯æ¥è§¦ã§æ¶ˆæ»…
          if(e.type === 'miniTriangle'){
            state.enemies.splice(i, 1);
          }
          
          if (state.player.hp <= 0) {
            gameOver();
            requestAnimationFrame(loop);
            return;
          }
        }
      }
// --- æ¯’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆæœ€å¤§2æšã¾ã§ã‚¹ã‚¿ãƒƒã‚¯ï¼‰ ---
// â˜…ã‚¹ãƒ”ãƒŠãƒ¼ã®é«˜é€Ÿå›è»¢ä¸­ã¯ç„¡åŠ¹
if(!(e.type === 'spinner' && e.spinPhase === 'highspin')){
  let top1 = 0, top2 = 0;  // ä¸Šä½2ã¤ã®DPS
  for (const ef of state.effects) {
    if (ef.type !== 'poisonField') continue;
    const dx = e.x - ef.x, dy = e.y - ef.y;
    if (dx*dx + dy*dy <= ef.r * ef.r) {
      const dps = ef.dps || 20;
      if (dps > top1) { top2 = top1; top1 = dps; }
      else if (dps > top2) { top2 = dps; }
    }
  }
  const poisonDps = top1 + top2; // â† æœ€å¤§2æšã¶ã‚“
  if (poisonDps > 0) {
    e.hp -= poisonDps * dt;
    e.hitFlash = Math.max(e.hitFlash, 0.06);
  }
}
      // æ•µæ­»äº¡å‡¦ç†
      if(e.hp <= 0) {
          
          // â–¼ ã‚­ãƒ«ã‚¹ã‚³ã‚¢ï¼ˆæ•µç¨®åˆ¥ã§é…ç‚¹ï¼‰
{
  let add = 0;
  if (e.type === 'final') add = 50000; // 5000 â†’ 50000
  else if (e.type === 'big') add = 1500; // 150 â†’ 1500
  else if (e.type === 'mid') add = 600; // 60 â†’ 600
  else if (e.type === 'bom') add = 500; // 50 â†’ 500ï¼ˆBOMé«˜å¾—ç‚¹ï¼‰
  else if (e.type === 'warper') add = 350; // 35 â†’ 350
  else if (e.type === 'laser') add = 320; // 32 â†’ 320
  else if (e.type === 'shooter') add = 300; // 30 â†’ 300
  else if (e.type === 'miniTriangle') add = 20; // â˜…miniTriangleã¯ä½ã‚¹ã‚³ã‚¢
  else add = 200; // minion ç­‰ï¼ˆ20 â†’ 200ï¼‰

  state.score += add;
  state.killScore = (state.killScore || 0) + add;
  if (scoreVal) scoreVal.textContent = Math.floor(state.score);
}

          
if (e.type === 'final') {
  // è¦‹ãŸç›®ï¼šå¼·ã„ç™ºå…‰ï¼‹çˆ†ç™º
  addEffect('bossExplode', { x: e.x, y: e.y, R: 420, life: 0.9, life0: 0.9 });
  addEffect('flash', { life: 0.08 });


  // å¾Œå§‹æœ«ï¼šæ•µãƒ»æ•µå¼¾ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢ï¼†ã‚¹ãƒãƒ¼ãƒ³åœæ­¢
  state.enemies.length = 0;
  state.enemyBullets.length = 0;
  state.items.length = 0;
  state.spawnTimer = 9999;



  // ã‚¯ãƒªã‚¢é·ç§»ï¼ˆå°‘ã—è¦‹ã›ã¦ã‹ã‚‰ï¼‰
state.winCountdown = 1.2;
state._winLast = performance.now();   // â† ã‚«ã‚¦ãƒ³ãƒˆã®åŸºæº–æ™‚åˆ»ã‚’åˆæœŸåŒ–
state.paused = false;                 // â† ãƒãƒ¼ã‚ºä¸­ã§ã‚‚ tick ãŒåŠ¹ããŒã€ã“ã“ã§ä¸€æ—¦è§£é™¤ã—ã¦ãŠãã¨ç¢ºå®Ÿ
} else if (e.type === 'mid' || e.type === 'big') {
          const picks = (e.type === 'big') ? 2 : 1;
          const pos = adjustDropPosition(e.x, e.y, 14);
          state.items.push({ kind: 'chest', x: pos.x, y: pos.y, r: 14, t: 0, picks });
          addEffect('text', { x: e.x, y: e.y, life: 1.2, text: (picks === 2 ? 'å®ç®±Ã—2ï¼' : 'å®ç®±ï¼') });
          spark(e.x, e.y, e.type === 'mid' ? 22 : 34);
        } else if (e.type === 'miniTriangle') {
          // â˜…miniTriangleã¯çµŒé¨“å€¤ã‚’è½ã¨ã•ãªã„ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿
          spark(e.x, e.y, 5);
        } else {
          const val = 1 + (Math.random() < 0.2 ? 1 : 0);
          dropGem(e.x, e.y, val);
          spark(e.x, e.y, 10);
        }
        state.enemies.splice(i, 1);
      }
      // ====== è¿½è¨˜ã“ã“ã¾ã§ ======

      }

    // === ã‚¢ã‚¤ãƒ†ãƒ  ===
    for(let i=state.items.length-1;i>=0;i--){
      const it=state.items[i]; it.t += dt;
      if(dist2(it.x,it.y,state.player.x,state.player.y) < (it.r + state.player.r)**2){
        applyItem(it); state.items.splice(i,1); spark(state.player.x,state.player.y,14);
        playItemSound(); // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—éŸ³
      }
      if(it.t>20){ state.items.splice(i,1); }
    }


    // === Magnet timer ===
    if (state.magnet?.active) {
      state.magnet.time += dt;
      if (state.magnet.time >= (state.magnet.dur || 0.8)) {
        state.magnet.active = false;
      }
    }
    // === ã‚¸ã‚§ãƒ  ===
    // å¸åç¯„å›²ã®åŸºç¤å€¤
    let pickupR = 70 * (1 + 0.6 * state.pickupLv);
    
    // ã‚¹ã‚­ãƒ«ã®ãƒ¬ãƒ™ãƒ«3ã§ç”»é¢ã®ç´„1/3ã®ç¯„å›²ï¼ˆå…¨ç”»é¢ã¯éå‰°ãªã®ã§ç¸®å°ï¼‰
    if (state.pickupLv >= 3) {
      const screenDiag = Math.hypot(W / DPR, H / DPR);
      pickupR = screenDiag * 0.35; // ã‚¹ã‚­ãƒ«ã¯ç´„1/3ã«åˆ¶é™
    }
    
    // ãƒã‚°ãƒãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨æ™‚ã¯å…¨ç”»é¢ã‹ã‚‰å¸åï¼ˆã‚¢ã‚¤ãƒ†ãƒ ã®ä¾¡å€¤ã‚’ç¶­æŒï¼‰
    if (state.magnet?.active) {
      pickupR = Math.hypot(W / DPR, H / DPR); // å…¨ç”»é¢
    }
    for(let i=state.gems.length-1;i>=0;i--){
      const g=state.gems[i];
      const d = Math.hypot(state.player.x-g.x, state.player.y-g.y);
      if(d<pickupR){
        const ax = (state.player.x-g.x)/Math.max(1,d);
        const ay = (state.player.y-g.y)/Math.max(1,d);
                const sp = state.magnet?.active ? (state.magnet.speed || 900) : 220;
        g.x += ax * sp * dt; g.y += ay * sp * dt;
      }
      if(dist2(g.x,g.y,state.player.x,state.player.y) < (state.player.r+g.r)**2){
        addXP(g.val*5); 
        sessionTracking.gemsCollected++;
        achievementProgress.totalGemsCollected++;
        
        // ã‚¸ã‚§ãƒ å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
        if (sessionTracking.gemsCollected >= 500) unlockAchievement('gem_500');
        
        state.gems.splice(i,1);
      }
    }

    // === ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ« ===
    for(let i=state.sparks.length-1;i>=0;i--){
      const p=state.sparks[i]; 
      p.t+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt;
      if(p.t>p.life) state.sparks.splice(i,1);
    }
    for(let i=state.effects.length-1;i>=0;i--){
      const e=state.effects[i]; 
      if (e.vx) e.x += e.vx * dt;
if (e.vy) e.y += e.vy * dt;

      e.life-=dt; 
      if(e.life<=0){ state.effects.splice(i,1); }
    }


    // === ã‚¯ãƒªã‚¢é·ç§»ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ ===
    if (state.winCountdown > 0){
      state.winCountdown -= dt;
      if (state.winCountdown <= 0){
        state.winCountdown = 0;
        showGameClear();
      }
    }

    updateHUD(); 
    draw();
    requestAnimationFrame(loop);

  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    requestAnimationFrame(loop);
  }
}

// === item icons (magnet & bomb) ===
// XPé’ä¸¸ã®ä¸­å¿ƒã«ã€ä¸ŠãŒé–‹ã„ãŸèµ¤ã„ã€ŒUã€ã‚’ä½™ç™½ã¤ãã§ç¶ºéº—ã«åã‚ã¦æã
function drawMagnet(ctx, x, y, r, t){
  ctx.save(); ctx.translate(x, y);

  // 1) èƒŒæ™¯ï¼šXPã¨åŒã˜é’ä¸¸ï¼ˆå˜è‰²ï¼‰
  const XP = '#3fa9ff';
  const R  = r * 1.35;                     // ãƒãƒƒã‚¸åŠå¾„ï¼ˆä»¥å‰ã‚ˆã‚Šå°‘ã—ã ã‘å°ã•ã‚ï¼‰
  ctx.fillStyle = XP;
  ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI * 2); ctx.fill();

  // 2) Uå­—ã®å¯¸æ³•ã‚’ã€Œå††ã®å†…å´ã«åã‚ã‚‹ã€æ¡ä»¶ã‹ã‚‰è¨ˆç®—
  const pad   = Math.max(2, R * 0.14);      // å††ã®ç¸ã‹ã‚‰ã®ä½™ç™½ï¼ˆpxï¼‰
  const Uout  = R - pad;                    // Uã®å¤–å‘¨ï¼ˆå††ã®å†…å´ã«æ¥ã™ã‚‹åŠå¾„ï¼‰
  let thick   = Math.max(3, R * 0.32);      // Uã®å¤ªã•ï¼ˆè¦‹ãŸç›®ãƒãƒ©ãƒ³ã‚¹ï¼‰
  thick       = Math.min(thick, Uout * 0.9);// å¤ªã•ãŒå¤–åŠå¾„ã‚’é£Ÿã„æ½°ã•ãªã„ã‚ˆã†ã«
  const RU    = Uout - thick / 2;           // Uã®â€œä¸­å¿ƒåŠå¾„â€ï¼ˆã“ã“ã«ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ä¸­å¿ƒãŒæ¥ã‚‹ï¼‰
  const topY  = -Uout + thick / 2;          // ç¸¦æ£’ã®ä¸Šç«¯ï¼šå††å†…å´ã«ã´ã£ãŸã‚Šåã¾ã‚‹é«˜ã•

  // 3) Uå­—ï¼ˆå·¦æ£’ â†’ ä¸‹å¼§ â†’ å³æ£’ï¼‰ã‚’åˆ¥ãƒ‘ã‚¹ã§ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯
  ctx.strokeStyle = '#ef4444';
  ctx.lineWidth   = thick;
  ctx.lineCap     = 'round';
  ctx.lineJoin    = 'round';

  // å·¦ã®ç¸¦æ£’
  ctx.beginPath();
  ctx.moveTo(-RU, topY);
  ctx.lineTo(-RU, 0);
  ctx.stroke();

  // ä¸‹åŠå††ï¼ˆUã®åº•ï¼‰â€” åæ™‚è¨ˆå›ã‚Š true ã§â€œä¸‹å´â€ã‚’é€šã‚‹
  ctx.beginPath();
  ctx.arc(0, 0, RU, Math.PI, 0, true);
  ctx.stroke();

  // å³ã®ç¸¦æ£’
  ctx.beginPath();
  ctx.moveTo( RU, 0);
  ctx.lineTo( RU, topY);
  ctx.stroke();

  ctx.restore();
}




function drawBomb(ctx, x, y, r, t){
  ctx.save(); ctx.translate(x,y);
  const R = r*1.25;

  // æœ¬ä½“
  ctx.fillStyle = '#773333';                                // ã»ã¼é»’ï¼ˆå°‘ã—èµ¤ã¿ï¼‰
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ctx.fillStyle = 'rgba(255,255,255,.08)';
  ctx.beginPath(); ctx.arc(-R*0.35,-R*0.35,R*0.55,0,Math.PI*2); ctx.fill();

  // å°ç«ç·š
  ctx.strokeStyle = '#c4b5fd';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(R*0.3,-R*0.2);
  ctx.quadraticCurveTo(R*0.9,-R*0.9, R*1.15,-R*1.25);
  ctx.stroke();

  // ç«èŠ±ï¼ˆã‚¢ãƒ‹ãƒ¡ï¼‰
  const a = t*8;
  const sx = R*1.15, sy = -R*1.25;
  ctx.translate(sx, sy);
  ctx.rotate(a);
  ctx.fillStyle = '#fde68a';
  for(let i=0;i<6;i++){
    ctx.rotate(Math.PI/3);
    ctx.beginPath();
    ctx.moveTo(0,0); ctx.lineTo(6,0); ctx.lineTo(0,12); ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

// === Heal: ç·‘ä¸¸ + ç™½åå­—ï¼ˆè»½ã„ã‚°ãƒ­ãƒ¼ & é¼“å‹•ï¼‰===
function drawHealIcon(ctx, x, y, r, t){
  ctx.save();
  // é¼“å‹•ï¼ˆã»ã‚“ã®å°‘ã—ã ã‘æ‹¡ç¸®ï¼‰
  const s = 1 + Math.sin(t*4.0)*0.06;
  ctx.translate(x, y); ctx.scale(s, s);

  // ä¸‹åœ°ã®ã‚°ãƒ­ãƒ¼
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#22c55e';
  ctx.beginPath(); ctx.arc(0,0,r*1.3,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // æœ¬ä½“ã®ç·‘ä¸¸ï¼ˆçµŒé¨“å€¤ã¨ã¯è‰²ã‚’æ˜ç¢ºã«åˆ†ã‘ã‚‹ï¼‰
  const g = ctx.createRadialGradient(-r*0.3,-r*0.3, r*0.2, 0,0, r);
  g.addColorStop(0, '#34d399');
  g.addColorStop(1, '#16a34a');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();

  // ç™½åå­—
  ctx.fillStyle = '#fff';
  const w = r*0.55, th = Math.max(2, r*0.22);
  ctx.fillRect(-th/2, -w/2, th, w);       // ç¸¦æ£’
  ctx.fillRect(-w/2, -th/2, w, th);       // æ¨ªæ£’

  // è¼ªéƒ­ï¼ˆè–„ãï¼‰
  ctx.strokeStyle = 'rgba(0,0,0,.25)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();

  ctx.restore();
}

// === Chest: é‡‘ã®å®ç®±ï¼ˆè“‹ãƒ»é‡‘å¸¯ãƒ»éŒ å‰ãƒ»è»½ã„ä¸Šä¸‹æºã‚Œï¼‰===
function drawChestIcon(ctx, x, y, r, t){
  // â˜…ä¿é™ºï¼šéæ•°ã‚’å›é¿
  r = Math.max(8, Number(r) || 14);
  x = Number.isFinite(x) ? x : 0;
  y = Number.isFinite(y) ? y : 0;

  ctx.save();
  // ã¡ã‚‡ã£ã¨ã ã‘ä¸Šä¸‹ã«ãµã‚ãµã‚
  y += Math.sin(t*3.2) * Math.min(6, r*0.18);
  ctx.translate(x, y);

  const W = r*2.0, H = r*1.5;
  const lidH = H*0.45;
  const baseH = H - lidH;

  // å½±
  ctx.globalAlpha = .20;
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.ellipse(0, H*0.65, W*0.6, r*0.45, 0, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 1;

  // æœ¬ä½“ï¼ˆåº•ï¼‰
  const bodyGrad = ctx.createLinearGradient(0, -H*0.2, 0, baseH);
  bodyGrad.addColorStop(0, '#d97706');  // æ˜ã‚‹ã„é‡‘
  bodyGrad.addColorStop(1, '#b45309');  // æ¿ƒã„é‡‘
  ctx.fillStyle = bodyGrad;
  ctx.fillRect(-W*0.5, 0, W, baseH);
  // è§’Rã£ã½ãè¦‹ã›ã‚‹ç·š
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.lineWidth=1;
  ctx.strokeRect(-W*0.5, 0, W, baseH);

  // è“‹
  const lidGrad = ctx.createLinearGradient(0, -lidH, 0, 0);
  lidGrad.addColorStop(0, '#f59e0b');
  lidGrad.addColorStop(1, '#d97706');
  ctx.fillStyle = lidGrad;
  ctx.beginPath();
  ctx.moveTo(-W*0.5, 0);
  ctx.lineTo(W*0.5, 0);
  ctx.quadraticCurveTo(W*0.5, -lidH, 0, -lidH);
  ctx.quadraticCurveTo(-W*0.5, -lidH, -W*0.5, 0);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.2)'; ctx.stroke();

  // é‡‘å±å¸¯ï¼ˆç¸¦2æœ¬ + æ¨ª1æœ¬ï¼‰
  ctx.fillStyle = '#facc15';
  const bandW = Math.max(3, r*0.22);
  ctx.fillRect(-W*0.25 - bandW/2, -lidH*0.2, bandW, baseH + lidH*0.2);
  ctx.fillRect( W*0.25 - bandW/2, -lidH*0.2, bandW, baseH + lidH*0.2);
  ctx.fillRect(-W*0.5, baseH*0.55, W, bandW);

  // éŒ å‰
  ctx.fillStyle = '#eab308';
  const lockW = Math.max(8, r*0.6)*0.6, lockH = Math.max(10, r*0.6)*0.75;
  ctx.fillRect(-lockW/2, baseH*0.25, lockW, lockH);
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.arc(0, baseH*0.25 + lockH*0.6, Math.max(2, r*0.12), 0, Math.PI*2); ctx.fill();

  ctx.restore();
}


// ==== æç”» ====
function draw(){

  try {
    ctx.clearRect(0,0,cv.width,cv.height);

    // ===== èƒŒæ™¯ =====
    const vw = cv.width / DPR, vh = cv.height / DPR;
    const px = PLAY.x, py = PLAY.y, pw = PLAY.w, ph = PLAY.h;

    // ä½™ç™½ï¼ˆæƒ…å ±ã‚¨ãƒªã‚¢å´ã‚’å«ã‚€ï¼‰ã‚’ã†ã£ã™ã‚‰æš—ã
    ctx.fillStyle = '#0b0b0b';
    // ä¸Šä¸‹
    ctx.fillRect(0, 0, vw, py);
    ctx.fillRect(0, py + ph, vw, Math.max(0, vh - (py + ph)));
    // å·¦å³
    ctx.fillRect(0, py, px, ph);
    ctx.fillRect(px + pw, py, Math.max(0, vw - (px + pw)), ph);

    // ãƒ—ãƒ¬ã‚¤é¢ã®ä¸‹åœ°ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ã¦è‰²å¤‰æ›´ï¼‰
    const currentStageData = STAGES[state.currentStage] || STAGES.stage1;
    ctx.fillStyle = currentStageData.bgColor || '#101010';
    ctx.fillRect(px, py, pw, ph);

    // ===== ã‚°ãƒªãƒƒãƒ‰ï¼ˆWORLDå˜ä½ã§ä¸€å®šã®é–“éš”ï¼‰=====
    ctx.save();
    ctx.beginPath(); ctx.rect(px, py, pw, ph); ctx.clip();

    // WORLDåº§æ¨™ã§æããŸã‚ã€å…ˆã«åŒã˜å¤‰æ›ã‚’æ›ã‘ã‚‹
    ctx.translate(px + pw*0.5, py + ph*0.5);
    const sFitOnly = Math.min(pw / WORLD.w, ph / WORLD.h);
    ctx.scale(sFitOnly, sFitOnly);
    ctx.translate(-WORLD.w * 0.5, -WORLD.h * 0.5);

    ctx.globalAlpha = .06;
    ctx.strokeStyle = '#666';

    const stepWorld = 64; // WORLDä¸Šã®ãƒã‚¹ç›®ã‚µã‚¤ã‚ºï¼ˆãŠå¥½ã¿ã§ï¼‰
    for (let x = 0; x <= WORLD.w; x += stepWorld){
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD.h); ctx.stroke();
    }
    for (let y = 0; y <= WORLD.h; y += stepWorld){
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD.w, y); ctx.stroke();
    }
    ctx.restore();

    // ===== ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ï¼šãƒ—ãƒ¬ã‚¤é¢ã®ä¸­å¿ƒã‚’åŸç‚¹ã«ï¼ˆWORLDåŸºæº–ï¼‰=====
    ctx.save();

    // ç”»é¢ã®ãƒ—ãƒ¬ã‚¤æ (PLAY)ã«ã€WORLD(å®Ÿå¯¸)ã‚’ç­‰å€ã§å…¥ã‚Œã‚‹ã‚¹ã‚±ãƒ¼ãƒ«
    const sFit = Math.min(pw / WORLD.w, ph / WORLD.h);

    // æ—¢å­˜ã®ã‚«ãƒ¡ãƒ©ã‚ºãƒ¼ãƒ ãŒã‚ã‚Œã°æ›ã‘åˆã‚ã›
    const z = (typeof state?.cameraZoom === 'number') ? state.cameraZoom : 1;

    // ãƒ—ãƒ¬ã‚¤æ ã®ä¸­å¿ƒã¸ â†’ WORLDã‚’ãƒ•ã‚£ãƒƒãƒˆå€ç‡Ã—ã‚ºãƒ¼ãƒ ã§ã‚¹ã‚±ãƒ¼ãƒ« â†’ WORLD(0..w,0..h)ã®å·¦ä¸Šã‚’åŸç‚¹ã¸
    ctx.translate(px + pw*0.5, py + ph*0.5);
    ctx.scale(sFit * z, sFit * z);
    ctx.translate(-WORLD.w * 0.5, -WORLD.h * 0.5);

    // ãƒ—ãƒ¬ã‚¤æ å¤–ï¼ˆé»’å¸¯ï¼‰ã«æã‹ã‚Œãªã„ã‚ˆã†ã€WORLDå†…ã§ã‚¯ãƒªãƒƒãƒ—
ctx.beginPath();
ctx.rect(0, 0, WORLD.w, WORLD.h);
ctx.clip();

    // â–¼â–¼ ã“ã®ä¸‹ã¯æ—¢å­˜ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰æç”»ï¼ˆitems, enemies, bullets ãªã©ï¼‰ â–¼â–¼

// â–¼â–¼ ã“ã“ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼æ•µï¼å¼¾ï¼åºŠãªã©â€œãƒ¯ãƒ¼ãƒ«ãƒ‰â€ã®æç”»ï¼ˆæ—¢å­˜ï¼‰ â–¼â–¼

// items
// éšœå®³ç‰©ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸2ï¼‰
for (const obs of state.obstacles) {
  ctx.save();
  if(obs.glowing){
    // â˜…å…‰ã£ã¦ã„ã‚‹æŸ±ï¼ˆãƒ©ã‚¹ãƒœã‚¹æ”»æ’ƒæ™‚ï¼‰
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#ffffff';
    ctx.shadowBlur = 30;
  } else {
    ctx.fillStyle = '#4a4a4a';
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 2;
  }
  ctx.fillRect(obs.x - obs.size/2, obs.y - obs.size/2, obs.size, obs.size);
  ctx.strokeRect(obs.x - obs.size/2, obs.y - obs.size/2, obs.size, obs.size);
  ctx.restore();
}

for (const it of state.items){
  const t = state.t || 0;

  if (it.kind === 'magnet'){
    drawMagnet(ctx, it.x, it.y, it.r, t);

  } else if (it.kind === 'nuke'){
    drawBomb(ctx, it.x, it.y, it.r, t);

  } else if (it.kind === 'heal'){
    drawHealIcon(ctx, it.x, it.y, it.r, t);

} else if (it.kind === 'chest'){
  const rr = Number.isFinite(it.r) ? it.r : 14;   // rãŒç„¡ã„/NaNãªã‚‰14ã«
  const xx = Number.isFinite(it.x) ? it.x : 0;    // å¿µã®ãŸã‚
  const yy = Number.isFinite(it.y) ? it.y : 0;
  drawChestIcon(ctx, xx, yy, rr * 1.2, t);
} else {
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæœªå®šç¾©ï¼‰
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath(); ctx.arc(it.x, it.y, it.r, 0, Math.PI*2); ctx.fill();
  }
}

  // gems
  for(const g of state.gems){
    ctx.fillStyle='#3fa9ff';
    ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2); ctx.fill();
  }

// bullets
for (const b of state.bullets){
  if (b.type === 'rock'){
    // æ—¢å­˜ãã®ã¾ã¾
    ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.spin||0);
    ctx.fillStyle = '#b39c82';
    const n=8, r=b.r;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const a=(i/n)*Math.PI*2, px=Math.cos(a)*r, py=Math.sin(a)*r;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill(); ctx.restore();

    } else if (b.type === 'slash') {
      // ä¸‰æ—¥æœˆã£ã½ã„æ–¬æ’ƒ
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.ang || Math.atan2(b.vy, b.vx));
      const outer = b.r * 1.2;
      const inner = Math.max(outer * 0.45, 8);
      ctx.beginPath();
      ctx.arc(0, 0, outer, -0.6, 0.6);
      ctx.arc(0, 0, inner, 0.6, -0.6, true);
      ctx.closePath();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();

  } else if (b.type === 'homing'){
    // æ—¢å­˜ãã®ã¾ã¾
    ctx.save(); ctx.translate(b.x,b.y);
    ctx.fillStyle = '#a0e1ff';
    ctx.beginPath(); ctx.arc(0,0,b.r,0,Math.PI*2); ctx.fill();
    ctx.restore();

  } else if (b.type === 'ghost') {
    // â˜… ã‚´ãƒ¼ã‚¹ãƒˆå¼¾ï¼šç´«ï¼‹ç™ºå…‰
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.fillStyle = '#a56bff';      // ç´«
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#cfa9ff';    // è–„ç´«ã«å…‰ã‚‰ã›ã‚‹
    ctx.beginPath();
    ctx.arc(0, 0, b.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

  } else if (b.type === 'rubber') {
    // ãƒ©ãƒãƒ¼ã‚·ãƒ§ãƒƒãƒˆï¼šé»„è‰²ã„å¼¾
    ctx.save();
    ctx.translate(b.x, b.y);
    ctx.fillStyle = '#ffeb3b';      // é»„è‰²
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#ffd700';
    ctx.beginPath();
    ctx.arc(0, 0, b.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();

  } else {
    // â˜… è‡ªåˆ†ã®é€šå¸¸å¼¾ï¼šç™½ç³»ã«å¤‰æ›´ï¼ˆè¦‹åˆ†ã‘ã‚„ã™ã„è»½ã„ç™ºå…‰ï¼‰
    ctx.save();
    ctx.fillStyle = '#f5f7ff';          // æ˜ã‚‹ã„ç™½
    ctx.shadowBlur = 8;                  // ã†ã£ã™ã‚‰å…‰ã‚‹
    ctx.shadowColor = '#ffffff';
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}



  // enemy bulletsï¼ˆè¦–èªæ€§å¼·åŒ–ï¼‰
  for (const b of state.enemyBullets){
    const x = b.x, y = b.y;
    
    // NaNãƒã‚§ãƒƒã‚¯ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ­»äº¡æ™‚ãªã©ã®å®‰å…¨å¯¾ç­–ï¼‰
    if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
    
    // === ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã®æç”»ï¼ˆwarperï¼‰===
    if(b.type === 'homing'){
      const rPhys = b.r || 5;
      const rVis = rPhys + 2;
      
      ctx.save();
      // ç´«è‰²ã®ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾
      const g = ctx.createRadialGradient(x, y, 0, x, y, rVis);
      g.addColorStop(0.00, '#e0b3ff');
      g.addColorStop(0.60, '#9b59b6');
      g.addColorStop(1.00, '#6c3483');
      ctx.fillStyle = g;
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(x, y, rVis, 0, Math.PI * 2);
      ctx.fill();
      
      // è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆä»»æ„ï¼‰
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#e0b3ff';
      ctx.beginPath();
      ctx.arc(x, y, rVis * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      continue;
    }
    
    // â˜…ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒã®æç”»ï¼ˆãƒ©ã‚¹ãƒœã‚¹ç”¨ï¼‰
    if(b.type === 'homingOrb'){
      ctx.save();
      // å¤§ããå…‰ã‚‹çƒ
      const g = ctx.createRadialGradient(x, y, 0, x, y, b.r);
      g.addColorStop(0.0, '#ffffff');
      g.addColorStop(0.3, '#fffacd');
      g.addColorStop(0.6, '#ffd700');
      g.addColorStop(1.0, '#ff8c00');
      ctx.fillStyle = g;
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(x, y, b.r, 0, Math.PI * 2);
      ctx.fill();
      // å†…å´ã®å…‰
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x, y, b.r * 0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      continue;
    }
    
    // === å°ã•ãªä¸‰è§’å¼¾ã®æç”»ï¼ˆã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ï¼‰ ===
    if(b.type === 'miniTriangle'){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(b.rotation || 0);
      ctx.fillStyle = '#ff6b35';
      ctx.shadowBlur = 5;
      ctx.shadowColor = '#ff6b35';
      const size = b.r * 1.5;
      ctx.beginPath();
      ctx.moveTo(size, 0);
      ctx.lineTo(-size * 0.6, -size * 0.5);
      ctx.lineTo(-size * 0.6, size * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      continue;
    }
    
    // === åå°„ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ã®æç”»ï¼ˆå¤§ãƒœã‚¹ï¼‰ç´°é•·ã„ ===
    if(b.type === 'reflectLaser'){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(b.rotation || 0);
      ctx.fillStyle = '#00ff88';
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#00ff88';
      // ç´°é•·ã„å½¢çŠ¶
      const len = b.r * 4;  // é•·ã•
      const wid = b.r * 0.8; // å¹…ï¼ˆç´°ã„ï¼‰
      ctx.beginPath();
      ctx.moveTo(len, 0);           // å…ˆç«¯
      ctx.lineTo(-len * 0.3, -wid); // å·¦å¾Œã‚
      ctx.lineTo(-len * 0.3, wid);  // å³å¾Œã‚
      ctx.closePath();
      ctx.fill();
      // ç™½ã„ã‚³ã‚¢
      ctx.fillStyle = '#ffffff';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(len * 0.7, 0);
      ctx.lineTo(-len * 0.1, -wid * 0.5);
      ctx.lineTo(-len * 0.1, wid * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      continue;
    }
    
    // === ã‚´ãƒ¼ã‚¹ãƒˆå¼¾ã®æç”»ï¼ˆãƒ©ã‚¹ãƒœã‚¹ï¼‰ ===
    if(b.type === 'ghostBullet'){
      ctx.save();
      ctx.translate(x, y);
      ctx.globalAlpha = b.alpha || 0.6;
      ctx.fillStyle = '#9b59b6';
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#9b59b6';
      ctx.beginPath();
      ctx.arc(0, 0, b.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#e0b3ff';
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(0, 0, b.r * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      continue;
    }
    
    // === ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼¾ã®æç”» ===
    if(b.type === 'laser'){
      const length = Math.abs(b.vx || 0);
      const thick = (b.r || 8) * 2;
      
      ctx.save();
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼æœ¬ä½“ï¼ˆé»„è‰²ã„é•·æ–¹å½¢ï¼‰
      ctx.fillStyle = 'rgba(241, 196, 15, 0.7)'; // åŠé€æ˜é»„è‰²
      ctx.shadowColor = '#f1c40f';
      ctx.shadowBlur = 12;
      const lx = b.vx > 0 ? x : x - length;
      ctx.fillRect(lx, y - thick/2, length, thick);
      
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®ç¸ï¼ˆæ˜ã‚‹ã„é»„è‰²ï¼‰
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.strokeRect(lx, y - thick/2, length, thick);
      ctx.restore();
      continue;
    }
    
    // === é€šå¸¸å¼¾ã®æç”» ===
    const rPhys = b.r || 5;        // å½“ãŸã‚Šåˆ¤å®šåŠå¾„ï¼ˆå¤‰æ›´ãªã—ï¼‰
    const rVis  = rPhys + 2.5;     // è¦‹ãŸç›®ã¯å°‘ã—å¤§ãã

    ctx.save();

    // 1) å¤–ç¸ï¼ˆãƒ€ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼‰
    ctx.beginPath();
    ctx.arc(x, y, rVis + 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.fill();

    // 2) ã‚³ã‚¢ï¼ˆç™½â†’ã‚ªãƒ¬ãƒ³ã‚¸ã®æ”¾å°„ã‚°ãƒ©ãƒ‡ï¼‹ã‚„ã‚ã‚‰ã‹ã„ç™ºå…‰ï¼‰
    const g = ctx.createRadialGradient(x, y, 0, x, y, rVis);
    g.addColorStop(0.00, '#F47A4D');
    g.addColorStop(0.55, '#F47A4D');
    g.addColorStop(1.00, '#E15A28');
    ctx.beginPath();
    ctx.arc(x, y, rVis, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.shadowColor = 'rgba(255,255,255,0.85)';
    ctx.shadowBlur  = 8;
    ctx.fill();

    // 3) ãƒªãƒ ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç™½ã„ç´°ç¸ï¼‰
    const dpr = (typeof DPR !== 'undefined' && DPR) ? DPR : (window.devicePixelRatio || 1);
    ctx.lineWidth = 0.2 * dpr;
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.stroke();

    ctx.restore();

    // é€Ÿåº¦ãŒé€Ÿã„å¼¾ã¯1pxã®ç™½ç‚¹ã§ãƒãƒ©è¦‹ã›ï¼ˆä»»æ„ï¼‰
    if ((b.vx*b.vx + b.vy*b.vy) > 120*120){
      ctx.fillStyle = '#fff';
      ctx.fillRect((x|0)-0.5, (y|0)-0.5, 1, 1);
    }
  }

// ç„¡æ•µä¸­ã¯ç‚¹æ»…
if (state.player.iTime > 0 && ((state.t * 20 | 0) % 2 === 0)) {
  ctx.globalAlpha = 0.38; // è–„ã
} else {
  ctx.globalAlpha = 1;
}
// player

if (state.player && state.player.visible === false) {
  // ä½•ã‚‚æã‹ãªã„
} else {
ctx.fillStyle = '#2ecc71';
ctx.beginPath(); ctx.arc(state.player.x, state.player.y, state.player.r, 0, Math.PI*2); ctx.fill();
ctx.lineWidth = 3; ctx.strokeStyle = '#ffffff'; ctx.stroke();
ctx.fillStyle = '#0b0b0b';
ctx.beginPath(); ctx.arc(state.player.x-5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(state.player.x+5, state.player.y-3, 2, 0, Math.PI*2); ctx.fill();

ctx.globalAlpha = 1;  // â† ã“ã“ã¾ã§ãŒæ—¢å­˜
}

/* ===== ã“ã“ã‹ã‚‰è¿½è¨˜ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‘¨å›²ãƒªãƒ³ã‚°ï¼ˆHP/XPï¼‰ ===== */
{
  const hpRatio = Math.max(0, Math.min(1, state.player.hp / state.player.maxHp));
  const xpRatio = Math.max(0, Math.min(1, state.player.xp / state.player.nextXp(state.player.level)));

  const R0 = state.player.r + 7;   // HPãƒªãƒ³ã‚°åŠå¾„
  const R1 = state.player.r + 12;  // XPãƒªãƒ³ã‚°åŠå¾„

  ctx.save();
  ctx.lineCap = 'round';

  // èƒŒæ™¯ãƒªãƒ³ã‚°ï¼ˆè–„ã‚°ãƒ¬ãƒ¼ï¼‰
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R0, 0, Math.PI*2); ctx.stroke();
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(state.player.x, state.player.y, R1, 0, Math.PI*2); ctx.stroke();

  // â˜… HPãƒªãƒ³ã‚°ï¼ˆ20%ä»¥ä¸‹ã§èµ¤ã€ãã‚Œä»¥å¤–ã¯ç·‘ï¼‰
  const hpColor = (hpRatio <= 0.20) ? '#ff5a5a' : '#2ecc71';
  ctx.strokeStyle = hpColor;
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R0,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*hpRatio
  );
  ctx.stroke();

  // XPãƒªãƒ³ã‚°ï¼ˆé’ï¼‰
  ctx.strokeStyle = '#3498db';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(
    state.player.x, state.player.y, R1,
    -Math.PI/2, -Math.PI/2 + Math.PI*2*xpRatio
  );
  ctx.stroke();

  // ï¼ˆç‹­ã„ç”»é¢å‘ã‘ï¼‰HPæ•°å€¤ã®å°è¡¨ç¤ºã¯ãã®ã¾ã¾ã§OK
  if (window.innerWidth <= 480) {
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${Math.ceil(state.player.hp)}/${state.player.maxHp}`,
      state.player.x, state.player.y - R0 - 6);
  }

  ctx.restore();
}
/* ===== è¿½è¨˜ã“ã“ã¾ã§ ===== */


// Ghosts render
if(state.weapons.ghost.lv>0){
  const w = state.weapons.ghost;
  const count = w.awaken ? 6 : w.lv;
  ctx.save();
  ctx.globalAlpha = 0.85;
  for(let k=0;k<count;k++){
    const a = w.ang + k * (Math.PI*2/count);
    const r = 40 + 6*(w.lv-1);
    const gx = state.player.x + Math.cos(a)*r;
    const gy = state.player.y + Math.sin(a)*r;

    // --- æœ¬ä½“ ---
    ctx.fillStyle = '#7ee4ff'; // æ°´è‰²ãƒœãƒ‡ã‚£
    ctx.beginPath();
    ctx.arc(gx, gy, 9, 0, Math.PI*2);
    ctx.fill();

    // --- é¡”ï¼ˆç›®ï¼‹å£ï¼‰ ---
    ctx.fillStyle = '#000';  // é»’ç›®
    ctx.beginPath(); ctx.arc(gx - 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(gx + 3, gy - 2, 1.5, 0, Math.PI*2); ctx.fill();

ctx.strokeStyle = '#000';
ctx.lineWidth = 1.5;       // å°‘ã—å¤ªã‚ã«
ctx.lineCap = 'round';     // ç«¯ã‚’ä¸¸ãã—ã¦è‡ªç„¶ã«
ctx.beginPath();
ctx.moveTo(gx - 3, gy + 2);
ctx.lineTo(gx + 3, gy + 2);
ctx.stroke();
  }
  ctx.restore();
}

// orbitals
if(state.weapons.orbit.lv>0){
  const w = state.weapons.orbit;
  const count = w.awaken ? 8 : (2 + w.lv);
  const rad = w.baseR + 14*(w.lv-1) + (w.awaken? 12:0);
  const orbR = (w.hitRBase + (w.awaken? 4:0)) * state.mods.sizeMul;

  ctx.fillStyle = '#9b59b6';
  for(let k=0;k<count;k++){
    const ang = w.ang + k*(Math.PI*2/count);
    const ox = state.player.x + Math.cos(ang)*rad;
    const oy = state.player.y + Math.sin(ang)*rad;
    ctx.beginPath(); ctx.arc(ox, oy, orbR, 0, Math.PI*2); ctx.fill();
  }
}

  // enemies with HP bars
  for(const e of state.enemies){
    const s=e.size;
    
    // === BOM ã®æç”»ï¼ˆã‚°ãƒ¬ãƒ¼ã®å››è§’ + äºˆå‘Šç·šï¼‰ ===
    if(e.type==='bom'){
      // æœ¬ä½“ï¼ˆã‚°ãƒ¬ãƒ¼ã®å››è§’ï¼‰
      ctx.fillStyle = '#95a5a6'; // ã‚°ãƒ¬ãƒ¼
      const w = e.sizeW || s * 1.4;
      const h = s;
      ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
      
      if(e.hitFlash>0){
        ctx.save(); 
        ctx.globalAlpha = e.hitFlash; 
        ctx.fillStyle = '#fff';
        ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
        ctx.restore();
      }
      
      // äºˆå‘Šå††ï¼ˆstop/warning phaseï¼‰
      if(e.phase==='stop' && e.warningRadius > 0){
        const progress = 1 - e.phaseTimer / e.warningTime;
        const alpha = 0.3 + 0.4 * Math.sin(progress * Math.PI * 8);
        
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.warningRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
      
      // HPãƒãƒ¼
      const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      const bw = w, bh = 4;
      const bx = e.x - bw/2, by = e.y - h/2 - 6;
      ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
      ctx.fillRect(bx, by, bw*ratio, bh);
      ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
      
    // === Warper ã®æç”»ï¼ˆç´«ã®ç¸¦é•·å››è§’ï¼‰ ===
    } else if(e.type==='warper'){
      if(e.phase==='invisible'){
        continue; // ä¸å¯è¦–æ™‚ã¯æç”»ã—ãªã„
      }
      
      // å‡ºç¾æ™‚ã®ç™½ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      if(e.spawnFlash > 0){
        const flashAlpha = Math.max(0, e.spawnFlash);
        ctx.save();
        ctx.globalAlpha = flashAlpha;
        ctx.fillStyle = '#ffffff';
        const w = e.size * 1.5;
        const h = (e.sizeH || e.size * 1.75) * 1.5;
        ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
        ctx.restore();
      }
      
      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆæ¶ˆãˆã‚‹å‰ã«ç‚¹æ»…ï¼‰
      let alpha = 1;
      if(e.fadeTimer > 0){
        const blinkSpeed = 12;
        const blink = Math.sin(e.fadeTimer * blinkSpeed * Math.PI);
        alpha = 0.3 + 0.7 * Math.max(0, blink);
      }
      
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#9b59b6'; // ç´«è‰²
      const w = e.size;
      const h = e.sizeH || e.size * 1.75;
      ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
      
      if(e.hitFlash>0){
        ctx.globalAlpha = e.hitFlash * alpha;
        ctx.fillStyle = '#fff';
        ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
      }
      ctx.restore();
      
      // HPãƒãƒ¼
      const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      const bw = w, bh = 4; 
      const bx = e.x - bw/2, by = e.y - h/2 - 6;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
      ctx.fillRect(bx, by, bw*ratio, bh);
      ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
      ctx.globalAlpha = 1;
      
    // === Laser ã®æç”»ï¼ˆé»„è‰²ã„æ¨ªé•·å››è§’ï¼‰ ===
    } else if(e.type==='laser'){
      ctx.fillStyle = '#f1c40f'; // é»„è‰²
      const w = e.sizeW || e.size * 2.5;
      const h = e.size;
      ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
      
      if(e.hitFlash>0){
        ctx.save(); 
        ctx.globalAlpha = e.hitFlash; 
        ctx.fillStyle = '#fff';
        ctx.fillRect(e.x - w/2, e.y - h/2, w, h);
        ctx.restore();
      }
      
      // HPãƒãƒ¼
      const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      const bw = w, bh = 4;
      const bx = e.x - bw/2, by = e.y - h/2 - 6;
      ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
      ctx.fillRect(bx, by, bw*ratio, bh);
      ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
      
    // === æ—¢å­˜ã®æ•µ ===
    } else {
    // === ã‚¹ãƒ”ãƒŠãƒ¼ï¼†ãƒ€ãƒƒã‚·ãƒ£ãƒ¼ï¼†ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã®æç”» ===
    // â˜…miniTriangleæ•µã®æç”»ï¼ˆã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ã®åå°„å¼¾ï¼‰
    if(e.type==='miniTriangle'){
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(e.rotation || 0);
      
      // å°ã•ãªèµ¤ã„ä¸‰è§’å½¢
      ctx.fillStyle = '#e74c3c';
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#ff6666';
      
      const size = e.size;
      ctx.beginPath();
      ctx.moveTo(size/2, 0);           // å…ˆç«¯ï¼ˆå³å‘ãï¼‰
      ctx.lineTo(-size/2, -size/3);    // å·¦ä¸Š
      ctx.lineTo(-size/2, size/3);     // å·¦ä¸‹
      ctx.closePath();
      ctx.fill();
      
      // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      if(e.hitFlash > 0){
        ctx.globalAlpha = e.hitFlash;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(size/2, 0);
        ctx.lineTo(-size/2, -size/3);
        ctx.lineTo(-size/2, size/3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
      continue;
    }
    
    if(e.type==='spinner' || e.type==='dasher' || e.type==='sniper' || e.type==='orbiter' || e.type==='pillarTrap'){
      ctx.save();
      ctx.translate(e.x, e.y);
      
      // è‰²è¨­å®š
      if(e.type==='spinner'){
        if(e.spinPhase === 'highspin'){
          ctx.fillStyle='#4a4a4a'; // é«˜é€Ÿå›è»¢ä¸­ã¯æ¿ƒã„ã‚°ãƒ¬ãƒ¼
          // ã‚°ãƒ­ã‚¦ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          ctx.shadowBlur = 15;
          ctx.shadowColor = '#666';
        }else{
          ctx.fillStyle='#9b59b6'; // é€šå¸¸ã¯ç´«
          ctx.shadowBlur = 0;
        }
      }else if(e.type==='sniper'){
        // ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã¯è–„ã„é»„è‰²
        if(e.phase === 'aim'){
          ctx.fillStyle='#fff59d'; // ç‹™ã„ä¸­ã¯è–„ã„é»„è‰²
        }else if(e.phase === 'fire'){
          ctx.fillStyle='#fff'; // ç™ºå°„æ™‚ã¯ç™½
        }else{
          ctx.fillStyle='#f9e076'; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã¯å°‘ã—æ¿ƒã„é»„
        }
      }else if(e.type==='orbiter'){
        // ã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ã¯ç·‘è‰²
        ctx.fillStyle='#27ae60';
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#2ecc71';
      }else if(e.type==='pillarTrap'){
        // ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ã¯èµ¤ç´«ï¼ˆå±é™ºè‰²ï¼‰
        ctx.fillStyle='#c0392b';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff0000';
      }else{
        // ãƒ€ãƒƒã‚·ãƒ£ãƒ¼ã¯ãƒ•ã‚§ãƒ¼ã‚ºã§è‰²å¤‰æ›´
        if(e.phase === 'dash'){
          ctx.fillStyle='#e74c3c'; // ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã¯èµ¤
        }else{
          ctx.fillStyle='#f39c12'; // é€šå¸¸ã¯ã‚ªãƒ¬ãƒ³ã‚¸
        }
      }
      
      // å›è»¢
      if(e.rotation !== undefined){
        ctx.rotate(e.rotation);
      }
      
      // ä¸‰è§’å½¢æç”»ï¼ˆãƒ€ãƒƒã‚·ãƒ£ãƒ¼ã¯ç´°é•·ã„å½¢ï¼‰
      if(e.type === 'dasher'){
        // é ‚è§’20åº¦ã®äºŒç­‰è¾ºä¸‰è§’å½¢ï¼ˆç´°é•·ã„ï¼‰
        const w = e.width || 12;   // æ¨ªå¹…ï¼ˆç´°ã„ï¼‰
        const h = e.height || 40;  // ç¸¦å¹…ï¼ˆé•·ã„ï¼‰
        
        ctx.beginPath();
        ctx.moveTo(0, -h/2);       // å…ˆç«¯ï¼ˆä¸Šï¼‰
        ctx.lineTo(-w/2, h/2);     // å·¦ä¸‹
        ctx.lineTo(w/2, h/2);      // å³ä¸‹
        ctx.closePath();
        ctx.fill();
        
        // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        if(e.hitFlash>0){
          ctx.globalAlpha=e.hitFlash;
          ctx.fillStyle='#fff';
          ctx.beginPath();
          ctx.moveTo(0, -h/2);
          ctx.lineTo(-w/2, h/2);
          ctx.lineTo(w/2, h/2);
          ctx.closePath();
          ctx.fill();
        }
      } else if(e.type === 'orbiter') {
        // ã‚ªãƒ¼ãƒ“ã‚¿ãƒ¼ï¼ˆä¸‰è§’å½¢ã§æŸ±ã‚’å‘¨å›ï¼‰
        const size = e.size;
        
        // é€²è¡Œæ–¹å‘ã‚’å‘ã
        ctx.rotate(e.orbitAngle + Math.PI / 2);
        
        ctx.beginPath();
        ctx.moveTo(0, -size/2);
        ctx.lineTo(-size/2, size/2);
        ctx.lineTo(size/2, size/2);
        ctx.closePath();
        ctx.fill();
        
        // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        if(e.hitFlash>0){
          ctx.globalAlpha=e.hitFlash;
          ctx.fillStyle='#fff';
          ctx.beginPath();
          ctx.moveTo(0, -size/2);
          ctx.lineTo(-size/2, size/2);
          ctx.lineTo(size/2, size/2);
          ctx.closePath();
          ctx.fill();
        }
      } else if(e.type === 'pillarTrap') {
        // ãƒ”ãƒ©ãƒ¼ãƒˆãƒ©ãƒƒãƒ—ï¼ˆä¸­å¿ƒã®å††ï¼‹4æ–¹å‘ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼‰
        // ä¸­å¿ƒå††
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // å†…å´ã®ç™½ã„å††
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // å›è»¢ãƒ¬ãƒ¼ã‚¶ãƒ¼ï¼ˆ4æ–¹å‘ï¼‰
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 6;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff0000';
        ctx.globalAlpha = 0.8;
        
        for(let i = 0; i < 4; i++){
          const angle = i * Math.PI / 2;  // 0, 90, 180, 270åº¦
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * e.laserLength, Math.sin(angle) * e.laserLength);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
      } else {
        // ã‚¹ãƒ”ãƒŠãƒ¼ã¯é€šå¸¸ã®ä¸‰è§’å½¢
        ctx.beginPath();
        ctx.moveTo(0, -s/2);
        ctx.lineTo(-s/2, s/2);
        ctx.lineTo(s/2, s/2);
        ctx.closePath();
        ctx.fill();
        
        // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        if(e.hitFlash>0){
          ctx.globalAlpha=e.hitFlash;
          ctx.fillStyle='#fff';
          ctx.beginPath();
          ctx.moveTo(0, -s/2);
          ctx.lineTo(-s/2, s/2);
          ctx.lineTo(s/2, s/2);
          ctx.closePath();
          ctx.fill();
        }
      }
      
      ctx.restore();
      
      // ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã®äºˆå‚™ç·š
      if(e.type === 'sniper' && (e.phase === 'aim' || e.phase === 'lock')){
        ctx.save();
        const laserLength = 2000;
        
        if(e.phase === 'aim'){
          // è¿½å°¾ä¸­ï¼ˆèµ¤ã„ç‚¹ç·šï¼‰
          const aimProgress = 1 - (e.phaseTimer / e.aimTime);
          ctx.globalAlpha = 0.3 + 0.3 * aimProgress;
          ctx.strokeStyle = '#ff0000';
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 10]);
          
          ctx.beginPath();
          ctx.moveTo(e.x, e.y);
          ctx.lineTo(
            e.x + Math.cos(e.targetAngle) * laserLength,
            e.y + Math.sin(e.targetAngle) * laserLength
          );
          ctx.stroke();
        } else {
          // å›ºå®šä¸­ï¼ˆç™½ã„å®Ÿç·šï¼‹ç‚¹æ»…ï¼‰å›é¿ãƒãƒ£ãƒ³ã‚¹ï¼
          const blinkPhase = Math.sin(state.t * 20) > 0;
          ctx.globalAlpha = blinkPhase ? 0.9 : 0.5;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff0000';
          
          ctx.beginPath();
          ctx.moveTo(e.x, e.y);
          ctx.lineTo(
            e.x + Math.cos(e.lockedAngle) * laserLength,
            e.y + Math.sin(e.lockedAngle) * laserLength
          );
          ctx.stroke();
        }
        
        ctx.setLineDash([]);
        ctx.restore();
      }
      
      // HPãƒãƒ¼
      const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      const bw = s, bh = 4;
      const bx = e.x - bw/2, by = e.y - s/2 - 6;
      ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
      ctx.fillRect(bx, by, bw*ratio, bh);
      ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
      
    // === æ—¢å­˜ã®æ•µï¼ˆé€šå¸¸ï¼‰ ===
    }else{
    // è‰²è¨­å®šï¼ˆminionè¿‘æ¥çˆ†ç™ºã®ç‚¹æ»…ï¼‰
    if(e.type==='minion'){
      if (e.blinkTimer > 0) {
        // ç‚¹æ»…ï¼ˆç‚¹æ»…é€Ÿåº¦ã‚’åŠ é€Ÿï¼‰
        const blinkSpeed = 5 + (e.blinkTimer * 10); // æ™‚é–“çµŒéã§é€Ÿããªã‚‹
        const blinkPhase = Math.sin(state.t * blinkSpeed * Math.PI);
        ctx.fillStyle = blinkPhase > 0 ? '#ff0000' : '#e74c3c';
      } else {
        ctx.fillStyle = '#e74c3c';
      }
    }
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸2ã®ä¸‰è§’ãƒœã‚¹æç”»
    if(e.isTriangle && (e.type === 'mid' || e.type === 'big' || e.type === 'final')){
      
      // â˜…ãƒ©ã‚¹ãƒœã‚¹å°‚ç”¨ï¼šã‚ªãƒ¼ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      if(e.type === 'final' && !e.chargeGlow){
        ctx.save();
        const auraTime = performance.now() / 1000;
        // è¤‡æ•°ã®ã‚ªãƒ¼ãƒ©ãƒªãƒ³ã‚°
        for(let ring = 0; ring < 3; ring++){
          const auraRadius = s * 0.7 + ring * 25 + Math.sin(auraTime * 2 + ring) * 10;
          const auraAlpha = (0.3 - ring * 0.08) * (e.alpha || 1);
          ctx.beginPath();
          ctx.arc(e.x, e.y, auraRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(168, 85, 247, ${auraAlpha})`;
          ctx.lineWidth = 4 - ring;
          ctx.stroke();
        }
        // ãƒ‘ãƒ«ã‚¹ã‚ªãƒ¼ãƒ©
        const pulseRadius = s * 0.6 + Math.sin(auraTime * 4) * 20;
        const gradient = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, pulseRadius);
        gradient.addColorStop(0, 'rgba(147, 51, 234, 0)');
        gradient.addColorStop(0.7, 'rgba(147, 51, 234, 0.1)');
        gradient.addColorStop(1, 'rgba(168, 85, 247, 0.3)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(e.x, e.y, pulseRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(e.rotation || 0);
      // â˜…ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ™‚ã®ã‚µã‚¤ã‚ºã‚¢ãƒƒãƒ—
      const scaleMul = e.chargeScaleMul || 1.0;
      if(scaleMul !== 1.0) ctx.scale(scaleMul, scaleMul);
      if(e.isGhost) ctx.globalAlpha = e.alpha || 0.7;
      
      if(e.type === 'mid'){ ctx.fillStyle = '#00bcd4'; ctx.shadowBlur = 15; ctx.shadowColor = '#00bcd4'; }
      else if(e.type === 'big'){ ctx.fillStyle = '#ff6b35'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff6b35'; }
      else if(e.type === 'final'){ 
        // â˜…å›è»¢ã‚¢ã‚¿ãƒƒã‚¯ä¸­ã¯ç™½ãå…‰ã‚‹
        if(e.chargeGlow){
          ctx.fillStyle = '#ffffff';
          ctx.shadowBlur = 60;
          ctx.shadowColor = '#ffffff';
        } else {
          // â˜…å¼·ã„ç´«è‰²
          ctx.fillStyle = '#9333ea';
          ctx.shadowBlur = 50;
          ctx.shadowColor = '#a855f7';
        }
      }
      
      ctx.beginPath();
      ctx.moveTo(0, -s/2);
      ctx.lineTo(-s/2, s/2);
      ctx.lineTo(s/2, s/2);
      ctx.closePath();
      ctx.fill();
      
      if(e.hitFlash > 0){
        ctx.globalAlpha = e.hitFlash;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(0, -s/2);
        ctx.lineTo(-s/2, s/2);
        ctx.lineTo(s/2, s/2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
      
      // â˜…ã‚·ãƒ¼ãƒ«ãƒ‰ä¸‰è§’ã®æç”»ï¼ˆãƒ©ã‚¹ãƒœã‚¹å°‚ç”¨ï¼‰
      if(e.type === 'final' && e.shieldCount > 0 && e.shieldAngle !== undefined){
        for(let k = 0; k < e.shieldCount; k++){
          const shieldAng = e.shieldAngle + (k * Math.PI * 2 / e.shieldCount);
          const shieldX = e.x + Math.cos(shieldAng) * e.shieldRadius;
          const shieldY = e.y + Math.sin(shieldAng) * e.shieldRadius;
          const shieldSize = 28;
          
          ctx.save();
          ctx.translate(shieldX, shieldY);
          ctx.rotate(shieldAng + Math.PI / 2); // å¤–å´ã‚’å‘ã
          
          // â˜…å›è»¢çªé€²ä¸­ã¯ç™½ãå…‰ã‚‹
          if(e.chargeGlow){
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.globalAlpha = 0.95;
          } else {
            ctx.fillStyle = '#666';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#888';
            ctx.globalAlpha = 0.9;
          }
          
          ctx.beginPath();
          ctx.moveTo(0, -shieldSize/2);
          ctx.lineTo(-shieldSize/2, shieldSize/2);
          ctx.lineTo(shieldSize/2, shieldSize/2);
          ctx.closePath();
          ctx.fill();
          
          // ç¸å–ã‚Š
          ctx.strokeStyle = e.chargeGlow ? '#fff' : '#aaa';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          ctx.restore();
        }
      }
      
      const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
      const bw = s * 1.2, bh = 6;
      const bx = e.x - bw/2, by = e.y - s/2 - 12;
      ctx.fillStyle = '#222'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ratio > 0.5 ? '#2ecc71' : ratio > 0.25 ? '#f1c40f' : '#e74c3c';
      ctx.fillRect(bx, by, bw * ratio, bh);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.strokeRect(bx, by, bw, bh);
      continue; // äºŒé‡æç”»ã‚’é˜²ã
    }
    else if(e.type==='shooter'){ ctx.fillStyle='#f39c12'; }
    else if(e.type==='mid'){ ctx.fillStyle='#00bcd4'; }
    else if(e.type==='final'){ ctx.fillStyle='#ffd700'; }
    else { ctx.fillStyle='#ff00aa'; }
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ã¦å½¢çŠ¶ã‚’å¤‰æ›´
    const currentStageData = STAGES[state.currentStage] || STAGES.stage1;
    if (currentStageData.shape === 'triangle') {
      // ä¸‰è§’å½¢ã§æç”»
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.beginPath();
      ctx.moveTo(0, -s/2);              // ä¸Šã®é ‚ç‚¹
      ctx.lineTo(-s/2, s/2);            // å·¦ä¸‹ã®é ‚ç‚¹
      ctx.lineTo(s/2, s/2);             // å³ä¸‹ã®é ‚ç‚¹
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else {
      // å››è§’å½¢ã§æç”»ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
      ctx.fillRect(e.x-s/2, e.y-s/2, s, s);
    }
    
    // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    if(e.hitFlash>0){
      ctx.save(); ctx.globalAlpha=e.hitFlash; ctx.fillStyle='#fff';
      if (currentStageData.shape === 'triangle') {
        ctx.translate(e.x, e.y);
        ctx.beginPath();
        ctx.moveTo(0, -s/2);
        ctx.lineTo(-s/2, s/2);
        ctx.lineTo(s/2, s/2);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.fillRect(e.x-s/2,e.y-s/2,s,s);
      }
      ctx.restore();
    }
    const ratio = Math.max(0, Math.min(1, e.hp / e.maxHp));
    const bw = s, bh = 4; const bx = e.x - bw/2, by = e.y - s/2 - 6;
    ctx.fillStyle = '#3a3a3a'; ctx.fillRect(bx, by, bw, bh);
    ctx.fillStyle = ratio>0.5 ? '#2ecc71' : ratio>0.25 ? '#f1c40f' : '#e74c3c';
    ctx.fillRect(bx, by, bw*ratio, bh);
    ctx.strokeStyle='#111'; ctx.lineWidth=1; ctx.strokeRect(bx, by, bw, bh);
    }
    }
  }

 // effects
for (const ef of state.effects) {
  // â˜…ãƒœã‚¹æ¶ˆå¤±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  if (ef.type === 'bossVanish') {
    const a = Math.max(0, ef.life / 0.6);
    const t = 1 - a;
    ctx.save();
    // ç´«ã®çˆ†ç™ºãƒªãƒ³ã‚°ï¼ˆè¤‡æ•°ï¼‰
    for(let ring = 0; ring < 3; ring++){
      const ringRadius = ef.r * (0.3 + t * 0.7) + ring * 30 * t;
      ctx.globalAlpha = (0.8 - ring * 0.2) * a;
      ctx.strokeStyle = ring === 0 ? '#a855f7' : (ring === 1 ? '#9333ea' : '#7c3aed');
      ctx.lineWidth = 12 - ring * 3;
      ctx.shadowBlur = 30;
      ctx.shadowColor = '#a855f7';
      ctx.beginPath();
      ctx.arc(ef.x, ef.y, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    }
    // ä¸­å¿ƒã®ç™½ã„ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    ctx.globalAlpha = a * a;
    const gradient = ctx.createRadialGradient(ef.x, ef.y, 0, ef.x, ef.y, ef.r * 0.5 * a);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
    gradient.addColorStop(0.5, 'rgba(168, 85, 247, 0.5)');
    gradient.addColorStop(1, 'rgba(147, 51, 234, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * 0.5 * a, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  // â˜…ç´«ã‚¹ãƒ‘ãƒ¼ã‚¯
  else if (ef.type === 'purpleSpark') {
    const a = Math.max(0, ef.life / 0.5);
    // ç§»å‹•
    ef.x += ef.vx * (1/60);
    ef.y += ef.vy * (1/60);
    ef.vx *= 0.95;
    ef.vy *= 0.95;
    ctx.save();
    ctx.globalAlpha = a;
    ctx.fillStyle = '#d8b4fe';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#a855f7';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, 6 * a, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  else if (ef.type === 'nova') {
    ctx.save();
    const life0 = 0.25;                 // ef.life ã¯ 0.25 ä»˜è¿‘ã‚’æƒ³å®š
    const a = Math.max(0, ef.life / life0);

    // å¤–è¼ªï¼ˆå¼·ã‚ã®ç™ºå…‰ï¼‹å¤ªã‚ï¼‰
    ctx.globalAlpha = 0.85 * a;
    ctx.strokeStyle = '#6fbaff';
    ctx.lineWidth = 6;
    ctx.shadowBlur = 18;
    ctx.shadowColor = '#9fd3ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.55), 0, Math.PI * 2);
    ctx.stroke();

    // ã†ã£ã™ã‚‰å¡—ã‚Š
    ctx.globalAlpha = 0.20 * a;
    ctx.fillStyle = '#6fbaff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.65), 0, Math.PI * 2);
    ctx.fill();

    // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆè¼ª
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.95 * a;
    ctx.strokeStyle = '#e7fbff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * (1 - a * 0.70), 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

} else if (ef.type === 'healText') {
  const a = Math.max(0, ef.life / (ef.life0 || 0.8)); // æ®‹å­˜ç‡
  const t = 1 - a;                                    // çµŒéç‡ 0â†’1
  // ã‚«ãƒ¡ãƒ©ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ "nova" ã®ç›´å‰ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨åŒã˜å¤‰æ•°ã‚’æµç”¨ã—ã¦ãã ã•ã„
  const ox = (state.cam && state.cam.x) || (state.viewX || 0);
  const oy = (state.cam && state.cam.y) || (state.viewY || 0);
  const sx = (ef.x - ox);
  const sy = (ef.y - oy) - (18 + 14 * t); // ä¸Šã«ãµã‚ã£ã¨
  ctx.save();
  ctx.globalAlpha = a;
  ctx.font = '700 16px system-ui, -apple-system, Segoe UI, Roboto';
  const txt = '+' + (ef.val % 1 === 0 ? ef.val.toFixed(0) : ef.val.toFixed(1));
  // ç¸å–ã‚Šâ†’å¡—ã‚Šï¼ˆè¦–èªæ€§UPï¼‰
  ctx.lineWidth = 3;
  ctx.strokeStyle = 'rgba(0,0,0,.55)';
  ctx.strokeText(txt, sx, sy);
  ctx.fillStyle = '#6ef08a'; // æ˜ã‚‹ã„ç·‘
  ctx.fillText(txt, sx, sy);
  ctx.restore();

  } else if (ef.type === 'aura') {
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#85c1ff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

} else if (ef.type === 'explosion') {
  // è¿‘æ¥çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  const a = Math.max(0, ef.life / 0.3);
  const t = 1 - a;
  
  ctx.save();
  ctx.globalAlpha = 0.6 * a;
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 8;
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ff0000';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r * (0.5 + t * 0.5), 0, Math.PI * 2);
  ctx.stroke();
  ctx.globalAlpha = 0.4 * a;
  ctx.fillStyle = '#ffaa00';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r * (0.3 + t * 0.4), 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

} else if (ef.type === 'bossBeamWarn') {
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.strokeStyle = '#ff0000';
  ctx.lineWidth = 3;
  ctx.setLineDash([10, 10]);
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(ef.x + Math.cos(ef.angle) * ef.length, ef.y + Math.sin(ef.angle) * ef.length);
  ctx.stroke();
  ctx.restore();

} else if (ef.type === 'bossBeam') {
  const a = Math.max(0, ef.life / 0.2);
  ctx.save();
  ctx.globalAlpha = a;
  ctx.strokeStyle = '#ff3333';
  ctx.lineWidth = ef.width;
  ctx.shadowBlur = 30;
  ctx.shadowColor = '#ff0000';
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(ef.x + Math.cos(ef.angle) * ef.length, ef.y + Math.sin(ef.angle) * ef.length);
  ctx.stroke();
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = ef.width * 0.5;
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(ef.x + Math.cos(ef.angle) * ef.length, ef.y + Math.sin(ef.angle) * ef.length);
  ctx.stroke();
  ctx.restore();

} else if (ef.type === 'dashWarn') {
  ctx.save();
  ctx.globalAlpha = 0.7;
  ctx.strokeStyle = '#ffff00';
  ctx.lineWidth = 4;
  ctx.setLineDash([15, 10]);
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#ffff00';
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(ef.x + Math.cos(ef.angle) * ef.length, ef.y + Math.sin(ef.angle) * ef.length);
  ctx.stroke();
  ctx.restore();

} else if (ef.type === 'bombWarn') {
  ctx.save();
  ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.02) * 0.3;
  ctx.strokeStyle = '#ff0000';
  ctx.lineWidth = 4;
  ctx.shadowBlur = 15;
  ctx.shadowColor = '#ff0000';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

} else if (ef.type === 'pillarArrow') {
  // â˜…æŸ±ã®é£›ã¶æ–¹å‘ã‚’ç¤ºã™çŸ¢å°
  ctx.save();
  ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.015) * 0.3;
  ctx.strokeStyle = '#ffff00';
  ctx.fillStyle = '#ffff00';
  ctx.lineWidth = 4;
  ctx.shadowBlur = 15;
  ctx.shadowColor = '#ffff00';
  
  // çŸ¢å°ã®ç·š
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(ef.targetX, ef.targetY);
  ctx.stroke();
  
  // çŸ¢å°ã®å…ˆç«¯ï¼ˆä¸‰è§’å½¢ï¼‰
  const arrowSize = 15;
  const angle = Math.atan2(ef.dirY, ef.dirX);
  ctx.beginPath();
  ctx.moveTo(ef.targetX, ef.targetY);
  ctx.lineTo(
    ef.targetX - Math.cos(angle - 0.4) * arrowSize,
    ef.targetY - Math.sin(angle - 0.4) * arrowSize
  );
  ctx.lineTo(
    ef.targetX - Math.cos(angle + 0.4) * arrowSize,
    ef.targetY - Math.sin(angle + 0.4) * arrowSize
  );
  ctx.closePath();
  ctx.fill();
  ctx.restore();

} else if (ef.type === 'sniperLaser') {
  // ã‚¹ãƒŠã‚¤ãƒ‘ãƒ¼ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ“ãƒ¼ãƒ 
  const a = Math.max(0, ef.life / 0.15);
  
  ctx.save();
  ctx.globalAlpha = a;
  
  // ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¼ãƒ ï¼ˆç™½ï¼‰
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = ef.width;
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ff0000';
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(
    ef.x + Math.cos(ef.angle) * ef.length,
    ef.y + Math.sin(ef.angle) * ef.length
  );
  ctx.stroke();
  
  // å¤–å´ã‚°ãƒ­ãƒ¼ï¼ˆèµ¤ï¼‰
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = ef.width * 2;
  ctx.globalAlpha = a * 0.5;
  ctx.beginPath();
  ctx.moveTo(ef.x, ef.y);
  ctx.lineTo(
    ef.x + Math.cos(ef.angle) * ef.length,
    ef.y + Math.sin(ef.angle) * ef.length
  );
  ctx.stroke();
  
  ctx.restore();

} else if (ef.type === 'playerLaser') {
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ“ãƒ¼ãƒ 
  const lifeMax = ef.awaken ? 0.15 : 0.12;
  const a = Math.max(0, ef.life / lifeMax);
  
  const endX = ef.x + Math.cos(ef.angle) * ef.length;
  const endY = ef.y + Math.sin(ef.angle) * ef.length;
  
  ctx.save();
  
  if(ef.awaken){
    // è¦šé†’æ™‚ï¼šè¶…è»½é‡ãªæç”»ï¼ˆshadowãªã—ï¼‰
    
    // å¤–å´ã‚°ãƒ­ãƒ¼ï¼ˆã‚·ã‚¢ãƒ³ï¼‰
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = ef.width * 2;
    ctx.globalAlpha = a * 0.5;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    // ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¼ãƒ ï¼ˆç™½ï¼‰
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = ef.width * 0.8;
    ctx.globalAlpha = a * 0.7;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
  } else {
    // é€šå¸¸æ™‚ï¼šã‚·ã‚¢ãƒ³ç³»
    
    // å¤–å´ã‚°ãƒ­ãƒ¼ï¼ˆã‚·ã‚¢ãƒ³ï¼‰
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = ef.width * 2.5;
    ctx.shadowBlur = 25;
    ctx.shadowColor = '#00ffff';
    ctx.globalAlpha = a * 0.4;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    // ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ¼ãƒ ï¼ˆç™½ï¼‰
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = ef.width;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    // ã‚³ã‚¢ï¼ˆæ˜ã‚‹ã„ä¸­å¿ƒï¼‰
    ctx.strokeStyle = '#aaffff';
    ctx.lineWidth = ef.width * 0.4;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
  }
  
  ctx.restore();

} else if (ef.type === 'slash') {
  const a = Math.max(0, ef.life / (ef.life0 || 0.18));
  ctx.save();
  ctx.translate(ef.x, ef.y);
  ctx.rotate(ef.ang);

  const R    = (ef.outer + ef.inner) * 0.5;
  // â˜… å¤ªã•ã®åŸºæº–ï¼š1/3ï¼ˆæ—¢ã«é©ç”¨ã—ã¦ã„ã‚‹ãªã‚‰ãã®ã¾ã¾ï¼‰
  const Wbase = (ef.outer - ef.inner) * 0.33;

  // â˜… é€£æ’ƒã®æ®µã«å¿œã˜ã¦å°‘ã—ã ã‘â€œå¼·èª¿â€
  const boost = ef.comboIdx ? Math.min(0.12 * ef.comboIdx, 0.24) : 0; // 2æ®µç›®=+0.12
  const W = Wbase * (1.0 + boost);          // å°‘ã—ã ã‘å¤ªã
  const span = ef.span;
  const LAYERS = 2; // è»½é‡åŒ–

  // --- å¤–å´ãƒ–ãƒ«ãƒ¼ã‚°ãƒ­ãƒ¼ ---
  ctx.globalAlpha = (0.45 + boost*0.6) * a;  // 2æ®µç›®ã¯å°‘ã—æ˜ã‚‹ã
  ctx.strokeStyle = '#4cc3ff';
  ctx.lineCap     = 'round';
  ctx.shadowBlur  = 10; // è»½é‡åŒ–
  ctx.shadowColor = '#9fd3ff';
  for (let i = 0; i < LAYERS; i++) {
    const t = i / (LAYERS - 1);
    const lw   = W * (0.52 - 0.36 * t);
    const trim = span * (0.06 + boost*0.02) * t; // ç«¯ã‚’å°‘ã—å¤šã‚ã«å‰Šã£ã¦åˆ‡ã‚Œå‘³UP
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.arc(0, 0, R, -span * 0.5 + trim, span * 0.5 - trim);
    ctx.stroke();
  }

  // --- ç™½ãƒã‚¤ãƒ©ã‚¤ãƒˆ ---
  ctx.shadowBlur  = 0;
  ctx.globalAlpha = (0.88 + boost*0.1) * a;
  ctx.strokeStyle = '#e8fbff';
  ctx.lineWidth   = Math.max(2, W * 0.18);
  ctx.beginPath();
  ctx.arc(0, 0, R, -span * 0.5 + span * (0.08 + boost*0.02), span * 0.5 - span * (0.08 + boost*0.02));
  ctx.stroke();

  ctx.restore();
// â˜…æ–°ãƒ–ãƒ¬ãƒ¼ãƒ‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆslashNewï¼‰- 3ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€shadowãªã—
} else if (ef.type === 'slashNew') {
  const progress = 1 - ef.life / ef.life0;
  ctx.save();
  ctx.translate(ef.x, ef.y);
  ctx.rotate(ef.ang);
  
  const R = ef.baseR + ef.expandDist * progress;
  const span = ef.span;
  
  const trailLength = 0.4;
  const headPos = progress * 1.3;
  const tailPos = Math.max(0, headPos - trailLength);
  
  if (headPos <= 1.3) {
    let startT = tailPos;
    let endT = Math.min(headPos, 1);
    
    if (ef.reverse) {
      startT = 1 - Math.min(headPos, 1);
      endT = 1 - tailPos;
    }
    
    const segments = 3;
    for (let i = 0; i < segments; i++) {
      const t = startT + (endT - startT) * i / (segments - 1);
      const nextT = startT + (endT - startT) * (i + 1) / (segments - 1);
      
      const angle = -span / 2 + span * t;
      const nextAngle = -span / 2 + span * Math.min(nextT, 1);
      
      const centerDist = Math.abs(t - 0.5) * 2;
      const thickness = 14 * (1 - centerDist * 0.6);
      
      let posInTrail = ef.reverse ? (1 - i / (segments - 1)) : (i / (segments - 1));
      const brightness = 0.4 + 0.6 * posInTrail;
      
      ctx.globalAlpha = brightness * (1 - progress * 0.3);
      ctx.strokeStyle = '#6cf';
      ctx.lineWidth = thickness;
      ctx.lineCap = 'butt';
      ctx.beginPath();
      ctx.arc(0, 0, R, angle, nextAngle);
      ctx.stroke();
    }
  }
  ctx.restore();

// â˜…æ”¾å°„ç·šã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆslashRayï¼‰
} else if (ef.type === 'slashRay') {
  const progress = 1 - ef.life / ef.life0;
  if (progress < 0.6) {
    ctx.save();
    const alpha = (0.6 - progress) / 0.6 * 0.5;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#6cf';
    ctx.lineWidth = 1.5;
    
    const spread = 0.3;
    const angles = [ef.ang - spread, ef.ang, ef.ang + spread];
    const len = ef.length * Math.min(1, progress * 3);
    
    for (const ang of angles) {
      ctx.beginPath();
      ctx.moveTo(ef.x, ef.y);
      ctx.lineTo(ef.x + Math.cos(ang) * len, ef.y + Math.sin(ang) * len);
      ctx.stroke();
    }
    ctx.restore();
  }

} else if (ef.type === 'poisonField') {
  ctx.save();
  const a = Math.max(0, ef.life / (ef.life0 || 5));
  // å¤–ã‚°ãƒ­ãƒ¼
  ctx.globalAlpha = 0.22 * a;
  ctx.fillStyle = '#7eff7e';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.fill();
  // å†…ã‚†ã‚‰ã
  ctx.globalAlpha = 0.10 * a;
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, ef.r*0.7 + Math.sin(state.t*2.2)*6, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();


  } else if (ef.type === 'aim') {
    // æ±ç”¨ã®èµ¤ç³»äºˆå‘Šç·šï¼ˆãƒœã‚¹dashãªã©ï¼‰
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ff66cc';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 6]);
    ctx.beginPath();
    ctx.moveTo(ef.x1, ef.y1);
    ctx.lineTo(ef.x2, ef.y2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

  } else if (ef.type === 'warning') {
    // å‡ºç¾äºˆå‘Šãƒãƒ¼ã‚«ãƒ¼ï¼ˆãƒœãƒ ãƒ»ãƒ¯ãƒ¼ãƒ—æ•µç”¨ï¼‰
    ctx.save();
    const a = Math.max(0, ef.life / 0.8); // é€æ˜åº¦ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼‰
    const pulse = 0.5 + 0.5 * Math.sin(state.t * 8); // ç‚¹æ»…åŠ¹æœ
    
    // å¤–å´ã®å††ï¼ˆç‚¹æ»…ï¼‰
    ctx.globalAlpha = (0.4 + 0.3 * pulse) * a;
    ctx.strokeStyle = ef.color || 'rgba(255,100,100,0.6)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 8]);
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // å†…å´ã®å¡—ã‚Šï¼ˆè–„ãï¼‰
    ctx.globalAlpha = 0.15 * a;
    ctx.fillStyle = ef.color || 'rgba(255,100,100,0.6)';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r * 0.8, 0, Math.PI * 2);
    ctx.fill();
    
    // ä¸­å¿ƒã®åå­—ãƒãƒ¼ã‚¯
    ctx.globalAlpha = (0.6 + 0.4 * pulse) * a;
    ctx.strokeStyle = ef.color || 'rgba(255,100,100,0.8)';
    ctx.lineWidth = 2;
    const crossSize = 15;
    ctx.beginPath();
    ctx.moveTo(ef.x - crossSize, ef.y);
    ctx.lineTo(ef.x + crossSize, ef.y);
    ctx.moveTo(ef.x, ef.y - crossSize);
    ctx.lineTo(ef.x, ef.y + crossSize);
    ctx.stroke();
    
    ctx.restore();

  } else if (ef.type === 'line') {
    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = '#ffcccc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ef.x, ef.y);
    ctx.lineTo(ef.x + ef.dx * 80, ef.y + ef.dy * 80);
    ctx.stroke();
    ctx.restore();

  } else if (ef.type === 'text') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life);
    ctx.fillStyle = (ef.color || '#fff');
    const fontSize = ef.size || 16;
    ctx.font = `bold ${fontSize}px system-ui`;
    ctx.fillText(ef.text, ef.x, ef.y - (1 - ef.life) * 20);
    ctx.restore();

} else if (ef.type === 'laserGhost') {
  // äºˆå‚™ç·šï¼šå¤ªã„åŠé€æ˜ã®å¸¯ã€‚çƒãŒå¤šãã¦ã‚‚è¦–èªã—ã‚„ã™ã„
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0â†’1 ã«æ­£è¦åŒ–

  // å¤–å´ã®ã‚„ã‚ã‚‰ã‹ã„â€œè‰²ã¤ããƒãƒ­â€
  ctx.globalAlpha = 0.35 * a;
  ctx.strokeStyle = '#7fd9ff';       // è–„ã„ã‚·ã‚¢ãƒ³ç³»
  ctx.lineWidth = (ef.w || 48) * 2;  // å¤–ãƒãƒ­ã¯å¤ªã‚
  ctx.shadowBlur = 28;
  ctx.shadowColor = '#90e4ff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // å†…å´ã®è»¸ï¼ˆã•ã‚‰ã«è–„ã„ï¼‰
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.22 * a;
  ctx.strokeStyle = '#dff6ff';
  ctx.lineWidth = (ef.w || 48);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  ctx.restore();

} else if (ef.type === 'laserBeam') {
  // ãƒ¬ãƒ¼ã‚¶ãƒ¼æœ¬ä½“ï¼šæ¥µå¤ªãƒ»é«˜è¼åº¦ã€‚Î±æ­£è¦åŒ–ï¼‹å¤ªã•å¢—ã—
  ctx.save();
  const life0 = 0.06;
  const a = Math.max(0, ef.life / life0); // 0â†’1 ã«æ­£è¦åŒ–

  // å¤–å´ã®å¼·ã„å…‰
  ctx.globalAlpha = 0.95 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = (ef.w || 48) * 3; // ã•ã‚‰ã«å¤ªã
  ctx.shadowBlur = 32;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();

  // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1.0 * a;
  ctx.strokeStyle = '#f5fbff';
  ctx.lineWidth = Math.max(8, ((ef.w || 48) * 3) - 8);
  ctx.beginPath();
  ctx.moveTo(ef.x1, ef.y1);
  ctx.lineTo(ef.x2, ef.y2);
  ctx.stroke();
  ctx.restore();

  } else if (ef.type === 'whiteCharge') {
    // çˆ†ç™ºäºˆå‚™å‹•ä½œï¼šç™½ãå¼·ãå…‰ã‚‹ç‰
    ctx.save();
    const a = Math.max(0, ef.life); // 1 â†’ 0
    const r = ef.r0 + (1 - a) * (ef.r1 - ef.r0);

    // å¡—ã‚Šï¼ˆç™½ï¼‰
    ctx.globalAlpha = 0.35 + 0.45 * a;
    ctx.fillStyle = '#ffffff';
    ctx.shadowBlur = 28;
    ctx.shadowColor = '#ffffff';
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r * 0.92, 0, Math.PI * 2);
    ctx.fill();

    // è¼ªéƒ­ï¼ˆç™½ï¼‰
    ctx.globalAlpha = 0.9;
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();

} else if (ef.type === 'megaNova') {
  // æœ¬çˆ†ç™ºï¼šã§ã‹ã„å…‰è¼ªï¼‹æ·¡ã„å¡—ã‚Šã€å°‘ã—é•·ã‚
  ctx.save();
  const a = Math.max(0, ef.life); // 0.9 â†’ 0
  const R = ef.r * (1 - a * 0.5);

  // å¤–è¼ªï¼ˆå¼·ç™ºå…‰ï¼‰
  ctx.globalAlpha = 0.95 * a;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth = 12;
  ctx.shadowBlur = 36;
  ctx.shadowColor = '#fffbe3';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, R, 0, Math.PI * 2);
  ctx.stroke();

  // å¡—ã‚Š
  ctx.globalAlpha = 0.28 * a;
  ctx.fillStyle = '#fff1b3';
  ctx.beginPath();
  ctx.arc(ef.x, ef.y, R * 0.95, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();


} else if (ef.type === 'whitePulse') {
  // äºˆå‚™ãƒ‘ãƒ«ã‚¹ï¼šå°ã•ãç™½ãå…‰ã‚‹ç‰ï¼ˆcharge_boomã§ä½¿ç”¨ï¼‰
  ctx.save();
  const a = Math.max(0, ef.life / 0.06);           // 0â†’1
  const r = ef.r0 + (ef.r1 - ef.r0) * (1 - a);     // ã ã‚“ã ã‚“å°â†’å¤§ ã§ã‚‚ OKï¼ˆå¥½ã¿ï¼‰
  ctx.globalAlpha = 0.4 * a;
  ctx.fillStyle = '#ffffff';
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ffffff';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r * 0.9, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.9 * a;
  ctx.shadowBlur = 0;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.arc(ef.x, ef.y, r, 0, Math.PI*2); ctx.stroke();
  ctx.restore();

} else if (ef.type === 'boomWave') {
  // åŠé€æ˜ã®â€œæ‹¡å¤§ãƒªãƒ³ã‚°â€ + ç ´ç·šã§éš™é–“ã‚’ä½œã‚‹
  ctx.save();
  const a = Math.max(0, ef.life / (ef.life0 || 0.06));
  const w = ef.w || 24;

  // å¤–å´ãƒãƒ­ï¼ˆãã®ã¾ã¾ï¼‰
  ctx.globalAlpha = 0.28 * a;
  ctx.strokeStyle = '#ffd27a';
  ctx.lineWidth = w * 1.6;
  ctx.shadowBlur = 24;
  ctx.shadowColor = '#ffe4ad';
  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // â˜… ä¸»ãƒªãƒ³ã‚°ã‚’ç ´ç·šã«ã™ã‚‹ï¼ˆãƒ€ãƒƒã‚·ãƒ¥é–“éš”ã¯å¥½ã¿ã§èª¿æ•´ï¼‰
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9 * a;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth = w;

  // ç ´ç·šï¼ˆä¾‹ï¼šæ18px / ç©º16pxï¼‰ã€‚å›è»¢ã•ã›ã¦â€œæ³¢â€ã£ã½ã
  const dash = 18, gap = 16;
  ctx.setLineDash([dash, gap]);
  ctx.lineDashOffset = -state.t * 120; // æ™‚é–“ã§æµã‚Œã‚‹

  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // å†…ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆã“ã¡ã‚‰ã¯ç´°ç ´ç·šã«ã—ã¦ã‚‚OKï¼ç„¡åœ°ã§ã‚‚OKï¼‰
  ctx.globalAlpha = 0.85 * a;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = Math.max(4, w - 6);
  ctx.setLineDash([12, 14]);
  ctx.lineDashOffset = -state.t * 160;

  ctx.beginPath(); ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI*2); ctx.stroke();

  // å¾Œå§‹æœ«
  ctx.setLineDash([]);
  ctx.restore();

} else if (ef.type === 'boomWaveSeg') {
  // è§’åº¦æ–¹å‘ã«å¤§ããªâ€œç©´â€ã‚’é–‹ã‘ãŸã€æ³¢æ‰“ã¤ãƒªãƒ³ã‚°
  ctx.save();
  const life0 = 0.06;
  const alpha = Math.max(0, ef.life / life0);
  const segCount = Math.max(3, ef.segCount|0);
  const gapFrac  = Math.max(0, Math.min(0.9, ef.gapFrac||0.35));
  const rot      = ef.rot || 0;
  const w        = ef.w || 20;
  const amp      = ef.wavAmp || 8;
  const freq     = Math.max(1, ef.wavFreq|0);
  const phase    = (ef.phase || 0) * 2.2; // æ³¢ã‚¢ãƒ‹ãƒ¡

  const cx = ef.x, cy = ef.y;
  const segSpan = (Math.PI*2)/segCount;
  const gapSpan = segSpan*gapFrac;
  const drawSpan= segSpan-gapSpan;

  // å¤–ãƒãƒ­
  ctx.globalAlpha = 0.26 * alpha;
  ctx.strokeStyle = '#ffd27a';
  ctx.lineWidth   = w * 1.5;
  ctx.shadowBlur  = 22;
  ctx.shadowColor = '#ffe4ad';

  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;      // ç©´ã®å¾Œã‚ã‹ã‚‰æãå§‹ã‚
    const a1 = a0 + drawSpan;

    // ãƒãƒªãƒ©ã‚¤ãƒ³ã§â€œæ³¢â€åŠå¾„ã‚’ä¸ãˆã‚‹
    ctx.beginPath();
    const steps = 28;                           // ãªã‚ã‚‰ã‹ã•
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp; // åŠå¾„ã‚’æ³¢æ‰“ãŸã›ã‚‹
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // ä¸»ãƒªãƒ³ã‚°
  ctx.shadowBlur  = 0;
  ctx.globalAlpha = 0.9 * alpha;
  ctx.strokeStyle = '#fff4c1';
  ctx.lineWidth   = w;
  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;
    const a1 = a0 + drawSpan;
    ctx.beginPath();
    const steps = 28;
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // å†…ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  ctx.globalAlpha = 0.85 * alpha;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth   = Math.max(4, w-6);
  for(let s=0;s<segCount;s++){
    const a0 = rot + s*segSpan + gapSpan;
    const a1 = a0 + drawSpan;
    ctx.beginPath();
    const steps = 28;
    for(let i=0;i<=steps;i++){
      const t = i/steps;
      const a = a0 + (a1-a0)*t;
      const r = ef.r + Math.sin(a*freq + phase)*amp;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  ctx.restore();

  } else if (ef.type === 'bossExplode') {
    // ãƒœã‚¹æ’ƒç ´æ¼”å‡ºï¼šç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼‹å¤šé‡ãƒªãƒ³ã‚°
    ctx.save();
    const a = Math.max(0, ef.life / (ef.life0 || 0.8));

    // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
    ctx.globalAlpha = 0.4 * a;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);

    // è¤‡æ•°ãƒªãƒ³ã‚°
    const rings = [
      { color: '#fff2b3', w: 16, blur: 24, mul: 1.00 },
      { color: '#ffe680', w: 10, blur: 16, mul: 0.75 },
      { color: '#ffd24d', w: 6,  blur: 10, mul: 0.55 },
    ];
    for (const r of rings) {
      ctx.globalAlpha = 0.9 * a;
      ctx.strokeStyle = r.color;
      ctx.lineWidth = r.w;
      ctx.shadowBlur = r.blur;
      ctx.shadowColor = r.color;
      ctx.beginPath();
      ctx.arc(ef.x, ef.y, ef.R * (1 - a * 0.7) * r.mul, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();

  } else if (ef.type === 'flash') {
    ctx.save();
    ctx.globalAlpha = Math.max(0, ef.life * 0.8);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, cv.width / DPR, cv.height / DPR);
    ctx.restore();

    } else if (ef.type === 'healSparkles') {
    ctx.save();
    const a = Math.max(0, (ef.life0 ? (ef.life / ef.life0) : ef.life)); // 0â†’1
    const prog = 1 - a;
    const n = ef.count || 12;
    for (let i = 0; i < n; i++) {
      const th = (i / n) * Math.PI * 2;
      const rr = (ef.r || 40) * (0.3 + 0.8 * prog);
      const x = ef.x + Math.cos(th) * rr;
      const y = ef.y + Math.sin(th) * rr;

      // æœ¬ä½“ï¼ˆç·‘ï¼‰
      ctx.globalAlpha = 0.85 * a;
      ctx.fillStyle = '#34d399';
      ctx.beginPath(); ctx.arc(x, y, 3.2, 0, Math.PI * 2); ctx.fill();

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç™½å¯„ã‚Šï¼‰
      ctx.globalAlpha = 0.9 * a;
      ctx.fillStyle = '#eafff1';
      ctx.beginPath(); ctx.arc(x - 0.8, y - 0.8, 1.6, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
 }else if (ef.type === 'zig') {
  // ç¨²å¦»ï¼ˆãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ï¼‰â€” é’é»’ç³»ã§ã‚„ã‚„è½ã¡ç€ã„ãŸç™ºå…‰
  const pts = ef.path;
  if (!pts || pts.length < 2) { continue; }

  ctx.save();
  const a = Math.max(0, ef.life / 0.22);

  // å°‘ã—æŠ‘ãˆã‚ã®å…¨ä½“ã‚¢ãƒ«ãƒ•ã‚¡
  ctx.globalAlpha = 0.78 * a;

  // å¤–å´ï¼ˆæœ¬ä½“ï¼‰ï¼šãã™ã‚“ã é’ã€å¼±ã‚ã®ã‚°ãƒ­ãƒ¼
  ctx.strokeStyle = '#6a93c2';   // é’é»’å¯„ã‚Š
  ctx.lineWidth   = ef.thick;
  ctx.lineJoin    = 'round';
  ctx.shadowBlur  = 10;          // 14 â†’ 10ï¼ˆã¾ã¶ã—ã•è»½æ¸›ï¼‰
  ctx.shadowColor = '#3c5b86';   // æš—ã„é’ã®å…‰
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.stroke();

  // å†…å´ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼šç™½ã§ã¯ãªãæ·¡ã„é’ã§ç›®ã«å„ªã—ã
  ctx.shadowBlur  = 0;
  ctx.lineWidth   = Math.max(2, ef.thick - 2);
  ctx.globalAlpha = 0.72 * a;    // 0.9 â†’ 0.72
  ctx.strokeStyle = '#b7cbea';   // æ·¡ã„é’
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.stroke();

  ctx.restore();
}   }
  } catch (err) {
    showErrorBanner(err.stack || err.message || String(err));
    throw err; // loop å´ã§ã‚‚æ‹¾ãˆã‚‹ã‚ˆã†ã«
  }
  
if (scoreVal) scoreVal.textContent = Math.floor(state.score || 0);  

// â–²â–² ãƒ¯ãƒ¼ãƒ«ãƒ‰æç”»çµ‚ã‚ã‚Šï¼ˆHUDã‚’ç­‰å€ã«æˆ»ã™ï¼‰ â–²â–²
ctx.restore();

// â–¼ ã“ã®ä¸‹ã§HUD/UIï¼ˆç­‰å€ï¼‰ã‚’æãï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
} // â† function draw ã®é–‰ã˜ã‚«ãƒƒã‚³

// ===== ã“ã“ã‹ã‚‰ä¸‹ã¯ãƒ˜ãƒ«ãƒ‘ =====

// === é›‘é­šï¼ˆminion/shooterï¼‰ã ã‘ã‚’æ•°ãˆã‚‹ç¾åœ¨æ•° ===
function countTrash() {
  let n = 0;
  for (const e of state.enemies) {
    if (e.type === 'minion' || e.type === 'shooter') n++;
  }
  return n;
}

// === æ™‚é–“ã«å¿œã˜ãŸåŒæ™‚å‡ºç¾ã®ä¸Šé™ï¼ˆåºç›¤ã¯ä½ã„ï¼‰ ===
function currentTrashCap(tSec) {
  // 0â€“60s: 10ä½“, 60â€“120s: 14, 120â€“180s: 18, 180â€“240s: 24
  // 240â€“360s: 30, 360sä»¥é™: å¾ã€…ã«48ã¾ã§
  if (tSec < 60)   return 10;
  if (tSec < 120)  return 18;
  if (tSec < 180)  return 25;
  if (tSec < 240)  return 40;
  if (tSec < 360)  return 60;
  // 6åˆ†ä»¥é™ã¯å°‘ã—ãšã¤ä¸Šé™â†‘ï¼ˆæœ€å¤§150ï¼‰
  return Math.min(150, 30 + Math.floor((tSec - 360) / 20));
}

function normAngle(a){
  // 0..2PI ã«æ­£è¦åŒ–
  const PI2 = Math.PI*2;
  return ((a % PI2) + PI2) % PI2;
}

// ãƒªãƒ³ã‚°ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆâ€œéš™é–“â€å†…ã«è§’åº¦ãŒå…¥ã£ã¦ã„ã‚‹ã‹ï¼Ÿ
function angleInGap(angle, wv){
  // segCount ã§ 0..2PI ã‚’ç­‰åˆ†ã—ã€å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å…ˆé ­å´ gapFrac ã‚’â€œç©´â€ã¨ã¿ãªã™
  const A = normAngle(angle - (wv.rot||0));
  const segSpan = (Math.PI*2) / wv.segCount;
  const idx = Math.floor(A / segSpan);
  const local = A - idx*segSpan;          // 0..segSpan
  const gapSpan = segSpan * wv.gapFrac;   // â˜… éš™é–“ã®è§’åº¦å¹…
  return local < gapSpan;                  // å…ˆé ­å´ã«â€œç©´â€
}


function pointLineDist(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const denom = Math.max(1e-6, vx * vx + vy * vy);
  const t = Math.max(0, Math.min(1, (vx * wx + vy * wy) / denom));
  const dx = x1 + vx * t - px, dy = y1 + vy * t - py;
  return Math.hypot(dx, dy);
}

// â€» æ—§ç‰ˆã®triggerFinalExplosion ã¯å‰Šé™¤ï¼ˆä¸‹ã®finalExplosionAndClearã«çµ±åˆæ¸ˆã¿ï¼‰


function showGameClear(){
  const el = document.getElementById('gameclear');
  const hardcoreBtn = document.getElementById('hardcoreBtn');
  if (el){
    // ã‚¯ãƒªã‚¢ã§è§£æ”¾
    state.mode.unlockedHardcore = true;
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸1ã‚¯ãƒªã‚¢ã§ã‚¹ãƒ†ãƒ¼ã‚¸2è§£æ”¾
    if (state.currentStage === 'stage1') {
      const saveData = window.loadSaveData();
      if (!saveData.stageProgress) saveData.stageProgress = {};
      if (!saveData.stageProgress.stage1) saveData.stageProgress.stage1 = {};
      saveData.stageProgress.stage1.cleared = true;
      window.saveSaveData(saveData);
      STAGES.stage2.unlocked = true;
    }
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸2ã‚¯ãƒªã‚¢ã‚‚è¨˜éŒ²
    if (state.currentStage === 'stage2') {
      const saveData = window.loadSaveData();
      if (!saveData.stageProgress) saveData.stageProgress = {};
      if (!saveData.stageProgress.stage2) saveData.stageProgress.stage2 = {};
      saveData.stageProgress.stage2.cleared = true;
      window.saveSaveData(saveData);
    }

    el.style.display = 'flex';
    state.paused = true;
    
    // ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨åœæ­¢
    state.enemies.length = 0;
    state.enemyBullets.length = 0;
    state.items.length = 0;
    state.spawnTimer = 9999999;
    state.bossTimer = 9999999;
    state.bigBossTimer = 9999999;
    
    ensureEndScoreNodes();
    updateEndScore('clear');

    // ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾ã‚’ãƒªã‚»ãƒƒãƒˆ
    window._unlockedThisSession = [];
    
    // å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
    checkAchievementsOnClear();
    
    // è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾ã‚’è¡¨ç¤º
    displayUnlockedAchievements();

    // ã‚¹ã‚³ã‚¢ä¿å­˜ï¼ˆãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯è‡ªå‹•è¡¨ç¤ºã—ãªã„ï¼‰
    const scoreData = createScoreData('clear');
    saveScore(scoreData);

    // ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
    if (hardcoreBtn){
      hardcoreBtn.style.display = 'inline-block';
      hardcoreBtn.onclick = () => {
        // ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¶ˆå»
        const rankingModal = document.getElementById('rankingModal');
        if (rankingModal) rankingModal.remove();
        
        // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        state.gameover = false;
        
        state.mode.hardcore = true;  // æ¬¡ã®å‘¨å›ã‚’ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã«
        el.style.display = 'none';
        resetGame();
        syncPauseButton();
        addEffect('text', { x: state.player.x, y: state.player.y, life: 1.4, text: 'HARDCORE START' });
      };
    }
  }else{
    state.paused = true;
    alert('GAME CLEAR');
  }
}

// è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
function displayUnlockedAchievements() {
  const unlockedList = window._unlockedThisSession || [];
  const achievementsArea = document.getElementById('clearAchievements');
  const achievementsList = document.getElementById('clearAchievementsList');
  
  if (!achievementsArea || !achievementsList) return;
  
  if (unlockedList.length === 0) {
    achievementsArea.style.display = 'none';
    return;
  }
  
  // è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
  achievementsArea.style.display = 'block';
  achievementsList.innerHTML = '';
  
  // å„å®Ÿç¸¾ã‚’è¡¨ç¤º
  for (const achId of unlockedList) {
    const achievement = ACHIEVEMENTS[achId];
    if (!achievement) continue;
    
    const item = document.createElement('div');
    item.style.cssText = `
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      font-size: 0.9rem;
    `;
    
    // ãƒ†ã‚£ã‚¢ã«å¿œã˜ãŸè‰²
    const tierColors = {
      bronze: '#cd7f32',
      silver: '#c0c0c0',
      gold: '#ffd700',
      platinum: '#e5e4e2'
    };
    const color = tierColors[achievement.tier] || '#fff';
    
    item.innerHTML = `
      <span style="font-size:1.5rem;">${achievement.icon}</span>
      <div style="flex:1;">
        <div style="font-weight:700; color:${color};">${achievement.name}</div>
        <div style="font-size:0.85rem; opacity:0.9;">${achievement.desc}</div>
      </div>
    `;
    
    achievementsList.appendChild(item);
  }
}

// === safeKillEnemy: æœ€çµ‚ç‰ˆï¼ˆfinalã§CLEARã¸ï¼‰ ===
function safeKillEnemy(idxOrEnemy){
  const e = (typeof idxOrEnemy === 'number') ? (state.enemies && state.enemies[idxOrEnemy]) : idxOrEnemy;
  if (!e || e.dead) return;

  try { if (typeof addEffect === 'function') addEffect('pop', { x:e.x, y:e.y }); } catch(_){}

// ---- çµ±ä¸€ã‚­ãƒ«ã‚«ã‚¦ãƒ³ãƒˆï¼ˆé‡è¤‡é˜²æ­¢ï¼‰----
if (!e._counted) {
  const isBoss = (e.type === 'mid' || e.type === 'big' || e.type === 'final');
  if (isBoss) {
    state.bossKills = (state.bossKills|0) + 1;
  } else {
    state.kills = (state.kills|0) + 1;
  }
  e._counted = true; // å¼¾ãƒ»å³æ­»ãƒ»å¤šçµŒè·¯ã§ã‚‚äºŒé‡åŠ ç®—ã‚’é˜²ã
  
  // å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
  checkKillAchievements(e);
}

  if (e.type === 'final') {
    playKillSound('final'); // ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ãƒœã‚¹åŠ¹æœéŸ³
    state.paused = true; // ç”»é¢ã‚’ä¸€æ™‚åœæ­¢
    try { finalExplosionAndClear(e.x, e.y); } catch(_){}
    try {
      state.enemies.length = 0;
      if (state.enemyBullets) state.enemyBullets.length = 0;
      if (state.items) state.items.length = 0;
      state.spawnTimer = 9999999;
      state.bossTimer = 9999999;
      state.bigBossTimer = 9999999;
    } catch(_){}
  } else if (e.type === 'big') {
    playKillSound('big'); // å¤§ãƒœã‚¹åŠ¹æœéŸ³
    state.paused = true; // ç”»é¢ã‚’ä¸€æ™‚åœæ­¢
    setTimeout(() => { state.paused = false; }, 800); // 0.8ç§’å¾Œã«å†é–‹
    const pos = adjustDropPosition(e.x, e.y, 16);
    state.items.push({ kind:'chest', x:pos.x, y:pos.y, r:16, t:0, picks:2 });
    try { addEffect('text', { x:e.x, y:e.y, life:1.2, text:'å®ç®±Ã—2ï¼' }); } catch(_){}
  } else if (e.type === 'mid') {
    playKillSound('mid'); // ä¸­ãƒœã‚¹åŠ¹æœéŸ³
    state.paused = true; // ç”»é¢ã‚’ä¸€æ™‚åœæ­¢
    setTimeout(() => { state.paused = false; }, 500); // 0.5ç§’å¾Œã«å†é–‹
    const pos = adjustDropPosition(e.x, e.y, 14);
    state.items.push({ kind:'chest', x:pos.x, y:pos.y, r:14, t:0, picks:1 });
  } else {
    playKillSound('normal'); // é€šå¸¸æ•µåŠ¹æœéŸ³
    // â˜…noXpDropãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯çµŒé¨“å€¤ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ãªã„
    if (!e.noXpDrop) {
      try { dropGem(e.x, e.y, 1); } catch(_){}
    }
  }

  e.dead = true; e.hp = 0;
  try {
    const i = state.enemies ? state.enemies.indexOf(e) : -1;
    if (i >= 0) state.enemies.splice(i, 1);
  } catch(_){}
}




// ---- Heal helpers (robust, single source of truth) ----
function _getPlayer() {
  // ã©ã¡ã‚‰ã‹ã‹ã‚‰ç¢ºå®Ÿã«å–ã‚‹ï¼ˆä»Šå¾Œã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ã§ã‚‚å£Šã‚Œã«ããï¼‰
  const ws = (typeof window !== 'undefined' ? window.state : null);
  if (ws && ws.player) return ws.player;
  if (typeof state !== 'undefined' && state && state.player) return state.player;
  return null;
}

// å®Ÿæ•°å›å¾©ï¼ˆå¢—ãˆãŸâ€œå®Ÿé‡â€ã‚’è¿”ã™ï¼š0 ã®ã¨ãã¯æº€ã‚¿ãƒ³ï¼‰
function healPlayer(v){
  const p = _getPlayer();
  if (!p) return 0;
  const maxHp = p.maxHp ?? p.hpMax ?? p.hp_max ?? p.maxHP ?? 100;
  const before = Number.isFinite(p.hp) ? p.hp : maxHp;
  const add    = Math.max(0, Number(v) || 0);
  if (add <= 0) return 0;
  const after  = Math.min(maxHp, before + add);
  p.hp = after;
  const gained = after - before;
  return (Number.isFinite(gained) && gained > 0) ? gained : 0;
}

// æœ€å¤§HPã«å¯¾ã™ã‚‹ % å›å¾©ï¼ˆå¢—ãˆãŸâ€œå®Ÿé‡â€ã‚’è¿”ã™ï¼‰
function healPlayerPercent(percent){
  const p = _getPlayer();
  if (!p) return 0;
  const maxHp = p.maxHp ?? p.hpMax ?? p.hp_max ?? p.maxHP ?? 100;
  const pct = Math.max(0, Number(percent) || 0) / 100;
  if (!(pct > 0)) return 0;
  return healPlayer(maxHp * pct);
}

// === NOVA å›å¾©ãƒ¬ãƒ¼ãƒˆ ===
function _getNovaLevel(){
  return (state?.weapons?.nova?.lv)
      ?? (state?.wlv?.nova)
      ?? (state?.wepLevel?.nova)
      ?? (state?.wep?.nova?.lv)
      ?? 1; // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°LV1æ‰±ã„
}
function _isNovaAwakened(){
  return !!((state?.weapons?.nova?.awakened)
         || (state?.weapons?.nova?.isAwaken)
         || (state?.awaken?.nova)
         || (state?.wep?.nova?.awakened));
}
/** ãƒãƒ´ã‚¡ã®â€œãƒ’ãƒƒãƒˆæ™‚â€ã«ä½¿ã†å›å¾©ï¼…ï¼ˆæ•´æ•°ï¼…ã‚’è¿”ã™ï¼‰ */
function getNovaHitHealPercent(){
  if (_isNovaAwakened()) return 3; // è¦šé†’ï¼šãƒ’ãƒƒãƒˆæ™‚ã¯4%
  const lv = _getNovaLevel();
  if (lv >= 3) return 3;  // LV3
  if (lv === 2) return 2.5; // LV2
  return 2;               // LV1
}


// === Unified final explosion & clear ===
function finalExplosionAndClear(x, y){
  try { addEffect('flash', { life: .06 }); } catch(_){}
  try {
    const W = cv.width, H = cv.height, DPR = window.devicePixelRatio||1;
    addEffect('megaNova', { x, y, r: Math.hypot(W/DPR, H/DPR)*0.85, life: 0.9 });
    for (let k = 0; k < 22; k++) spark(x + (Math.random()-0.5)*30, y + (Math.random()-0.5)*30, 18);
  } catch(_){}

  // === BOSS TIME BONUSï¼ˆ1å›ã ã‘ï¼‰ ===
  if (!state._finalBonusAwarded){
    const spawnAt = Number.isFinite(state.finalSpawnAt) ? state.finalSpawnAt : (state.timeSec||0);
    const now     = state.timeSec || 0;
    const took    = Math.max(0, now - spawnAt);

    const MAX_BONUS = 30000; // æœ€é€Ÿæ’ƒç ´
    const FULL_TIME = 15;    // ã“ã“ã¾ã§æº€é¡
    const ZERO_TIME = 90;    // ã“ã“ã‚’éãã‚‹ã¨0
    let ratio = 0;
    if (took <= FULL_TIME)       ratio = 1;
    else if (took >= ZERO_TIME)  ratio = 0;
    else                         ratio = (ZERO_TIME - took) / (ZERO_TIME - FULL_TIME);

    const bonus = Math.max(0, Math.round(MAX_BONUS * ratio));
    state.bossBonus = (state.bossBonus|0) + bonus;
    state.score     = (state.score|0)     + bonus;
    state._finalBonusAwarded = true;

    try { addEffect('text', { x, y, life: 1.3, text: `BOSS TIME BONUS +${bonus.toLocaleString()}` }); } catch(_){}
  }

  // å°‘ã—è¦‹ã›ã¦ã‹ã‚‰CLEAR
  state.winCountdown = 1.2;
  state._winLast = performance.now?.() || 0;
  state.paused = false;
}

// æ—§åã§å‘¼ã°ã‚Œã¦ã‚‚å¿…ãšåŒã˜å‡¦ç†ã«æµã™
function triggerFinalExplosion(x, y){
  return finalExplosionAndClear(x, y);
}

function gameOver(){
  state.paused = true;
  // â–¼ XPå›åã®æ®‹ã‚Šã‚’å¼·åˆ¶åœæ­¢
  state.gather.active = false;
  state.gather.time = 0;
  state.gather.totalXP = 0;
if (gatherEl) gatherEl.style.display='none';
  // â–¼ ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼†ç„¡æ•µã‚‚åœæ­¢
  state.player.kbx = state.player.kby = 0;
  state.player.iTime = 0;
  
  // ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾ã‚’ãƒªã‚»ãƒƒãƒˆ
  window._unlockedThisSession = [];
  
  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯ï¼ˆè¨ä¼æ•°ãªã©ï¼‰
  checkKillAchievements();
  
  // è§£é™¤ã•ã‚ŒãŸå®Ÿç¸¾ã‚’è¡¨ç¤ºï¼ˆã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç‰ˆï¼‰
  displayUnlockedAchievementsGameover();
  
  goEl.style.display='flex';
}

// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®å®Ÿç¸¾è¡¨ç¤º
function displayUnlockedAchievementsGameover() {
  const unlockedList = window._unlockedThisSession || [];
  const achievementsArea = document.getElementById('gameoverAchievements');
  const achievementsList = document.getElementById('gameoverAchievementsList');
  
  if (!achievementsArea || !achievementsList) return;
  
  if (unlockedList.length === 0) {
    achievementsArea.style.display = 'none';
    return;
  }
  
  // è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º
  achievementsArea.style.display = 'block';
  achievementsList.innerHTML = '';
  
  // å„å®Ÿç¸¾ã‚’è¡¨ç¤º
  for (const achId of unlockedList) {
    const achievement = ACHIEVEMENTS[achId];
    if (!achievement) continue;
    
    const item = document.createElement('div');
    item.style.cssText = `
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      font-size: 0.9rem;
    `;
    
    // ãƒ†ã‚£ã‚¢ã«å¿œã˜ãŸè‰²
    const tierColors = {
      bronze: '#cd7f32',
      silver: '#c0c0c0',
      gold: '#ffd700',
      platinum: '#e5e4e2'
    };
    const color = tierColors[achievement.tier] || '#fff';
    
    item.innerHTML = `
      <span style="font-size:1.5rem;">${achievement.icon}</span>
      <div style="flex:1;">
        <div style="font-weight:700; color:${color};">${achievement.name}</div>
        <div style="font-size:0.85rem; opacity:0.9;">${achievement.desc}</div>
      </div>
    `;
    
    achievementsList.appendChild(item);
  }
}

// Final Boss spawn
function spawnFinalBoss(){
  const B = worldBounds();
  const margin = 120;
  const side = Math.floor(Math.random()*4);
  let x, y;

  if (side === 0){ x = rnd(B.minX - margin, B.maxX + margin); y = B.minY - margin; }
  else if (side === 1){ x = B.maxX + margin; y = rnd(B.minY - margin, B.maxY + margin); }
  else if (side === 2){ x = rnd(B.minX - margin, B.maxX + margin); y = B.maxY + margin; }
  else { x = B.minX - margin; y = rnd(B.minY - margin, B.maxY + margin); }

  const base = 1500 + state.difficulty*300;
  const hp0  = base * 10;
  // â˜…ã‚¹ãƒ†ãƒ¼ã‚¸2ã¯HP60%ã«ï¼ˆ80%ã‹ã‚‰ã•ã‚‰ã«20%æ¸›ï¼‰
  const hpMul = state.currentStage === 'stage2' ? 0.6 : 1.0;
  const hp   = (state.mode.hardcore ? hp0 * 1.5 : hp0) * hpMul; // â˜…ãƒãƒ¼ãƒ‰ã‚³ã‚¢ã¯HP1.5å€ï¼ˆ1.3â†’1.5ï¼‰

  const e = {
    x, y,
    size: state.currentStage === 'stage2' ? 200 : 84*2, // â˜…100â†’200ï¼ˆ2å€ï¼‰
    hp, maxHp: hp, speed: state.currentStage === 'stage2' ? 40 : 70, type: 'final', // â˜…é…ã
    phase: 'shoot', cd: 0, tele: 0, dashCD: 5.5, dashDir: {x:0, y:0},
    patternCD: 4.5, blastCharge: 0, blastR: 220, laserAng: 0,
    laserAimT: 0, laserDur: 0, hitFlash: 0,
    kbx: 0, kby: 0,
    // ã‚¹ãƒ†ãƒ¼ã‚¸2ç”¨ï¼ˆæ–°ãƒ©ã‚¹ãƒœã‚¹ï¼‰
    isTriangle: state.currentStage === 'stage2',
    isGhost: state.currentStage === 'stage2',
    rotation: 0, alpha: 0.85, // â˜…ã‚ˆã‚Šè¦‹ãˆã‚„ã™ã
    // â˜…æ–°æ”»æ’ƒï¼šãƒ›ãƒ¼ãƒŸãƒ³ã‚°å…‰çƒ
    orbCd: 3, orbInterval: 5.0,
    // â˜…æ–°æ”»æ’ƒï¼š12ç®‡æ‰€çˆ†æ’ƒ
    bombCd: 6, bombInterval: 10.0, bombPhase: 'idle', bombWarnTime: 0, bombTargets: [],
    // â˜…æ–°æ”»æ’ƒï¼šæŸ±é£›ã°ã—
    pillarCd: 15, pillarInterval: 20.0, pillarPhase: 'idle', pillarChargeTime: 0,
    // â˜…æ–°æ”»æ’ƒï¼šå›è»¢å¼¾å¹•
    spinCd: 8, spinInterval: 12.0, spinPhase: 'idle', spinAngle: 0,
    // â˜…æ–°æ”»æ’ƒï¼šå›è»¢çªé€²
    chargeCd: 20, chargeInterval: 25.0, chargePhase: 'idle', chargeBlinkTime: 0,
    chargeStartPos: null, chargeTargetPos: null, chargeSpeed: 800,
    // â˜…ã‚·ãƒ¼ãƒ«ãƒ‰ä¸‰è§’ï¼ˆå¼¾ã‚’é€šã•ãªã„ï¼‰
    shieldAngle: 0,
    shieldCount: 3,
    shieldRadius: 160, // â˜…120â†’160ï¼ˆã•ã‚‰ã«æ‹¡å¤§ï¼‰
    shieldSpeed: 1.8   // â˜…1.0â†’1.8ï¼ˆå›è»¢é€Ÿåº¦ã‚¢ãƒƒãƒ—ï¼‰
  };

  state.enemies.push(e);
  state.finalSpawnAt = state.timeSec || 0;
  state.bossBonus = 0;

  flashBossMsg();
  playBossWarningSound(true);
}

  requestAnimationFrame(loop);

})();

// ============================================================
// SNSå…±æœ‰æ©Ÿèƒ½
// ============================================================

function getShareText(resultType) {
  const score = Math.floor(state.score || 0).toLocaleString();
  const kills = (state.kills || 0).toLocaleString();
  const bossKills = state.bossKills || 0;
  const timeSec = state.timeSec || 0;
  const minutes = Math.floor(timeSec / 60);
  const seconds = Math.floor(timeSec % 60);
  const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
  
  let text = '';
  const gameTitle = "10min's Survivor";
  const gameUrl = window.location.href.split('?')[0]; // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’é™¤å»
  
  if (resultType === 'clear') {
    text = `ğŸ‰ ${gameTitle} ã‚¯ãƒªã‚¢ï¼\n\n`;
    text += `â±ï¸ ã‚¿ã‚¤ãƒ : ${timeStr}\n`;
    text += `ğŸ’¯ ã‚¹ã‚³ã‚¢: ${score}ç‚¹\n`;
    text += `âš”ï¸ è¨ä¼æ•°: ${kills}ä½“\n`;
    text += `ğŸ‘‘ ãƒœã‚¹è¨ä¼: ${bossKills}ä½“\n\n`;
    if (state.mode.hardcore) {
      text += `ğŸ”¥ ãƒãƒ¼ãƒ‰ã‚³ã‚¢ãƒ¢ãƒ¼ãƒ‰ã§ã‚¯ãƒªã‚¢ï¼\n\n`;
    }
    text += `#10minsSurvivor #ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢\n`;
  } else {
    text = `${gameTitle} ã«æŒ‘æˆ¦ï¼\n\n`;
    text += `â±ï¸ ç”Ÿå­˜æ™‚é–“: ${timeStr}\n`;
    text += `ğŸ’¯ ã‚¹ã‚³ã‚¢: ${score}ç‚¹\n`;
    text += `âš”ï¸ è¨ä¼æ•°: ${kills}ä½“\n`;
    text += `ğŸ‘‘ ãƒœã‚¹è¨ä¼: ${bossKills}ä½“\n\n`;
    text += `#10minsSurvivor\n`;
  }
  
  text += gameUrl;
  
  return text;
}

function shareToTwitter(resultType) {
  const text = getShareText(resultType);
  const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
  window.open(url, '_blank', 'width=550,height=420');
}

function shareToLine(resultType) {
  const text = getShareText(resultType);
  const url = `https://social-plugins.line.me/lineit/share?text=${encodeURIComponent(text)}`;
  window.open(url, '_blank', 'width=550,height=420');
}

function copyShareText(resultType) {
  const text = getShareText(resultType);
  
  // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(() => {
      showCopyNotification();
    }).catch(() => {
      fallbackCopy(text);
    });
  } else {
    fallbackCopy(text);
  }
}

function fallbackCopy(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  
  try {
    document.execCommand('copy');
    showCopyNotification();
  } catch (err) {
    alert('ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã§ã—ãŸ');
  }
  
  document.body.removeChild(textarea);
}

function showCopyNotification() {
  // æ—¢å­˜ã®é€šçŸ¥ãŒã‚ã‚Œã°å‰Šé™¤
  const existing = document.getElementById('copyNotification');
  if (existing) existing.remove();
  
  const notification = document.createElement('div');
  notification.id = 'copyNotification';
  notification.textContent = 'ğŸ“‹ ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼';
  notification.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(16, 185, 129, 0.95);
    color: white;
    padding: 1rem 1.5rem;
    border-radius: 0.5rem;
    font-weight: 700;
    z-index: 99999;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    animation: fadeInOut 2s ease-in-out;
  `;
  
  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾©
  if (!document.getElementById('copyNotificationStyle')) {
    const style = document.createElement('style');
    style.id = 'copyNotificationStyle';
    style.textContent = `
      @keyframes fadeInOut {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        15% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.remove();
  }, 2000);
}



</script>


<!-- Floating Joystick -->
<div id="joyBase"></div>
<div id="joyKnob"></div>




</body>

</html>
